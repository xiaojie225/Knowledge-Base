# 使用 JS 反转单向链表 - 什么是链表

## 目录

- [链表的概念与重要性](#链表的概念与重要性)
- [链表与数组的区别](#链表与数组的区别)
- [链表的数据结构](#链表的数据结构)
- [TypeScript 实现链表节点](#typescript-实现链表节点)
- [创建链表的实现](#创建链表的实现)
- [AI 总结](#ai-总结)

---

## 链表的概念与重要性

### 什么是链表

链表是一种基础的数据结构，分为**单向链表**和**双向链表**两种类型。

- **单向链表**：每个节点只有一个指向下一个节点的引用，就像自行车链条一样，一个节点连接下一个节点
- **双向链表**：除了指向下一个节点的引用外，还有指向前一个节点的引用

形象化理解：
- 单向链表：A → B → C → D
- 双向链表：A ⇄ B ⇄ C ⇄ D

### 为什么前端要学习链表

虽然链表在前端开发中并不常用，但在面试中出现频率极高，原因包括：

1. **工作与面试的区别**：工作能力强不代表面试能力强，反之亦然
2. **考察基础功底**：链表是计算机科学中最基本的概念，通过链表题目可以判断应聘者是否受过专业的计算机基础训练
3. **数据结构算法考察**：在数据结构和算法面试中，链表题目的概率非常高，是筛选优秀工程师的重要手段

### 反转链表的含义

反转单向链表是指将链表的方向完全颠倒：

- **输入**：A → B → C → D
- **输出**：D → C → B → A

就像司马懿领兵遇到诸葛亮空城计时掉头撤退一样，头变成尾，尾变成头。

---

## 链表与数组的区别 

### 链表是物理结构

链表是一种**物理结构**（而非逻辑结构，不要与栈、队列混淆）：

- 每种编程语言都可以实现链表
- 有些语言自带链表（如 Java、Python）
- JavaScript 没有内置链表，需要自己实现

### 存储方式的根本差异

**数组的特点**：
- 需要一段**连续的内存空间**
- 就像教室里一排连续的桌子：A 同学、B 同学、C 同学、D 同学、E 同学依次坐在一起
- 插入或删除中间元素时，需要移动大量元素
- 例如要把 E 插入到 A 之前，需要先移除 D、C、B、A，然后放入 E，再依次放回其他元素

**链表的特点**：
- 采用**零散的内存存储**
- 节点可以分散在内存的不同位置
- 通过引用（指针）连接各个节点
- 插入或删除操作只需改变引用关系，不需要移动其他元素

### 操作复杂度对比

在中间插入元素时：
- **数组**：需要移动多个元素，操作复杂
- **链表**：只需改变两个引用，理想时间复杂度为 O(1)

这种差异使得数组和链表各有用途，能够共同存在并完成各自的任务。

---

## 链表的数据结构 

### 链表节点的基本结构

链表节点通常是一个对象，包含以下属性：

1. **value**：存储节点的值
2. **next**：指向下一个节点的引用（单向链表）
3. **prev**：指向前一个节点的引用（双向链表特有）

### 单向链表与双向链表的表示

**单向链表**：
- 只有 `next` 属性
- 通过 `next` 指向下一个节点
- 最后一个节点的 `next` 为空

**双向链表**：
- 既有 `next` 又有 `prev`
- `next` 指向下一个节点
- `prev` 指向前一个节点
- 头节点只有 `next`，没有 `prev`
- 尾节点只有 `prev`，没有 `next`

### JavaScript 示例代码

```javascript
// 创建单向链表节点
const n1 = { value: 100 };
const n2 = { value: 200 };
const n3 = { value: 300 };
const n4 = { value: 400 };

// 建立单向链接
n1.next = n2;
n2.next = n3;
n3.next = n4;
n4.next = null; // 尾节点

// 如果是双向链表，还需要添加 prev
n2.prev = n1;
n3.prev = n2;
n4.prev = n3;
n1.prev = null; // 头节点
```

### 链表的访问方式

- **返回链表**通常返回**头节点**
- 因为链表是连续结构，只要抓住头节点，就能通过 `next` 访问所有后续节点
- 双向链表还可以从尾节点开始，通过 `prev` 反向访问
- 单向链表只能从头到尾访问

---

## TypeScript 实现链表节点 

### 定义链表节点接口

```typescript
// 定义链表节点的类型
interface ILinkList {
  value: number;
  next?: ILinkList; // 可选属性，因为最后一个节点没有 next
}
```

**接口说明**：
- `value: number`：节点存储的值（这里用 number 类型，也可以是字符串或对象）
- `next?: ILinkList`：指向下一个节点的引用
- `?` 表示可选，因为链表的最后一个节点没有 `next`

### 创建链表的函数签名

```typescript
/**
 * 根据数组创建链表
 * @param arr 输入的数组
 * @returns 返回链表的头节点
 */
function createLinkList(arr: number[]): ILinkList {
  // 实现代码
}
```

**函数说明**：
- 输入：一个 `number` 类型的数组
- 输出：返回链表的头节点
- 头节点类型为 `ILinkList`

---

## 创建链表的实现 

### 实现思路

从数组的**最后一个元素**开始，逐步往前创建节点，因为：
- 链表是从前到后访问的
- 最后一个节点没有 `next`
- 从后往前构建，每次创建的新节点可以将之前创建的节点作为 `next`

### 完整实现代码

```typescript
/**
 * 根据数组创建链表
 */
function createLinkList(arr: number[]): ILinkList {
  const length = arr.length;
  
  // 边界情况：数组为空
  if (length === 0) {
    throw new Error('数组不能为空');
  }
  
  // 创建最后一个节点
  let curNode: ILinkList = {
    value: arr[length - 1]
    // 最后一个节点没有 next
  };
  
  // 如果数组只有一个元素，直接返回
  if (length === 1) {
    return curNode;
  }
  
  // 从倒数第二个元素开始，往前遍历
  for (let i = length - 2; i >= 0; i--) {
    curNode = {
      value: arr[i],
      next: curNode // 当前节点的 next 指向之前创建的节点
    };
  }
  
  return curNode; // 返回头节点
}
```

### 代码执行过程详解

以数组 `[100, 200, 300, 400, 500]` 为例：

**第 1 步**：创建最后一个节点
```typescript
curNode = { value: 500 }
// 没有 next
```

**第 2 步**：i = 3（倒数第二个）
```typescript
curNode = {
  value: 400,
  next: { value: 500 }
}
```

**第 3 步**：i = 2
```typescript
curNode = {
  value: 300,
  next: {
    value: 400,
    next: { value: 500 }
  }
}
```

**第 4 步**：i = 1
```typescript
curNode = {
  value: 200,
  next: {
    value: 300,
    next: {
      value: 400,
      next: { value: 500 }
    }
  }
}
```

**第 5 步**：i = 0（头节点）
```typescript
curNode = {
  value: 100,
  next: {
    value: 200,
    next: {
      value: 300,
      next: {
        value: 400,
        next: { value: 500 }
      }
    }
  }
}
```

最终返回的 `curNode` 就是完整链表的头节点。

### 测试代码

```typescript
const arr = [100, 200, 300, 400, 500];
const list = createLinkList(arr);
console.log(list);
```

**输出结果**：
```
{
  value: 100,
  next: {
    value: 200,
    next: {
      value: 300,
      next: {
        value: 400,
        next: {
          value: 500
        }
      }
    }
  }
}
```

### 验证链表结构

- `list.value` = 100（头节点）
- `list.next.value` = 200
- `list.next.next.value` = 300
- `list.next.next.next.value` = 400
- `list.next.next.next.next.value` = 500
- `list.next.next.next.next.next` = undefined（最后一个节点没有 next）

这样就成功通过数组创建了一个单向链表。

---

## AI 总结

本节课详细讲解了链表的基础知识和在 JavaScript/TypeScript 中的实现：

**核心要点**：
1. **链表概念**：链表是一种物理数据结构，分为单向链表和双向链表，通过节点间的引用连接
2. **面试重要性**：虽然前端开发中不常用，但链表是面试高频题，用于考察计算机基础功底
3. **与数组对比**：数组需要连续内存且插入删除复杂，链表零散存储且操作灵活
4. **TypeScript 实现**：通过接口定义节点结构，实现从数组创建链表的函数
5. **实现技巧**：从数组末尾开始逆向构建链表，每次将新节点的 next 指向前一个创建的节点

**下一步学习**：基于本节创建的链表结构，下一节将实现反转单向链表的算法，将 A→B→C→D 转换为 D→C→B→A。