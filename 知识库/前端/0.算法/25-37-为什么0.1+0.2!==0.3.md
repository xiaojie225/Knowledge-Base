# 为什么 0.1 + 0.2 !== 0.3

## 目录

- [问题本质](#问题本质)
- [整数与小数的二进制转换](#整数与小数的二进制转换)
- [跨语言的普遍现象](#跨语言的普遍现象)
- [实际表现](#实际表现)
- [解决方案与建议](#解决方案与建议)
- [推荐资源](#推荐资源)
- [AI 总结](#ai-总结)

## 问题本质

这个问题本质上是一个二进制的问题，但更多的是一个应用问题。面试考察这个问题的主要目的是：

- 避免开发者在实际工作中因不知道 `0.1 + 0.2 !== 0.3` 这种情况而出现 bug
- 即使不深入理解底层原理也不会太影响工作，但如果完全不知道这个现象，可能会在出现 bug 后还不自知，从而耽误整体工作进度

**重点**：知道这个现象的存在比深究底层原理更重要。

## 整数与小数的二进制转换

### 整数转换

计算机使用二进制来存储数据。整数转化为二进制是**没有误差**的：

- 9 转化为二进制：`1001`
- 10 转化为二进制：`1010`
- 8 转化为二进制：`1000`

可以通过转换器验证这些转换都是精确的。

### 小数转换的问题

小数可能会出现二进制表示的问题，因为**小数不能完全用二进制准确表达**：

- 例如 0.2 转化为二进制会变成 `0.00110011001100...`（无限循环下去）
- 由于无法完全转换，只能采取**取精度、忽略低几位**的方式来处理

这不是某个编程语言的问题，而是数学本身的限制。

## 跨语言的普遍现象

这个问题不仅存在于 JavaScript 中：

- 所有编程语言都有这个问题
- 所有基于计算机的计算都会遇到
- 所有用二进制表示数据的计算系统都会有这种效果

## 实际表现

在 JavaScript 中执行 `0.1 + 0.2`：

```javascript
0.1 + 0.2  // 结果：0.30000000000000004
```

这个结果已经经过了精度转化。如果不做取舍，后面还会有更长的小数位。

因此：`0.1 + 0.2 === 0.3` 返回 `false`

**需要注意**：可能其他小数相加也并不相等，这个现象必须知道，知道之后才能避坑。

## 解决方案与建议

### 理解程度

对于面试和实际工作：

- 知道这个现象的存在是最根本的
- 大概知道是因为小数存储为二进制造成的
- 理解是因为无法准确表达造成的
- 这样就足够了，再深入对实际工作没有太大帮助

### 使用第三方库

如果经常操作小数且需要精确计算，建议使用第三方库：

**推荐库**：`Math.js`

- 下载量很大
- 提供各种函数，允许进行比较准确的计算
- 包含加法（add）、四舍五入（round）等功能

**使用建议**：

- 不是所有项目都需要使用
- 如果经常使用小数并且要求精度，最好使用第三方库
- 不要自己去想哪些情况会不相等（想不穷尽）
- 使用第三方库是最好的方式

## 推荐资源

### 书籍推荐

**《编程世界》** - 松本行弘（Ruby 语言创始人）著

- 出版时间：2011年
- 特点：通俗易懂，讲解了很多关于计算机编程的底层知识
- 作者作为编程语言的创造者，对底层原理讲解深入
- 这本书曾给作者带来很大启发
- 虽然是较老的书，但有时间可以买来看看（不是必须）

## AI 总结

`0.1 + 0.2 !== 0.3` 是由于计算机使用二进制存储数据导致的。小数在转换为二进制时可能无法精确表示（如 0.2 会变成无限循环的二进制小数），因此只能通过取精度来近似存储。这个问题存在于所有使用二进制的编程语言和计算系统中。

对于开发者来说，最重要的是**知道这个现象的存在**，而不必深究复杂的底层原理。在实际开发中，如果需要进行精确的小数计算，应该使用专门的第三方库（如 Math.js）来避免精度问题，而不是自己尝试处理各种边界情况。