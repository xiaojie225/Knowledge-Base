# 斐波那契数列第n值优化 - 时间复杂度优化

## 目录

- [优化思路：从递归到循环](#优化思路从递归到循环)
- [代码实现](#代码实现)
- [单元测试](#单元测试)
- [动态规划思想](#动态规划思想)
- [算法思维总结](#算法思维总结)
- [AI 总结](#ai-总结)

## 优化思路：从递归到循环

### 性能问题分析

之前的递归实现性能慢的根本原因是**大量重复计算**：

- 计算 F(6) 需要计算 F(5) + F(4)
- 计算 F(7) 需要计算 F(6) + F(5)
- F(5) 和 F(6) 被重复计算

### 优化方案

**核心思想**：记录中间结果，避免重复计算

- 如果把 F(6)、F(5) 的结果记录下来，每次求值只需要将前两个结果相加
- 时间复杂度优化为 O(n)：有多少个数就计算多少次

## 代码实现

### 循环实现

```javascript
function fibonacci(n) {
  // 边界条件
  if (n === 0) return 0;
  if (n === 1) return 1;
  
  // 初始化变量
  let n1 = 1;  // 记录 F(n-1) 的结果
  let n2 = 0;  // 记录 F(n-2) 的结果
  let result = 0;  // 存储当前计算结果
  
  // 从索引 2 开始循环（0 和 1 已经固定）
  for (let i = 2; i <= n; i++) {
    result = n1 + n2;  // 当前值 = 前两个值之和
    
    // 更新中间结果，整体后移
    n2 = n1;      // n2 指向原来的 n1
    n1 = result;  // n1 指向当前结果
  }
  
  return result;
}
```

### 关键点说明

**为什么循环从 2 开始？**

- F(0) = 0 和 F(1) = 1 是固定值，不需要计算
- 只有从 F(2) 开始，才需要计算前两个值的和
- F(2) = F(1) + F(0) = 1 + 0 = 1

**中间结果更新机制**：

以计算 F(7) 为例，当前 n1 指向 8，n2 指向 5：
1. `result = n1 + n2 = 8 + 5 = 13`
2. `n2 = n1`（n2 移动到 8）
3. `n1 = result`（n1 移动到 13）
4. 下一轮可以继续计算 F(8) = 13 + 8 = 21

## 单元测试

```javascript
describe('斐波那契数列', () => {
  // 测试边界情况
  it('应该正确处理 n=0 和 n=1', () => {
    expect(fibonacci(0)).toBe(0);
    expect(fibonacci(1)).toBe(1);
  });
  
  // 测试正常情况
  it('应该正确计算斐波那契数列', () => {
    expect(fibonacci(2)).toBe(1);
    expect(fibonacci(3)).toBe(2);
    expect(fibonacci(6)).toBe(8);
  });
  
  // 测试特殊情况
  it('应该处理 n < 0 的情况', () => {
    expect(fibonacci(-1)).toBe(0);
  });
});
```

**测试用例说明**：

- F(0) = 0, F(1) = 1（基础情况）
- F(2) = 1, F(3) = 2, F(6) = 8（正常计算）
- n < 0 时返回 0（边界处理）

## 动态规划思想

### 什么是动态规划

动态规划是一种算法思维，核心是**把大问题拆解成小问题**，逐级向下拆解。

### 斐波那契数列的拆解过程

以 F(34) 为例：

```
F(34) = F(21) + F(13)
F(21) = F(13) + F(8)
F(13) = F(8) + F(5)
F(8) = F(5) + F(3)
F(5) = F(3) + F(2)
...
最终到达：F(0) = 0, F(1) = 1
```

**特点**：

- 每个问题可以拆成两个子问题
- 子问题的逻辑规则相同
- 一直拆解到最底层的基础规则

### 递归分析 vs 循环实现

**用递归思路分析问题**：
- 清晰地展示问题的拆解过程
- 容易理解问题的本质结构

**用循环实现代码**：
- 避免递归带来的重复计算
- 通过记录中间结果提升性能
- 时间复杂度从指数级降到线性

**结论**：分析思路可以用递归方式，但实现时要考虑性能，必要时改用循环并记录中间结果。

## 算法思维总结

### 三大核心算法思维

**1\. 贪心算法**

- 每一步都选择当前最优解
- 例如：二叉树的中序遍历（先左、再中、再右）
- 一旦有左节点就一直往下找，直到最底层

**2\. 二分法**

- 将问题空间不断二分
- 非常高效的查找和解决问题的方式

**3\. 动态规划**

- 大问题拆解成小问题
- 找到问题的递推关系
- 确定边界条件

### 递归 vs 思维

- **递归是方法**，不是思维
- **思维是贪心、二分、动态规划**
- 掌握这三种思维，基本可以解决所有算法题目

## AI 总结

本节课讲解了如何优化斐波那契数列的计算，将递归实现改为循环实现，通过记录中间结果避免重复计算，使时间复杂度从指数级优化到 O(n)。

核心要点：
1. 使用 n1 和 n2 记录前两个结果，result 存储当前计算值
2. 循环从索引 2 开始（0 和 1 是固定值）
3. 每次迭代后整体后移：n2 = n1, n1 = result

同时引入了**动态规划**的概念：用递归思路分析问题（大问题拆小问题），用循环方式实现代码（记录中间结果）。动态规划与贪心、二分并列为算法的三大核心思维，掌握这些思维可以解决绝大多数算法问题。