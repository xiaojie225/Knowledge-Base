# 用 JS 实现二分查找 - 递归和循环哪个更好

## 目录

- [循环与递归的性能对比](#循环与递归的性能对比)
- [性能测试实验](#性能测试实验)
- [性能差异的原因分析](#性能差异的原因分析)
- [递归与循环的各自优势](#递归与循环的各自优势)
- [二分查找的核心要点](#二分查找的核心要点)
- [AI 总结](#ai-总结)

---

## 循环与递归的性能对比

在二分查找的实现中,循环和递归这两种方式都可以达到相同的时间复杂度,都是 $O(\log N)$ 级别,效率都很高。但如果较真地对比细节,**循环会比递归稍微快一些**。

需要注意的是,这里说的"快慢"并不是数量级或复杂度级别上的差异,而是在细节实现上的性能差异。两者的时间复杂度完全相同,只是在实际执行时会有一些微小的性能差别。

## 性能测试实验

为了验证循环和递归的性能差异,可以进行一个性能测试:

### 测试方法

1. 实现两个版本的二分查找:
   - `binarySearch1`: 循环实现
   - `binarySearch2`: 递归实现

2. 测试代码结构:
   - 准备一个数组
   - 对每个方法执行 **100 万次** 调用(数量要足够大,因为这两个方法效率都很高,数量太小看不出区别)
   - 使用 `console.time()` 测量执行时间

3. 多次测试以确保结果稳定

### 测试结果

根据实际测试,结果大致如下:
- 循环实现: **17 毫秒**
- 递归实现: **34 毫秒**

递归实现的时间约为循环实现的 **2 倍**。虽然差了 2 倍,但从数量级上看,17 毫秒和 34 毫秒实际上是在同一个数量级,这是一个较真层面的性能差异,并不是像其他算法对比那样差了好几个数量级。

## 性能差异的原因分析

### 循环实现的优势

循环实现的特点:
- **只调用一次函数**
- 函数内部通过循环不断执行,对变量进行赋值
- 函数调用开销小

对于 100 万次计算,可能只调用了 **100 万次** `binarySearch1` 函数。

### 递归实现的劣势

递归实现的特点:
- **需要频繁调用多次函数**
- 每次递归都是一次新的函数调用
- 每次函数调用都有额外开销

对于 100 万次计算,需要调用 **远超 100 万次** `binarySearch2` 函数(因为每次递归都会多次调用自身)。

### 核心原因

**每次函数调用都有开销**:
- 如果只调用一次函数,函数内部的代码随便写、随便循环、变量随便赋值,开销比较小
- 如果在函数里面不断套函数、继续调用函数,每调用一次函数,开销就会多一点

这就是为什么循环比递归性能更好的根本原因 - **循环减少了函数调用次数,而递归需要不停地调用函数**。

## 递归与循环的各自优势

### 递归的优势

1. **代码逻辑更加清晰简洁**
2. 对于理解算法的人来说,**递归更容易理解**
3. 在某些复杂问题中,递归实现会简单很多

**应用场景举例**:
- 树的遍历(广度优先遍历、深度优先遍历)
- 用递归实现非常简单、代码清晰
- 用循环实现则会变得非常麻烦

虽然二分查找相对简单,体现不太明显,但在更复杂的问题中,递归的优势会更加突出。

### 循环的优势

1. **性能更好**
2. 减少函数调用开销
3. 在简单问题中实现起来也很直观

### 总结对比

| 特性 | 递归 | 循环 |
|------|------|------|
| 代码清晰度 | ✅ 更清晰简洁 | ❌ 相对复杂 |
| 性能 | ❌ 稍慢(函数调用开销) | ✅ 更快 |
| 适用场景 | 复杂算法(如树遍历) | 简单迭代 |

**重要提醒**: 递归的性能劣势是"较真层面"的,并不是复杂度级别或数量级级别的差异。

## 二分查找的核心要点

### 1\. 前提条件

**凡有序,必二分**:
- "有序"指可排序的,比如从小到大或从大到小
- 只要数据是可排序的,都可以用二分法进行查找
- 中间一分,然后在左边或右边继续查找

### 2\. 时间复杂度

**凡二分,时间复杂度必包含 $O(\log N)$**:
- 注意是"包含",不一定完全相等
- 有时候二分的基础上还会加其他算法,比如"二分 + 贪心"
- 时间复杂度可能是 $O(\log N)$ 加上其他部分

**后续相关内容**:
- 快速排序(QuickSort)也包含 $O(\log N)$,但不等于 $O(\log N)$
- 这个在后面的课程中会重点讲解

### 3\. 实现方式选择

- 递归: 让代码思路更清晰、更简洁
- 非递归(循环): 性能更好

但要记住,这个"性能更好"是较真细节层面的,并不是复杂度级别或数量级级别的优势。

---

## AI 总结

本节课深入对比了二分查找的两种实现方式:

**性能对比**: 通过 100 万次调用的实际测试,循环实现(17ms)比递归实现(34ms)快约 2 倍,但这是细节层面的差异,两者时间复杂度都是 $O(\log N)$。

**差异原因**: 循环只需调用一次函数,而递归需要频繁调用多次函数,每次函数调用都有额外开销,这是性能差异的根本原因。

**如何选择**: 递归代码更清晰简洁,特别适合复杂问题(如树遍历);循环性能更优,适合追求极致性能的场景。

**核心原则**: 凡有序必二分,凡二分时间复杂度必包含 $O(\log N)$。在实际开发中,应根据具体场景权衡代码可读性和性能需求来选择实现方式。