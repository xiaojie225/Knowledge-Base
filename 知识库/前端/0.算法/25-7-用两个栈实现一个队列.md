# 用两个栈实现一个队列

## 目录

- [队列与栈的基本概念](#队列与栈的基本概念)
- [逻辑结构与物理结构](#逻辑结构与物理结构)
- [用两个栈实现队列的思路](#用两个栈实现队列的思路)
- [代码实现](#代码实现)
- [测试验证](#测试验证)
- [性能分析](#性能分析)
- [AI 总结](#ai-总结)

---

## 队列与栈的基本概念

**栈（Stack）** 是一种**先进后出**（FILO）的数据结构，类似于一摞盘子，最后放上去的最先被取出。

**队列（Queue）** 是一种**先进先出**（FIFO）的数据结构，类似于排队打饭或买咖啡，谁先排队谁先被服务，后来的人只能依次等待。

### 队列的基本操作

队列的核心操作包括：

- **入队（enqueue/add）**：在队列尾部添加一个元素
- **出队（dequeue/delete）**：从队列头部删除一个元素
- **长度（length/size）**：获取队列中元素的数量

不同的队列实现中，方法名称可能不同，但功能是一致的。队列有队头和队尾的概念，入队在队尾进行，出队在队头进行。

### 用数组实现队列

可以使用数组实现队列：

```javascript
const queue = [];
queue.push(1);  // 入队
queue.push(2);  // 入队
queue.push(3);  // 入队
const result = queue.shift();  // 出队，返回 1
```

**性能问题**：使用数组实现队列时，`push()` 操作很快，但 `shift()` 或 `splice()` 操作较慢。这是因为数组是有序的连续内存存储结构，执行 `shift()` 时需要移动所有后续元素。

虽然数组实现队列存在性能问题，但为了学习队列的基本概念，我们暂时不深究这个问题。后续会介绍用**链表**实现队列，可以避免 `shift()` 的性能问题。

---

## 逻辑结构与物理结构 

**重要概念区分**：

- **逻辑结构**：队列、栈等是逻辑结构，是一种抽象模型，描述数据之间的逻辑关系
- **物理结构**：数组、链表等是物理结构，是实际的存储实现方式

### 关键理解

- 队列和栈是逻辑结构，可以用不同的物理结构实现（数组、链表等）
- 数组和链表是物理结构，需要分析具体的性能、存储和复杂度
- **不要混淆**：队列和栈可以放在一起比较，数组和链表可以放在一起比较，但这两组之间不应混为一谈

### 消息队列示例

在实际应用中，消息队列（Message Queue）是一个服务级别的实现：

- 生产端（Service A）产生大量消息，发送到消息队列
- 消息队列维护一个队列结构，保存这些消息
- 消费端从队列中获取消息进行处理（如存入数据库、数据分析等）

消息队列作为一个第三方服务，可能需要几万甚至几十万行代码实现，但其本质仍然是一个队列的逻辑结构。这说明：

- 逻辑结构是高层抽象
- 底层实现可以简单（如用数组），也可以复杂（如完整的消息队列服务）
- 对于物理结构（数组、链表），需要分析性能、存储、复杂度等具体问题

---

## 用两个栈实现队列的思路 

### 问题分析

**面试准备**：建议带纸、笔、简历和笔记本。纸和笔用于画图分析，笔记本用于现场编码（在纸上写代码会很难受）。

### 图解分析

假设有一个队列，队尾在左，队头在右：

```
队列: [A, B, C]
      队尾 → 队头
```

入队顺序：A → B → C  
出队顺序：A → B → C（先进先出）

现在用两个栈（Stack1 和 Stack2）实现这个队列。

#### 入队操作

入队时，直接将元素压入 Stack1：

```
入队 A: Stack1: [A]
入队 B: Stack1: [A, B]
入队 C: Stack1: [A, B, C]
```

#### 出队操作（三步走）

出队操作比较复杂，需要三个步骤：

**第一步**：将 Stack1 的所有元素移动到 Stack2

```
Stack1: [A, B, C]  →  Stack2: [C, B, A]
                       (栈顶)
```

通过不断从 Stack1 弹出元素，压入 Stack2，顺序就反转了。

**第二步**：从 Stack2 弹出栈顶元素（这就是要出队的元素）

```
Stack2.pop() → 返回 A
Stack2: [C, B]
```

**第三步**：将 Stack2 的剩余元素还回 Stack1

```
Stack2: [C, B]  →  Stack1: [B, C]
```

这样做是为了方便后续的入队操作。如果不还回去，下次入队 D 时，D 会和 B 靠在一起，顺序就乱了。

### 完整流程示例

**初始状态**：
- 入队 A、B、C → Stack1: [A, B, C]

**出队 A**：
1. Stack1 倒入 Stack2: Stack2: [C, B, A]
2. Stack2 弹出 A
3. Stack2 还回 Stack1: Stack1: [B, C]

**继续入队 D、E**：
- Stack1: [B, C, D, E]

**出队 B**：
1. Stack1 倒入 Stack2: Stack2: [E, D, C, B]
2. Stack2 弹出 B
3. Stack2 还回 Stack1: Stack1: [C, D, E]

### 操作步骤总结

- **入队**：只需一步操作，直接 `Stack1.push()`
- **出队**：需要三步操作：
  1. 将 Stack1 倒入 Stack2
  2. 从 Stack2 弹出栈顶元素
  3. 将 Stack2 还回 Stack1

**建议**：自己在纸上画一遍流程，动手画图可以帮助理解和记忆。这也是面试时的重要技巧。

---

## 代码实现 

创建文件 `TwoStackOneQueue.ts`：

```typescript
/**
 * 两个栈实现一个队列
 */

class MyQueue {
  private stack1: number[] = [];
  private stack2: number[] = [];

  /**
   * 入队 - 将元素添加到队尾
   */
  add(n: number): void {
    this.stack1.push(n);
  }

  /**
   * 出队 - 从队头删除元素并返回
   */
  delete(): number | null {
    let result: number | null = null;

    const stack1 = this.stack1;
    const stack2 = this.stack2;

    // 第一步: 将 stack1 所有元素移动到 stack2
    while (stack1.length) {
      const n = stack1.pop();
      if (n != null) {
        stack2.push(n);
      }
    }

    // 第二步: 执行 stack2.pop()
    result = stack2.pop() || null;

    // 第三步: stack2 所有元素再还给 stack1
    while (stack2.length) {
      const n = stack2.pop();
      if (n != null) {
        stack1.push(n);
      }
    }

    // 返回结果
    return result;
  }

  /**
   * 获取队列长度
   */
  get length(): number {
    return this.stack1.length;
  }
}
```

### 代码说明

**private 关键字**：
- `stack1` 和 `stack2` 使用 `private` 修饰，表示私有属性
- 只能在类内部访问，外部无法通过 `myQueue.stack1` 访问
- 但可以通过公开的方法 `add()`、`delete()`、`length` 访问

**getter 语法**：
- `get length()` 是 getter 语法，虽然写法像函数，但调用时像属性
- 使用方式：`myQueue.length`（不需要括号）

**实现逻辑**：
- `add()` 方法：直接 `this.stack1.push(n)`，时间复杂度 $O(1)$
- `delete()` 方法：按照三步走的流程实现，时间复杂度 $O(n)$
- `length` 属性：返回 `stack1` 的长度，因为所有数据最终都存储在 `stack1` 中

---

## 测试验证 

### 手动测试

在 `index.js` 中进行测试：

```javascript
const myQueue = new MyQueue();

myQueue.add(100);
myQueue.add(200);
myQueue.add(300);

console.log(myQueue.length);  // 输出: 3
console.log(myQueue.delete());  // 输出: 100
console.log(myQueue.length);  // 输出: 2
console.log(myQueue.delete());  // 输出: 200
console.log(myQueue.length);  // 输出: 1
```

运行结果：`3, 100, 2`，符合预期。

### 单元测试

创建测试文件 `TwoStackOneQueue.test.ts`：

```typescript
/**
 * 两个栈实现一个队列 - 测试
 * @author [作者名]
 */

import { MyQueue } from './TwoStackOneQueue';

describe('两个栈实现一个队列', () => {
  it('add 和 length', () => {
    const q = new MyQueue();
    expect(q.length).toBe(0);
    
    q.add(100);
    q.add(200);
    q.add(300);
    
    expect(q.length).toBe(3);
  });

  it('delete', () => {
    const q = new MyQueue();
    
    // 空队列删除应返回 null
    expect(q.delete()).toBeNull();
    
    // 添加元素
    q.add(100);
    q.add(200);
    q.add(300);
    
    // 删除第一个元素
    expect(q.delete()).toBe(100);
    expect(q.length).toBe(2);
    
    // 删除第二个元素
    expect(q.delete()).toBe(200);
    expect(q.length).toBe(1);
  });
});
```

运行单元测试，所有测试用例通过。

**关于 getter 语法**：
- `length` 虽然写成函数形式，但前面加了 `get` 关键字
- 调用时使用属性方式：`q.length`（不需要括号）
- 这是 TypeScript/JavaScript 的 getter 语法糖

---

## 性能分析 

### 时间复杂度

- **add() 操作**：$O(1)$  
  只需要一次 `push()` 操作，非常简单。

- **delete() 操作**：$O(n)$  
  需要进行两次循环：
  1. 将 `stack1` 循环倒入 `stack2`
  2. 将 `stack2` 循环还回 `stack1`
  
  虽然是两个 $n$，理论上是 $O(2n)$，但算法复杂度讲的是**数量级**，$2n$ 和 $n$ 的数量级相同，所以时间复杂度是 $O(n)$。因为只有一层循环（没有嵌套循环），所以是线性时间。

### 空间复杂度

整体空间复杂度：$O(n)$

因为两个栈中存储的数据总量就是队列中的元素数量。虽然数据在两个栈之间倒来倒去，但并没有额外存储更多数据，只是位置变化。队列多长，栈存储的数据就是多长。

---

## AI 总结

本节课详细讲解了如何用两个栈实现一个队列，这是一道经典的数据结构面试题。

**核心知识点**：

1. **队列与栈的区别**：队列是先进先出（FIFO），栈是先进后出（FILO）
2. **逻辑结构与物理结构**：队列和栈是逻辑结构（抽象模型），数组和链表是物理结构（实际存储）。不要混淆这两个层次
3. **实现思路**：利用两个栈的倒转特性实现队列的先进先出
   - 入队：直接压入 Stack1
   - 出队：三步操作（Stack1 → Stack2 → 弹出 → Stack2 → Stack1）
4. **画图分析**：面试时带纸笔，通过画图能更清晰地理解和表达思路
5. **性能分析**：入队 $O(1)$，出队 $O(n)$，空间 $O(n)$

队列是非常重要的数据结构，在实际开发中应用广泛（如消息队列）。理解队列的本质和实现原理，对于深入学习数据结构和算法至关重要。