# 空间复杂度

## 目录

- [空间复杂度基本概念](#空间复杂度基本概念)
- [前端开发中的复杂度侧重点](#前端开发中的复杂度侧重点)
- [常见空间复杂度](#常见空间复杂度)
- [空间复杂度示例](#空间复杂度示例)
- [算法复杂度的重要性](#算法复杂度的重要性)
- [时间复杂度的实际影响](#时间复杂度的实际影响)
- [实际案例Vue虚拟DOM的Diff算法](#实际案例vue虚拟dom的diff算法)
- [学习建议](#学习建议)
- [AI 总结](#ai-总结)

## 空间复杂度基本概念

空间复杂度指的是**程序执行时需要的内存空间**。相比时间复杂度,空间复杂度的概念相对简单一些。

空间复杂度与时间复杂度类似,也使用大O符号表示数量级。主要包括:

- **$O(1)$**: 常量空间复杂度,需要固定的、可数的空间,与数据量无关
- **$O(n)$**: 线性空间复杂度,所需空间与数据量相同

其他如 $O(\log n)$ 或 $O(n^2)$ 在空间复杂度中不太常见。

### 空间复杂度的直观理解

- **$O(1)$ 的情况**: 无论数据量多大,需要的空间都是固定的。可能是1个空间、2个空间或3个空间,但总是可数的、恒定的,与输入数据量没有关系。

- **$O(n)$ 的情况**: 如果数据量是10,需要的空间就是10;如果数据量是6,需要的空间就是6。所需空间与数据量直接相关。

## 前端开发中的复杂度侧重点

在前端领域,我们遵循**"重时间、轻空间"**的原则。

原因在于:
- 前端需要程序运行得更快,用户体验直接受时间影响
- 空间(内存)一般是够用的,因为前端程序都运行在浏览器里
- 现代浏览器功能强大,空间通常不是瓶颈

**这与后端或嵌入式开发不同**:后端和嵌入式开发(如单片机)的内存比较小,需要精打细算地使用空间。但对于前端来说,**时间复杂度才是最关键的**。

## 常见空间复杂度

### $O(1)$ 常量空间

定义固定数量的变量,无论数据量多大,占用的空间都是恒定的。

```javascript
function example1(data) {
  const a = data[0];  // 定义第一个元素
  const b = data[1];  // 定义第二个元素
  // 即使写100个变量也是O(1)
  // 因为只是定义了固定数量的变量
  // 与数据的数据量无关
}
```

这种情况下,程序是静态的、固定的,与输入数据的数量无关,因此空间复杂度是 $O(1)$。

### $O(n)$ 线性空间

需要创建与输入数据量相同规模的额外空间。

```javascript
function example2(data) {
  const arr2 = [];  // 定义另一个数组
  
  for (let i = 0; i < data.length; i++) {
    arr2[i] = data[i];  // 复制数据到新数组
    // 后续进行其他操作
  }
}
```

在这个例子中,当传入一个数组时,数组的长度直接影响了空间占用:
- 定义了另一个数组来复制或处理原数组的数据
- 新数组的大小与输入数组的大小相关
- 输入数组有多长,就需要占用多少空间

这是**非常常见的情况**,比如:
- 先定义一个空数组
- 处理完数据后把结果存入这个数组
- 最后返回这个数组

这就是 $O(n)$ 的空间复杂度,在实际开发中很常见。

## 空间复杂度示例

通过代码示例可以更清楚地理解空间复杂度:

**$O(1)$ 示例**:
```javascript
// 只定义固定数量的变量
const a = data[0];
const b = data[1];
// 屏幕上静态地写,写100个也是O(1)
```

**$O(n)$ 示例**:
```javascript
// 创建与输入数据同等规模的新数据结构
const arr2 = [];
for (let i = 0; i < data.length; i++) {
  arr2[i] = data[i];
}
```

## 算法复杂度的重要性

### 必须掌握复杂度概念

**所有程序员都必须掌握算法复杂度**,无论是前端还是后端。

原因:
- 算法面试题在后端和客户端面试中经常考察,因为这些领域对算法要求较高
- 前端最近几年职业越来越成熟,做得越来越广,算法也开始成为考察重点
- 现在看来,所有程序员都必须掌握算法复杂度

### 复杂度敏感度

**"敏感度"这个词很重要**。

什么是复杂度敏感度:
- 看到一个算法后,要下意识地感觉这个算法的复杂度行不行
- 要有这种下意识的感觉,形成条件反射

**如果没有这个敏感度,写程序是非常危险的**:
- 很可能写出功能上看似可以运行的代码
- 但一旦数据量增大就会崩溃
- 这就是复杂度问题导致的

### 前端的复杂度侧重

对于前端开发:**重时间、轻空间**

- **时间复杂度非常关键**,必须特别注意
- 空间复杂度一般不会有太大问题,因为不太可能占用过多空间,而且使用的空间也比较诚实
- 我们经常做性能优化,优化的主要就是时间
- 空间复杂度主要是后端和嵌入式开发需要精打细算的

## 时间复杂度的实际影响

从复杂度增长曲线图可以清楚看出不同复杂度的差异:

### 不可用的复杂度

**$O(n^2)$**: 如果写了一个时间复杂度为 $O(n^2)$ 的算法,**这个算法基本上不可用**。

从图上可以看出:
- 输入量一旦增大,计算量会急剧上升
- 如果输入量是1万,计算量就到1亿,这是非常恐怖的概念

### 理想的复杂度

我们最好能把算法的时间复杂度控制在:
- **$O(n)$ 级别**: 大部分算法应该控制在这个级别
- **$O(n \log n)$ 级别**: 少部分会到这个级别,也是可以接受的
- **$O(\log n)$ 级别**: 如果能到这个级别,那就非常非常好了

### 必须避免的复杂度

千万不要让复杂度达到:
- $O(n^2)$ (n的平方)
- $O(n^3)$ (n的3次方)
- $O(2^n)$ (2的n次方) - **注意是2的n次方,不是n的2次方,2的n次方更加恐怖**

比如后面会讲到的**斐波那契数列算法**:
- 如果使用默认的递归方式实现,复杂度会达到 $O(2^n)$
- 这个算法完全不可以用
- 数量级稍微大一点,程序就会崩溃

## 实际案例Vue虚拟DOM的Diff算法

这里可以回顾一个实际案例 - **Vue虚拟DOM的Diff算法**。

### 传统Diff算法的问题

传统的树的Diff算法:
- 时间复杂度是 $O(n^3)$
- 这个复杂度完全不可用
- 数量稍微大一点,程序就会崩溃

想象一下:算法复杂度是 $n^3$,这是不得了的事情,数量稍微大一点程序就崩溃。

### React的优化方案

React最先提出要优化虚拟DOM的Diff算法:
- 优化之后达到了 $O(n)$ 级别
- **从 $n^3$ 优化到 $n$**
- 达到这个级别后,代码就可以实际使用了

这个例子非常能结合复杂度增长曲线图来说明问题的严重性。

## 学习建议

### 核心要点

1. **算法复杂度是学习算法的基础**,非常重要
2. 理解不了就先**背诵**
3. 必须掌握的内容:
   - 把增长曲线图画出来并背过
   - 记住各种复杂度对应的代码表现
   - 先背诵,背诵后再去理解

背诵不是说让你一辈子一直背,背诵完之后,学完这一章后就可以理解了。

### 必须掌握的对应关系

一定要搞清楚每个时间复杂度与代码之间的关系:
- 一次循环
- 没有循环
- 嵌套循环
- 二分查找

**这些一定要搞清楚才行**,然后学习本章就没有什么压力了。

### 关键概念总结

1. **复杂度用大O表示数量级**: $O(1)$, $O(n)$, $O(\log n)$, $O(n \log n)$, $O(n^2)$ 等
2. **内部是函数关系**: 1是函数,$\log n$ 是函数,$n$ 也是函数,$n \log n$ 以及 $n^2$ 都是函数。就像我们上学时学的函数曲线,比如 $y = x^2$ 的曲线是抛物线
3. **"数量级"这个词很重要**
4. **前端开发:重时间、轻空间** - 时间复杂度尤其重要
5. 面试时可能根本不考空间复杂度,主要考察时间复杂度

## AI 总结

本节课详细讲解了**空间复杂度**的概念及其在实际开发中的应用。空间复杂度衡量程序执行所需的内存空间,主要分为 $O(1)$ (常量空间)和 $O(n)$ (线性空间)两类。前端开发遵循"重时间、轻空间"原则,因为现代浏览器内存充足,但用户体验对执行速度敏感。

课程强调了**时间复杂度的关键性**:$O(n^2)$ 及以上的复杂度基本不可用,应将算法控制在 $O(n)$ 或 $O(\log n)$ 级别。通过Vue的Diff算法案例($O(n^3)$ 优化到 $O(n)$)和斐波那契数列($O(2^n)$ 不可用)的例子,说明了复杂度对程序性能的巨大影响。

所有程序员都必须掌握算法复杂度,并培养**复杂度敏感度** - 能下意识判断算法是否高效。建议先背诵各复杂度的曲线图和代码特征,然后通过实践逐步理解,这是学习算法的必备基础。