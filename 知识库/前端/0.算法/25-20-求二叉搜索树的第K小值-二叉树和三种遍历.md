# 求二叉搜索树的第K小值 - 二叉树和三种遍历

## 目录

- [题目背景与重要性](#题目背景与重要性)
- [二叉树基础概念](#二叉树基础概念)
- [二叉树的数据结构定义](#二叉树的数据结构定义)
- [二叉树的三种遍历方式](#二叉树的三种遍历方式)
- [前序遍历（Pre-order Traversal）](#前序遍历preorder-traversal)
- [中序遍历（In-order Traversal）](#中序遍历inorder-traversal)
- [后序遍历（Post-order Traversal）](#后序遍历postorder-traversal)
- [代码实现与测试](#代码实现与测试)
- [AI 总结](#ai-总结)

## 题目背景与重要性

求二叉搜索树的第K小值是一个非常经典的算法面试题，不仅在前端面试中经常出现，在后端和考研的面试中也会频繁考察。这个题目内容丰富，可以考查：

- 对二叉树的理解
- 对二叉搜索树的理解
- 对第K小值求法的理解
- 相关算法的掌握

这是一个综合性的面试题目。在大厂算法面试中，如果没有考察二叉树相关的算法题，基本上这个技术层面的面试是不合格的，面试官也可能是不合格的（当然可能由于时间关系没有考到）。

对于面试者来说，如果对二叉树及其相关扩展不了解，那么算法或数据结构方面是完全不合格的。因为二叉树在整个数据结构中占据了非常大的比重，而且非常有意思。

**思考问题**：为什么我们平常会说二叉树，而不说三叉树、四叉树、五叉树呢？为什么"二"就这么特别？（这个问题会在下一大节解决）

**题目示例**：对于数值序列 2、3、4、5、6、7、8，如果 K=3，第三小的值是 4。第一小的是 2，第二小的是 3，依次是 4、5、6、7、8。也可以反过来求第K大值，第一大的就是 8。

## 二叉树基础概念

**二叉树（Binary Tree）**：顾名思义，一个节点只有两个子节点。

- 它是一棵树结构
- 每个节点最多只能有两个子节点
- 可以有一个子节点
- 也可以没有子节点
- 但最多只能有两个，不能超过两个

如果超过两个子节点，就不是二叉树了，可能是多叉树。

**叶子节点**：没有子节点的节点称为叶子节点，就像树叶子一样。只要节点有子节点（不管是两个还是一个），它就不是叶子节点。

## 二叉树的数据结构定义

可以用 TypeScript 接口来定义二叉树节点的数据结构：

```typescript
interface ITreeNode {
  value: number;
  left: ITreeNode | null;
  right: ITreeNode | null;
}
```

数据结构说明：
- `value`：节点的值（这里定义为 Number 类型，其他类型也可以）
- `left`：左子节点，可能是二叉树的节点，也可能是 null
- `right`：右子节点，可能是二叉树的节点，也可能是 null

**树的表示**：类似链表需要拿到头节点才能知道整个链表的结构，对于树来说，我们需要拿到根节点（root）。只要拿到根节点，就能访问整棵树。不管是获取还是创建一个树，我们操作的都是根节点。

**构建示例树**：

```typescript
const root = {
  value: 5,
  left: {
    value: 3,
    left: {
      value: 2,
      left: null,
      right: null
    },
    right: {
      value: 4,
      left: null,
      right: null
    }
  },
  right: {
    value: 7,
    left: {
      value: 6,
      left: null,
      right: null
    },
    right: {
      value: 8,
      left: null,
      right: null
    }
  }
}
```

这个代码构建的树结构如下：

```
        5
       / \
      3   7
     / \ / \
    2  4 6  8
```

其中 2、4、6、8 都是叶子节点（没有子节点）。

## 二叉树的三种遍历方式

二叉树的遍历有三种基本方法：

1. **前序遍历（Pre-order）**：根 → 左 → 右
2. **中序遍历（In-order）**：左 → 根 → 右
3. **后序遍历（Post-order）**：左 → 右 → 根

这个遍历也可能作为算法题来考察，一般是针对应届生考察比较基础的内容，让你说一说中序遍历的结果或者后序遍历的结果。

**关键规则**：前、中、后指的是根节点的访问顺序，然后都是先左后右。

### 简单示例

对于最简单的树：

```
    A
   / \
  B   C
```

- **前序遍历**：根在前，然后左右 → A, B, C
- **中序遍历**：根在中，然后左右 → B, A, C
- **后序遍历**：根在后，然后左右 → B, C, A

### 复杂示例

对于稍微复杂的树，需要递归地理解：

- **前序遍历**：先遍历根，然后左子树也要先遍历根再左右，右子树也要先遍历根再左右
- **中序遍历**：先左子树，再根，再右子树；左子树内部也是先左再根再右
- **后序遍历**：先左子树，再右子树，最后根；每个子树内部也遵循相同逻辑

整个过程是递归实现的，符合递归的逻辑。

## 前序遍历（Pre-order Traversal）

前序遍历的顺序是：**根 → 左 → 右**

### 代码实现

```typescript
function preOrderTraverse(node: ITreeNode | null) {
  if (node === null) return;
  
  // 先访问根节点
  console.log(node.value);
  // 再遍历左子树
  preOrderTraverse(node.left);
  // 最后遍历右子树
  preOrderTraverse(node.right);
}
```

### 执行结果

对于前面构建的树：

```
        5
       / \
      3   7
     / \ / \
    2  4 6  8
```

前序遍历结果：**5, 3, 2, 4, 7, 6, 8**

- 先访问根节点 5
- 然后访问左子树：先根 3，再左 2，再右 4
- 最后访问右子树：先根 7，再左 6，再右 8

这是一个递归过程，把一个树的根节点传入，只要不是 null 就可以继续。先打印当前的根，然后遍历左子树，再遍历右子树。

## 中序遍历（In-order Traversal）

中序遍历的顺序是：**左 → 根 → 右**

### 代码实现

```typescript
function inOrderTraverse(node: ITreeNode | null) {
  if (node === null) return;
  
  // 先遍历左子树
  inOrderTraverse(node.left);
  // 再访问根节点
  console.log(node.value);
  // 最后遍历右子树
  inOrderTraverse(node.right);
}
```

### 执行结果

对于同样的树，中序遍历结果：**2, 3, 4, 5, 6, 7, 8**

- 先遍历最左边：2
- 然后是左子树的根：3
- 然后是左子树的右：4
- 整个左子树完成后是总根：5
- 然后右子树也遵循左中右：6, 7, 8

中序遍历就是把根放在中间，先左再根再右。对于二叉搜索树，中序遍历的结果是有序的。

## 后序遍历（Post-order Traversal）

后序遍历的顺序是：**左 → 右 → 根**

### 代码实现

```typescript
function postOrderTraverse(node: ITreeNode | null) {
  if (node === null) return;
  
  // 先遍历左子树
  postOrderTraverse(node.left);
  // 再遍历右子树
  postOrderTraverse(node.right);
  // 最后访问根节点
  console.log(node.value);
}
```

### 执行结果

对于同样的树，后序遍历结果：**2, 4, 3, 6, 8, 7, 5**

- 先遍历左：2
- 再右：4
- 再左子树的根：3
- 然后右子树的左：6
- 右子树的右：8
- 右子树的根：7
- 最后是总根：5

后序遍历是根在后，先左再右再根。

## 代码实现与测试

### 完整的文件结构

创建文件 `BinaryTree.ts`：

```typescript
// 定义二叉树节点接口
interface ITreeNode {
  value: number;
  left: ITreeNode | null;
  right: ITreeNode | null;
}

// 构建示例树
const root: ITreeNode = {
  value: 5,
  left: {
    value: 3,
    left: {
      value: 2,
      left: null,
      right: null
    },
    right: {
      value: 4,
      left: null,
      right: null
    }
  },
  right: {
    value: 7,
    left: {
      value: 6,
      left: null,
      right: null
    },
    right: {
      value: 8,
      left: null,
      right: null
    }
  }
};

// 前序遍历
function preOrderTraverse(node: ITreeNode | null) {
  if (node === null) return;
  console.log(node.value);
  preOrderTraverse(node.left);
  preOrderTraverse(node.right);
}

// 中序遍历
function inOrderTraverse(node: ITreeNode | null) {
  if (node === null) return;
  inOrderTraverse(node.left);
  console.log(node.value);
  inOrderTraverse(node.right);
}

// 后序遍历
function postOrderTraverse(node: ITreeNode | null) {
  if (node === null) return;
  postOrderTraverse(node.left);
  postOrderTraverse(node.right);
  console.log(node.value);
}

// 测试
console.log('前序遍历：');
preOrderTraverse(root); // 5, 3, 2, 4, 7, 6, 8

console.log('中序遍历：');
inOrderTraverse(root); // 2, 3, 4, 5, 6, 7, 8

console.log('后序遍历：');
postOrderTraverse(root); // 2, 4, 3, 6, 8, 7, 5
```

### 重要提示

对于层次较多的复杂树结构，理解遍历结果需要：

1. 在白纸上画出树的结构
2. 写出前中后遍历的结果
3. 结合代码去调试
4. 自己分析总结

这些知识点非常重要，是讲解下一步内容的基础。如果这一步没理解好，下一步就讲不下去了。

核心要点：
- 二叉树的数据结构：有 value、left 和 right
- 最多只有两个子节点（left 和 right）
- 前中后序遍历及其递归形式
- 理解多层次递归下的遍历结果

## AI 总结

本节课详细讲解了二叉树的基础知识和三种遍历方式，为求解二叉搜索树第K小值问题奠定基础。

**核心知识点**：

1\. **二叉树定义**：每个节点最多有两个子节点（left 和 right），可以有一个、零个，但不能超过两个

2\. **数据结构**：使用包含 value、left、right 三个属性的接口定义节点

3\. **三种遍历方式**：
   - 前序遍历：根 → 左 → 右（结果：5, 3, 2, 4, 7, 6, 8）
   - 中序遍历：左 → 根 → 右（结果：2, 3, 4, 5, 6, 7, 8，有序）
   - 后序遍历：左 → 右 → 根（结果：2, 4, 3, 6, 8, 7, 5）

4\. **实现方式**：三种遍历都采用递归实现，通过调整打印语句的位置来实现不同的遍历顺序

5\. **重要性**：二叉树是数据结构中占比很大的知识点，在大厂面试中几乎必考，是后续学习二叉搜索树和求第K小值的基础

**学习建议**：对于复杂的多层树结构，建议通过画图、调试代码、分析结果来加深理解。