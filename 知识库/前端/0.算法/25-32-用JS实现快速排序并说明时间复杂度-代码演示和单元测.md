# 用 JavaScript 实现快速排序并说明时间复杂度

## 目录

- [快速排序算法概述](#快速排序算法概述)
- [快速排序的基本思路](#快速排序的基本思路)
- [时间复杂度分析](#时间复杂度分析)
- [splice 与 slice 的区别](#splice-与-slice-的区别)
- [使用 splice 实现快速排序](#使用-splice-实现快速排序)
- [使用 slice 实现快速排序](#使用-slice-实现快速排序)
- [功能测试](#功能测试)
- [单元测试](#单元测试)
- [AI 总结](#ai-总结)

## 快速排序算法概述

快速排序是一个固定的算法，有固定的思路。它主要考察基本的排序功底和算法基础。这个算法没有什么特别的思路可以分析，就是一个固定的套路，如果学过算法的话应该能够理解它的套路。

## 快速排序的基本思路

快速排序的核心步骤如下：

1\. **找出中间位置的值（midValue）**：因为是排序，输入的数组肯定是散乱的，不是递增也不是递减。

2\. **遍历整个数组**：
   - 如果元素小于 midValue，就放在 left 数组中
   - 如果元素大于等于 midValue，就放在 right 数组中

3\. **递归调用**：这是一个递归算法，需要继续对 left 和 right 进行递归排序

4\. **拼接结果**：最后拼接 left、midValue 和 right，返回排序完成的数组

## 时间复杂度分析

快速排序的时间复杂度分析：

- 算法中有一个**遍历**操作，遍历的基础时间复杂度是 $O(n)$
- 在遍历的基础上，又有一个**大于或小于的二分**操作
- 因此快速排序的时间复杂度是：**一次遍历加一次二分**

这是第一次接触这种遍历加二分的时间复杂度组合。之前接触的时间复杂度都是 $O(1)$、$O(\log n)$、$O(n)$、$O(n^2)$ 等，现在接触到了新的组合式时间复杂度 $O(n \log n)$。

## splice 与 slice 的区别

获取 midValue 有两种方法：

### splice 方法

```javascript
const arr = [10, 20, 30];
arr.splice(1, 1); // 返回 [20]
console.log(arr); // [10, 30] - 原数组被修改
```

- `splice` 会**修改原数组**
- 由于数组是连续存储空间，修改数组结构会导致性能比较慢

### slice 方法

```javascript
const arr = [10, 20, 30];
arr.slice(1, 2); // 返回 [20]
console.log(arr); // [10, 20, 30] - 原数组不变
```

- `slice` **不会修改原数组**
- 只是取出中间的值，数组不会变
- 这是比较期望的效果，整体会快一些

**推荐使用 slice 方法**，因为它不会修改原数组。除非面试官有要求必须修改原数组，否则尽量不要去动原数据，而是返回一个新的数据。这在实际工作中尤其重要，类似于函数式编程的方式。

## 使用 splice 实现快速排序

### 代码实现

```javascript
function quickSort1(arr) {
  const length = arr.length;
  if (length === 0) return arr;
  
  // 获取中间位置的索引
  const midIndex = Math.floor(length / 2);
  // 使用 splice 取出中间值（会修改原数组）
  const midValue = arr.splice(midIndex, 1)[0];
  
  const left = [];
  const right = [];
  
  // 注意：这里不能直接用 length，要用 arr.length
  // 因为 arr 已经被 splice 修改了
  for (let i = 0; i < arr.length; i++) {
    const n = arr[i];
    if (n < midValue) {
      left.push(n);
    } else {
      right.push(n);
    }
  }
  
  // 递归调用并拼接结果
  return quickSort1(left).concat([midValue], quickSort1(right));
}
```

### 关键注意点

1\. **不能直接使用 length**：因为 `arr` 已经被 `splice` 修改了，原来的 length 是 10，经过 splice 之后减少为 9，所以必须使用 `arr.length`

2\. **不需要考虑等于 midValue 的情况**：因为 midValue 已经通过 splice 从数组中移除了，遍历时不会遇到它，最后通过 concat 拼接上即可

3\. **splice 的便利性**：不用考虑等于 midValue 的情况，但缺点是需要重新判断 `arr.length`

## 使用 slice 实现快速排序

### 代码实现

```javascript
function quickSort2(arr) {
  const length = arr.length;
  if (length === 0) return arr;
  
  // 获取中间位置的索引
  const midIndex = Math.floor(length / 2);
  // 使用 slice 取出中间值（不会修改原数组）
  const midValue = arr.slice(midIndex, midIndex + 1)[0];
  
  const left = [];
  const right = [];
  
  // 可以直接使用 length，因为原数组没有被修改
  for (let i = 0; i < length; i++) {
    // 需要忽略 midIndex 位置的元素
    if (i !== midIndex) {
      const n = arr[i];
      if (n < midValue) {
        left.push(n);
      } else {
        right.push(n);
      }
    }
  }
  
  // 递归调用并拼接结果
  return quickSort2(left).concat([midValue], quickSort2(right));
}
```

### 关键注意点

1\. **slice 参数不同**：`slice(midIndex, midIndex + 1)` 传入的是开始位置和结束位置，而 `splice(midIndex, 1)` 传入的是开始位置和长度

2\. **可以直接使用 length**：因为 slice 不会修改原数组

3\. **需要忽略 midIndex**：在遍历时要加上 `if (i !== midIndex)` 判断，因为 slice 不会修改原数组，midValue 还在数组中。如果不忽略，在拼接 left、midValue、right 时会导致 midValue 重复

## 功能测试

测试用例：

```javascript
const arr1 = [1, 6, 2, 7, 3, 8, 4, 9, 5];

console.log(quickSort1(arr1)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(quickSort2(arr1)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

测试结果：两种方法都能正确地将散乱的数组排序为递增序列。

## 单元测试

### 测试用例设计

单元测试需要考虑以下几个用例：

1\. **正常情况**：常规的散乱数组排序

2\. **有负数**：数组中包含正数和负数

3\. **数组元素都一样**：测试边界情况

4\. **空数组**：确保不会报错

### 测试代码

```javascript
describe('快速排序', () => {
  it('正常情况', () => {
    const arr = [1, 6, 2, 7, 3, 8, 4, 9, 5];
    const result = quickSort1(arr);
    expect(result).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9]);
  });
  
  it('有负数', () => {
    const arr = [-4, -2, 4, 3, -1];
    const result = quickSort1(arr);
    expect(result).toEqual([-4, -2, -1, 3, 4]);
  });
  
  it('所有元素都一样', () => {
    const arr = [2, 2, 2, 2, 2];
    const result = quickSort1(arr);
    expect(result).toEqual([2, 2, 2, 2, 2]);
  });
  
  it('空数组', () => {
    const arr = [];
    const result = quickSort1(arr);
    expect(result).toEqual([]);
  });
});
```

将 `quickSort1` 替换为 `quickSort2` 可以测试第二种实现方式，所有测试用例都能通过。

## AI 总结

本视频详细讲解了用 JavaScript 实现快速排序的两种方式：

**核心算法思路**：找中间值 → 遍历分组（小于放 left，大于等于放 right）→ 递归排序 → 拼接结果

**时间复杂度**：$O(n \log n)$，由一次遍历 $O(n)$ 加上二分递归 $O(\log n)$ 组成

**两种实现方式的对比**：
- `splice` 方式：会修改原数组，需要注意使用 `arr.length` 而非原始 `length`，但不需要处理 midValue 重复问题
- `slice` 方式（推荐）：不修改原数组，可直接使用 `length`，但需要在遍历时忽略 midIndex 位置

**最佳实践**：推荐使用 `slice` 方法，因为不修改原数组符合函数式编程思想，在实际工作中更安全可靠。