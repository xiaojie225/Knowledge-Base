# 判断一个字符串是否括号匹配

## 目录

- [问题描述](#问题描述)
- [常见错误思路](#常见错误思路)
- [栈(Stack)数据结构](#栈stack数据结构)
- [逻辑结构与物理结构](#逻辑结构与物理结构)
- [解题思路](#解题思路)
- [代码实现](#代码实现)
- [单元测试](#单元测试)
- [复杂度分析](#复杂度分析)
- [重点总结](#重点总结)
- [AI 总结](#ai-总结)

## 问题描述

判断字符串是否括号匹配是一个常见的编程问题。这个问题在写代码时经常遇到，比如编写代码时，如果括号不匹配，程序就会报错。

**问题要求**：
- 给定一个字符串 S，可能包含三种括号：`()`, `[]`, `{}`
- 为简单起见，只限制这三种括号类型
- 判断 S 是否是括号匹配的

**示例**：
- 匹配的情况：`{[()]}` - 每个左括号都能找到对应的右括号，且顺序正确
- 不匹配的情况：
  - `{[(])}` - 顺序不对，方括号和圆括号交错
  - `{[()` - 只有左括号，缺少右括号

## 常见错误思路

很多面试者会采用以下错误思路：

1\. **遍历字符串，前后做匹配**
2\. **统计括号数量**：先把括号拿出来，统计左括号和右括号的数量，然后做匹配
3\. **前半后半匹配**：把字符串分成前半部分和后半部分进行匹配

这些方法的问题：
- 对于简单情况可能有效
- 一旦情况复杂化，就无法正确判断
- 例如 `{[(])}` 这种交错的情况就无法处理

## 栈(Stack)数据结构

### 什么是栈

**栈 (Stack)** 是计算机中最重要的数据结构之一，是一种**先进后出 (LIFO - Last In First Out)** 的数据结构。

如果没有栈：
- 就没有现在的计算机
- 就没有编程
- 就没有软件工程

### 栈的特点

栈就像一个水桶或水缸：
- 进来的东西放在底下（栈底）
- 后来的东西堆在上面
- 谁想出去，就从最后进来的那个出去（栈顶）

**形象比喻**：
- 就像洗完餐具后叠盘子
- 先叠的盘子在底下
- 后叠的盘子在上面
- 要拿盘子就从上面开始拿

### 栈的基本操作

栈的 API 主要包括：
- **push (入栈/压栈)**：将元素放入栈中
- **pop (出栈)**：将栈顶元素取出
- **length/size**：获取栈的长度

### 用数组实现栈

```javascript
const stack = []; // 创建空数组

// 入栈操作
stack.push(100);  // [100]
stack.push(200);  // [100, 200]
stack.push(300);  // [100, 200, 300]

// 出栈操作
stack.pop();      // 300 出栈，stack = [100, 200]

// 获取长度
stack.length;     // 2
```

## 逻辑结构与物理结构

### 重要概念区分

**栈和数组的关系是什么？有什么区别？**

很多数据结构的书会把数组和栈混在一起讲，但实际上它们根本不是一回事。

就好比问："拖拉机和牛有什么区别？"
答案是：没有任何区别，没有任何联系，它们不是一回事。

### 逻辑结构 vs 物理结构

**栈** 是一种**逻辑结构**：
- 只是一个理论模型
- 不管如何实现
- 不受任何语言的限制
- 在任何语言里都可以通过当前语言的语法去实现栈

**数组** 是一种**物理结构**：
- 是实实在在的东西
- 有语法的，有 API 的
- API 写错了会报错
- 是真实的具体实现
- 每个编程语言的数组都不一样
- 甚至有些编程语言没有数组

### 实现关系

- 数组可以实现栈
- 链表可以实现栈
- 其他数据结构也可以实现栈

但是：
- 栈实现不了数组
- 栈没有任何实际的功能
- 栈是一个比较高级、抽象的东西
- 数组是一个比较低级、现实的东西

**类比**：
- "吃饱了" 可能是栈（抽象概念）
- 吃馒头可以吃饱
- 吃米饭也可以吃饱
- 吃饼干也可以吃饱
- 它们不是一个东西

**关键结论**：栈和数组是两回事，不要拿来一块对比。数组可以实现栈，但栈实现不了数组。

## 解题思路

使用栈来解决括号匹配问题的核心思路：

1\. **遇到左括号就入栈**
2\. **遇到右括号就判断栈顶**：看是否匹配，如果匹配则出栈
3\. **最后判断栈的 length 是否为 0**：
   - 如果为 0，说明所有括号都匹配
   - 如果大于 0，说明还有未匹配的括号

### 图解示例

假设有字符串：`(A{B[C]D}E)`

1. 遇到 `(`，入栈：`['(']`
2. A 不管，遇到 `{`，入栈：`['(', '{']`
3. B 不管，遇到 `[`，入栈：`['(', '{', '[']`
4. C 不管，遇到 `]`，判断栈顶是 `[`，匹配！出栈：`['(', '{']`
5. D 不管，遇到 `}`，判断栈顶是 `{`，匹配！出栈：`['(']`
6. E 不管，遇到 `)`，判断栈顶是 `(`，匹配！出栈：`[]`
7. 最后栈的 length 为 0，说明括号匹配

### 关键点

**不匹配的情况**：
- 如果栈顶是方括号 `[`
- 但遇到的右括号是圆括号 `)`
- 说明整个字符串的括号就是不匹配的
- 只要有一个不匹配，整体就是不匹配的
- **直接返回 false**

## 代码实现

```typescript
/**
 * 判断字符串是否括号匹配
 */
export function matchBracket(str: string): boolean {
  const length = str.length;
  
  // 空字符串，返回 true
  if (length === 0) {
    return true;
  }
  
  const stack: string[] = []; // 定义栈
  const leftSymbols = '([{';   // 左括号
  const rightSymbols = ')]}';  // 右括号
  
  // 遍历字符串
  for (let i = 0; i < length; i++) {
    const s = str[i];
    
    // 如果是左括号，入栈
    if (leftSymbols.includes(s)) {
      stack.push(s);
    } 
    // 如果是右括号
    else if (rightSymbols.includes(s)) {
      // 判断栈顶
      const top = stack[stack.length - 1];
      
      // 如果匹配，出栈
      if (isMatch(top, s)) {
        stack.pop();
      } else {
        // 如果不匹配，直接返回 false
        return false;
      }
    }
  }
  
  // 最后判断栈是否为空
  return stack.length === 0;
}

/**
 * 判断左右括号是否匹配
 * @param leftS 左括号
 * @param rightS 右括号
 */
function isMatch(leftS: string, rightS: string): boolean {
  if (leftS === '(' && rightS === ')') return true;
  if (leftS === '[' && rightS === ']') return true;
  if (leftS === '{' && rightS === '}') return true;
  return false;
}
```

### 代码关键点说明

1\. **空字符串处理**：空字符串直接返回 true

2\. **includes 方法**：
   - 用于判断字符是否在左括号或右括号集合中
   - `includes` 在数组中寻找某一项，需要遍历
   - 但这里 `leftSymbols` 和 `rightSymbols` 是固定的量（只有 3 个元素）
   - 与输入字符串长度无关，所以不计入时间复杂度

3\. **不匹配立即返回**：
   - 这是代码实现中的关键改进点
   - 只要发现一个不匹配，立即返回 false
   - 不需要继续遍历

## 单元测试

```typescript
import { matchBracket } from './match-bracket';

describe('括号匹配', () => {
  it('正常情况', () => {
    const str = '{[A(B)C]D}E';
    const result = matchBracket(str);
    expect(result).toBe(true);
  });
  
  it('不匹配', () => {
    const str = '{[A(B]C}D)E';
    const result = matchBracket(str);
    expect(result).toBe(false);
  });
  
  it('顺序不一致', () => {
    const str = '{A[B(C)D]E}';
    // 改为 {A(B[C]D)E} - 顺序不对
    const result = matchBracket(str);
    expect(result).toBe(false);
  });
  
  it('空字符串', () => {
    const str = '';
    const result = matchBracket(str);
    expect(result).toBe(true);
  });
});
```

### 单元测试的重要性

**强烈建议**：做算法题时，一定要把单元测试写上

即使你写的测试代码有问题，甚至 `describe` 和 `it` 的语法都有问题，这都不是问题。关键是：

- 证明你有**测试思维**
- 展现你的专业素养
- 在面试中争取更多优势

单元测试非常简单：
- 安装 Jest 测试框架
- 按照固定的模式编写
- 基本的简单的单元测试完全没有问题

## 复杂度分析

### 时间复杂度：O(n)

- 需要遍历整个字符串一次
- 虽然 `includes` 方法本身是 O(n)，但因为：
  - `leftSymbols` 和 `rightSymbols` 是固定的量（只有 3 个元素）
  - 与输入数据量无关
  - 数据量非常小
  - 所以不计入时间复杂度
- 整体时间复杂度就是一次遍历：**O(n)**

### 空间复杂度：O(n)

- 需要一个栈来存储左括号
- 虽然栈中的数量不如字符串长（因为字符串不可能全是括号）
- 但在数量级上，栈的大小与字符串长度是同一量级
- 所以空间复杂度是：**O(n)**

## 重点总结

### 1\. 栈的重要性

栈是计算机中最重要的数据结构：
- 没有栈就没有计算机
- 没有栈就没有编程
- 每个程序员都应该知道栈是什么
- 每个合格的程序员都应该掌握栈

### 2\. 逻辑结构与物理结构

这是一个**启发式的概念**，非常重要：

**如果不知道这个概念**：
- 想再多的东西，做再多的练习
- 都是穿不成正层穿户纸（无法真正理解）

**如果知道这个概念**：
- 很轻松就能理解
- 不用做任何练习
- 就能理解栈和数组之间的关系

**核心区别**：
- 栈：逻辑结构，理论模型，抽象概念
- 数组：物理结构，具体实现，实际存在

### 3\. 算法题通用建议

- 理解栈的概念后，这道题就没有问题
- 遇到一点小挫折（如不匹配情况的处理）是正常的
- 很快就能补上，不是什么大的妨碍
- 主要是对栈的理解和应用

### 4\. 面试经验

这是一个前两年的真实面试题：
- 是一个最基本的数据结构和算法问题
- 但很多人答不出来
- 反映出很多前端工程师：
  - 算法和数据结构的基础知识并不牢靠
  - 整体来看这方面的基础不够扎实

## AI 总结

本节课讲解了经典的**括号匹配问题**，这是一道考察栈数据结构应用的基础算法题。核心知识点包括：

**栈的本质**：先进后出 (LIFO) 的数据结构，是计算机科学中最基础也最重要的数据结构之一。

**关键概念**：栈是逻辑结构（理论模型），数组是物理结构（具体实现）。栈可以用数组实现，但栈和数组不是一回事，不能混为一谈。

**解题思路**：遇到左括号入栈，遇到右括号判断栈顶是否匹配，匹配则出栈，不匹配直接返回 false，最后检查栈是否为空。

**复杂度**：时间复杂度 O(n)，空间复杂度 O(n)。

这道题虽然简单，但能很好地考察对栈这一基本数据结构的理解和应用能力。掌握栈的概念和使用方法，是每个程序员必备的基础技能。