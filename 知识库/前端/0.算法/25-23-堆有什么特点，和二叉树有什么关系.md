# 堆的特点与二叉树的关系

## 目录

- [堆栈模型基础](#堆栈模型基础)
- [值类型与引用类型](#值类型与引用类型)
- [堆的定义与特点](#堆的定义与特点)
- [完全二叉树](#完全二叉树)
- [堆的逻辑与物理结构](#堆的逻辑与物理结构)
- [节点关系](#节点关系)
- [堆与二叉搜索树的对比](#堆与二叉搜索树的对比)
- [堆的使用场景](#堆的使用场景)
- [AI 总结](#ai-总结)

---

## 堆栈模型基础

在 JavaScript 执行过程中，内存分为两个主要区域：

- **栈（Stack）**：存储值类型变量
- **堆（Heap）**：存储引用类型变量

这是 JavaScript 内存管理的基础概念。一个进程的内存空间包含栈内存和堆内存，此外还有代码文件、全局变量等其他内存区域，但主要关注的是栈和堆。

### 内存空间限制

操作系统给一个进程（或称为一个 APP）分配的内存空间大约是 **2GB 左右**（不同系统可能有所差异）。

- 栈从上往下增长
- 堆从下往上增长
- 当两者相互冲突，内存被用光后，进程会报错提示内存不足

一般情况下，2GB 的内存空间对一个应用程序来说是足够的。如果不够用，说明程序存在问题（如内存泄漏）。

---

## 值类型与引用类型

### 值类型的赋值

```javascript
let a = 100;
let b = a;
b = 200;
```

结果：
- `a` 仍然是 `100`
- `b` 变成 `200`

值类型的赋值是**直接复制值**，两个变量互不影响。

### 引用类型的赋值

```javascript
let obj1 = { x: 100 };
let obj2 = obj1;
obj2.x = 200;
```

结果：
- `obj1.x` 变成 `200`
- `obj2.x` 也是 `200`

引用类型的赋值是**复制堆地址**，两个变量指向同一个堆内存对象。

### 内存存储方式

- **值类型**：直接存储在栈中，例如 `Number: 100` 直接存储值 `100`
- **引用类型**：栈中存储**堆地址**，实际对象数据存储在堆中

这就是值类型和引用类型赋值行为不同的本质原因。

### 深拷贝

如果想让引用类型的变量互不影响，需要进行**深拷贝**。深拷贝的各种方法和注意事项会在后续课程中详细讲解。

---

## 堆的定义与特点

堆（Heap）是一个**完全二叉树**，它与二叉树有着密切的关系。

### 堆的两种类型

堆必须满足以下两个条件之一：

1. **最大堆（Max Heap）**：父节点 ≥ 所有子节点
2. **最小堆（Min Heap）**：父节点 ≤ 所有子节点

这两个条件只需满足其中一个即可。

### 堆与二叉搜索树（BST）的区别

- **二叉搜索树（BST）**：
  - 左子节点 < 根节点
  - 右子节点 > 根节点
  - 规则严格，左右有明确的大小关系

- **堆（Heap）**：
  - 左右子节点不分大小
  - 只要求父节点与所有子节点满足大小关系（≥ 或 ≤）
  - 规则更灵活

例如，在最小堆中：
- 根节点是 `10`
- 左子节点可以是 `14`，右子节点可以是 `25`
- 只要 `10 ≤ 14` 且 `10 ≤ 25` 即可，不要求 `14` 和 `25` 之间的大小关系

---

## 完全二叉树

### 满二叉树与完全二叉树

- **满二叉树（Full Binary Tree）**：所有层级都被完全填满，呈现完美的三角形结构
- **完全二叉树（Complete Binary Tree）**：除了最后一层外，其他层都被填满；最后一层的节点从左到右依次填充，即使没有填满也必须**先填满左边**

关系：满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。

### 最小堆示例

```
        10
       /  \
      14   25
     /  \  /  \
    33  81 82  99
```

这是一个最小堆，满足：
- 根节点 `10` ≤ 左右子节点 `14` 和 `25`
- 节点 `14` ≤ 其子节点 `33` 和 `81`
- 节点 `25` ≤ 其子节点 `82` 和 `99`

当然也可以构建最大堆，只需让根节点始终大于所有子节点即可。

---

## 堆的逻辑与物理结构

堆的设计非常巧妙，体现了极致的优化思想：

- **逻辑结构**：一棵二叉树
- **物理结构**：一个数组

### 为什么这样设计？

1. **逻辑上是二叉树**：可以利用二叉树的特性进行各种操作，具有二叉树的查找和遍历优势
2. **物理上是数组**：
   - 存储空间极小
   - 连续存储，利用率高
   - 节省内存开销

### 对比传统二叉树节点结构

传统二叉树节点定义：

```javascript
class TreeNode {
  value: any;
  left: TreeNode;
  right: TreeNode;
}
```

这种结构需要存储：
- 节点值
- 左子节点引用
- 右子节点引用

占用的内存空间较大，且需要分散的堆内存存储。

### 堆的数组表示

堆使用数组存储，例如上面的最小堆：

```
数组：[忽略, 10, 14, 25, 33, 81, 82, 99]
索引：  0    1   2   3   4   5   6   7
```

注意：**索引 0 被忽略**，从索引 1 开始存储堆的根节点。

这种表示方式：
- 空间利用率最高
- 连续存储，访问速度快
- 非常适合底层系统对性能和空间的极致要求

---

## 节点关系

堆虽然物理上是数组，但逻辑上是二叉树，因此需要通过**节点关系**来操作数组，实现二叉树的功能。

### 节点关系公式

对于数组中索引为 `i` 的节点：

- **父节点索引**：$\text{parent\_index} = \lfloor i \div 2 \rfloor$
- **左子节点索引**：$\text{left\_index} = 2 \times i$
- **右子节点索引**：$\text{right\_index} = 2 \times i + 1$

### 示例验证

以节点 `14`（索引 2）为例：

```
数组：[忽略, 10, 14, 25, 33, 81, 82, 99]
索引：  0    1   2   3   4   5   6   7
```

- **父节点**：$\lfloor 2 \div 2 \rfloor = 1$，对应值 `10` ✓
- **左子节点**：$2 \times 2 = 4$，对应值 `33` ✓
- **右子节点**：$2 \times 2 + 1 = 5$，对应值 `81` ✓

可以选择任意节点验证，例如节点 `25`（索引 3）：

- 父节点：$\lfloor 3 \div 2 \rfloor = 1$，值为 `10` ✓
- 左子节点：$2 \times 3 = 6$，值为 `82` ✓
- 右子节点：$2 \times 3 + 1 = 7$，值为 `99` ✓

通过这些公式，可以在数组中实现二叉树的父子节点导航。

---

## 堆与二叉搜索树的对比

### 查询性能

- **二叉搜索树（BST）**：查询更快
  - 规则严格（左 < 根 < 右）
  - 可以使用二分查找
  - 查找目标节点时可以快速确定方向

- **堆（Heap）**：查询较慢
  - 规则宽松（只要求父节点与子节点的大小关系）
  - 无法使用二分查找
  - 查找时需要遍历更多节点

### 插入和维护性能

- **二叉搜索树**：维护平衡较慢
  - 规则严格，维持关系需要更多操作
  - 类似人际关系：关系紧密时求人办事容易，但维系关系费时费力

- **堆**：插入和维护更快
  - 规则简单，维持关系容易
  - 类似人际关系：关系疏远时求人办事难，但不需要刻意维系关系

### 时间复杂度

两者的整体时间复杂度都是 **O(log n)**（取决于树的高度），但在具体场景下各有优劣。

---

## 堆的使用场景

### 堆栈模型中的堆

堆特别适合**堆栈模型**的使用场景：

```
栈（Stack）：
  ┌─────────┐
  │ obj地址 │ → 指向堆中的对象
  └─────────┘

堆（Heap）：
  ┌─────────┐
  │  对象   │ ← 被栈中的地址引用
  └─────────┘
```

### 堆的访问特点

堆中的数据**不需要从根节点开始查找**，而是：

1. 栈中已经存储了堆地址
2. 通过地址直接访问堆中的对象
3. 类似于数组通过索引访问元素，时间复杂度为 **O(1)**

### 为什么不需要树形查找？

在堆栈模型中：
- 引用类型变量在栈中存储的是**堆地址**
- 访问对象时，直接通过地址定位
- 不需要像 BST 那样从根节点开始二分查找

这种访问方式：
- 特别像数组通过索引查找元素
- 时间复杂度是 **O(1)**，非常快
- 物理结构就是数组，天然支持这种访问模式

### 空间优化

相比传统二叉树节点结构（需要存储左右子节点引用），堆的数组结构：
- 只存储节点值
- 通过计算索引关系找到父子节点
- 大大节省了内存空间

---

## AI 总结

本节课深入讲解了**堆（Heap）**的概念、特点及其与二叉树的关系，主要内容包括：

1. **堆栈模型基础**：JavaScript 中值类型存储在栈中，引用类型的地址存储在栈中，实际对象存储在堆中

2. **堆的定义**：堆是一个完全二叉树，分为最大堆（父节点 ≥ 子节点）和最小堆（父节点 ≤ 子节点）

3. **完全二叉树**：除最后一层外其他层填满，最后一层从左到右依次填充

4. **逻辑与物理结构的巧妙设计**：
   - 逻辑上是二叉树：利用树的查找优势
   - 物理上是数组：节省空间，连续存储

5. **节点关系公式**：通过数学公式在数组中实现父子节点导航

6. **与 BST 的对比**：堆的查询较慢但维护更快，规则更灵活

7. **使用场景**：特别适合堆栈模型，通过栈中的地址直接访问堆中对象，时间复杂度 O(1)

堆的设计体现了计算机科学中对性能和空间的极致优化，通过简单的规则和巧妙的结构，在底层系统中发挥重要作用。理解堆的这些特性，有助于深入理解 JavaScript 的内存管理机制。