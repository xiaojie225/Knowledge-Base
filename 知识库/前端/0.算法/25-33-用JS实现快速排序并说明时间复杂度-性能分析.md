# 用 JS 实现快速排序并说明时间复杂度 - 性能分析

## 目录

- [快速排序的时间复杂度分析](#快速排序的时间复杂度分析)
- [性能测试对比](#性能测试对比)
- [slice 与 splice 的性能差异](#slice-与-splice-的性能差异)
- [总结与建议](#总结与建议)
- [AI 总结](#ai-总结)

## 快速排序的时间复杂度分析

快速排序的性能分析需要从两个维度考虑：

### 遍历操作
- 每次遍历数组的时间复杂度是 $O(n)$
- 通过一次遍历将数组元素分配到不同区域

### 递归二分操作
- 递归通过 `left` 和 `right` 参数不断二分整个范围
- 二分的时间复杂度是 $O(\log n)$

### 综合时间复杂度
- 一层遍历嵌套一层二分，两者是**相乘关系**（不是相加）
- 最终时间复杂度：$O(n \log n)$ 或写作 $O(n) \cdot O(\log n)$

### 与其他排序算法对比
- $O(n \log n)$ 比 $O(n)$ 大，也比 $O(\log n)$ 大
- 但比 $O(n^2)$ 小很多
- 一般常规排序算法（如冒泡排序）的时间复杂度是 $O(n^2)$
- 快速排序的 $O(n \log n)$ 在排序算法中已经是非常优秀的性能表现

## 性能测试对比

### 测试代码设计

创建随机数组进行测试：

```javascript
// 生成 10 万个随机数的数组
const array1 = [];
for (let i = 0; i < 100000; i++) {
  array1.push(Math.random() * 1000); // 0-1000 的随机数
}

// 测试 quickSort1 (使用 splice)
console.time('quickSort1');
quickSort1(array1);
console.timeEnd('quickSort1');

// 测试 quickSort2 (使用 slice)
const array2 = [];
for (let i = 0; i < 100000; i++) {
  array2.push(Math.random() * 1000);
}

console.time('quickSort2');
quickSort2(array2);
console.timeEnd('quickSort2');
```

### 测试结果
- quickSort1 (splice): 约 74 毫秒
- quickSort2 (slice): 约 82 毫秒
- 两者性能差异不明显，基本接近

### 为什么看不出差异

1. **算法本身复杂度已经很高**
   - 快速排序本身就是 $O(n \log n)$ 级别
   - 在这么高的时间复杂度基础上，slice 和 splice 的性能差异被淹没

2. **二分快速减少数量级**
   - 递归二分会快速减少数据规模
   - slice 的性能影响会被快速削减

## slice 与 splice 的性能差异

### 单独对比测试

```javascript
// 测试 slice
const array1 = [];
for (let i = 0; i < 100000; i++) {
  array1.push(Math.random() * 1000);
}

console.time('slice');
array1.slice(50000); // 从第 5 万个开始截取
console.timeEnd('slice');

// 测试 splice
const array2 = [];
for (let i = 0; i < 100000; i++) {
  array2.push(Math.random() * 1000);
}

console.time('splice');
array2.splice(50001); // 从第 5 万+1 个开始（因为 splice 是从 start 到 end）
console.timeEnd('splice');
```

### 单独测试结果
- slice: 约 0.1 毫秒
- splice: 约 0.08 毫秒
- 差距约 10 倍左右

### 性能差异原因
- **单独比较**：slice 和 splice 的性能差异明显
- **在快速排序中**：差异被算法本身的高复杂度淹没
- 如果执行多次，差异会更加明显

## 总结与建议

### 快速排序实现要点
- 使用 slice 或 splice 对快速排序性能影响不大
- 重点考察的是：
  - 快速排序的算法思想
  - 递归实现方式
  - 二分策略
- 与具体 API 选择关系不大

### API 选择建议
- **单独使用场景**：需要了解 slice 和 splice 哪个更快
- **快速排序场景**：两者都可以，重点在算法本身
- **性能对比**：
  - slice 不修改原数组
  - splice 会修改原数组
  - 单独使用时 splice 稍快

### 时间复杂度对比图
- 常见复杂度从低到高：
  - $O(1)$ - 常数时间
  - $O(\log n)$ - 对数时间
  - $O(n)$ - 线性时间
  - $O(n \log n)$ - 快速排序级别
  - $O(n^2)$ - 冒泡排序级别

## AI 总结

本视频深入分析了快速排序的时间复杂度和性能特点。核心要点包括：

1. **时间复杂度**：快速排序的时间复杂度为 $O(n \log n)$，由一层遍历 $O(n)$ 和一层递归二分 $O(\log n)$ 相乘得出，在排序算法中属于优秀水平。

2. **性能测试**：通过 10 万个随机数的实测发现，使用 slice 和 splice 实现的快速排序性能差异不明显（74ms vs 82ms），因为算法本身的高复杂度掩盖了 API 的性能差异。

3. **API 对比**：单独测试 slice 和 splice 时，性能差异明显（约 10 倍），但在快速排序场景中这种差异被淹没。实际开发中，快速排序的重点在于算法思想和递归实现，而非 API 选择。