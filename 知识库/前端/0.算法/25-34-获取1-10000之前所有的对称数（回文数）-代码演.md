# 获取1-10000之间所有的对称数（回文数）

## 目录

- [问题描述](#问题描述)
- [方法一：数组反转法](#方法一数组反转法)
- [方法二：字符串首尾比较法](#方法二字符串首尾比较法)
- [方法三：生成翻转数法](#方法三生成翻转数法)
- [单元测试](#单元测试)
- [AI 总结](#ai-总结)

## 问题描述

对称数（回文数/palindrome number）是指从左往右读和从右往左读都相同的数字。例如：
- 个位数：0, 1, 2, 3...9
- 两位数：11, 22, 33...99
- 三位数：101, 111, 121, 131...191, 202...

本视频讲解如何求1到10000之间所有的对称数，并介绍三种不同的实现方法。

## 方法一：数组反转法

### 实现思路

最简单直接的方式：
1. 将数字转换为字符串
2. 将字符串转换为数组
3. 对数组进行反转（reverse）
4. 将反转后的数组拼接回字符串
5. 比较原字符串和反转后的字符串是否相等

### 代码实现

```typescript
function findPalindrome1(max: number) {
  const numbers = [];
  
  // 边界情况处理
  if (max <= 0) return numbers;
  
  // 从1遍历到max
  for (let i = 1; i <= max; i++) {
    // 转换为字符串
    const s = i.toString();
    
    // 转换成数组，反转，再拼接
    const reversed = s.split('').reverse().join('');
    
    // 比较原字符串和反转后的字符串
    if (s === reversed) {
      numbers.push(i);
    }
  }
  
  return numbers;
}
```

### 测试结果

测试范围1-200，输出结果：1, 2, 3...11, 22...101, 111...191

## 方法二：字符串首尾比较法

### 实现思路

省去数组反转步骤，直接进行字符串首尾比较：
1. 将数字转换为字符串
2. 使用双指针，从字符串两端向中间比较
3. 如果发现不相等的字符，标记为非回文
4. 如果所有对应位置字符都相等，则为回文数

这个方法类似于括号匹配问题的解法。

### 代码实现

```typescript
function findPalindrome2(max: number) {
  const numbers = [];
  
  if (max <= 0) return numbers;
  
  for (let i = 1; i <= max; i++) {
    const s = i.toString();
    
    // 字符串首尾比较
    let flag = true;  // 标记是否为回文
    let startIndex = 0;  // 字符串开始位置
    let endIndex = s.length - 1;  // 字符串结束位置
    
    while (startIndex < endIndex) {
      if (s[startIndex] !== s[endIndex]) {
        flag = false;
        break;
      }
      startIndex++;
      endIndex--;
    }
    
    if (flag) {
      numbers.push(i);
    }
  }
  
  return numbers;
}
```

### 算法说明

- 第一次比较：第1个字符 vs 最后1个字符
- 第二次比较：第2个字符 vs 倒数第2个字符
- 第三次比较：第3个字符 vs 倒数第3个字符
- 以此类推，直到 `startIndex >= endIndex`

如果在比较过程中发现任何不相等的字符，立即标记为非回文并跳出循环。

## 方法三：生成翻转数法

### 实现思路

不使用字符串或数组操作，纯数字计算：
1. 使用取余（%）和向下取整（Math.floor）操作生成翻转数
2. 将原数字与生成的翻转数进行比较
3. 如果相等则为回文数

### 代码实现

```typescript
function findPalindrome3(max: number) {
  const numbers = [];
  
  if (max <= 0) return numbers;
  
  for (let i = 1; i <= max; i++) {
    let n = i;  // 保存原始值
    let reverse = 0;  // 存储翻转数
    
    // 生成翻转数
    while (n > 0) {
      reverse = reverse * 10 + (n % 10);
      n = Math.floor(n / 10);
    }
    
    // 比较原数字和翻转数
    if (i === reverse) {
      numbers.push(i);
    }
  }
  
  return numbers;
}
```

### 算法详解（以123为例）

**初始状态：**
- `i = 123`
- `n = 123`
- `reverse = 0`

**第一轮循环：**
- `reverse = 0 * 10 + (123 % 10) = 0 + 3 = 3`
- `n = Math.floor(123 / 10) = 12`

**第二轮循环：**
- `reverse = 3 * 10 + (12 % 10) = 30 + 2 = 32`
- `n = Math.floor(12 / 10) = 1`

**第三轮循环：**
- `reverse = 32 * 10 + (1 % 10) = 320 + 1 = 321`
- `n = Math.floor(1 / 10) = 0`

**循环结束：**
- `n = 0`（不满足 `n > 0`）
- `reverse = 321`
- 比较：`123 !== 321`，不是回文数

## 单元测试

### 测试用例设计

创建 `palindrome-number.test.ts` 文件，包含以下测试用例：

1. **正常情况**：测试1-200范围内的回文数
   - 预期结果：数组长度为28

2. **边界情况**：测试 `max <= 0` 的情况
   - 预期结果：返回空数组

### 测试代码

```typescript
import { findPalindrome1, findPalindrome2, findPalindrome3 } from './palindrome-number';

describe('对称数测试', () => {
  // 测试方法一
  it('正常情况 - 方法一', () => {
    const numbers = findPalindrome1(200);
    expect(numbers.length).toBe(28);
  });
  
  it('max <= 0 - 方法一', () => {
    expect(findPalindrome1(0)).toEqual([]);
  });
  
  // 测试方法二
  it('正常情况 - 方法二', () => {
    const numbers = findPalindrome2(200);
    expect(numbers.length).toBe(28);
  });
  
  it('max <= 0 - 方法二', () => {
    expect(findPalindrome2(0)).toEqual([]);
  });
  
  // 测试方法三
  it('正常情况 - 方法三', () => {
    const numbers = findPalindrome3(200);
    expect(numbers.length).toBe(28);
  });
  
  it('max <= 0 - 方法三', () => {
    expect(findPalindrome3(0)).toEqual([]);
  });
});
```

### 测试结果

所有测试用例通过，三种方法都能正确找出1-200范围内的28个回文数。

## 方法对比

三种方法各有特点：

1. **方法一（数组反转法）**：
   - 优点：代码最简洁，易于理解
   - 缺点：涉及多次类型转换和数组操作

2. **方法二（字符串首尾比较法）**：
   - 优点：比方法一少了数组反转操作
   - 缺点：仍需要字符串转换

3. **方法三（生成翻转数法）**：
   - 优点：纯数字计算，无需类型转换
   - 缺点：算法理解稍复杂

关于性能比较，视频提到将在下一节课中详细测试和分析。每种方式都有其适用场景：有些更易读，有些性能更好。

## AI 总结

本视频详细讲解了求解回文数（对称数）的三种方法。方法一使用数组反转最直观易懂；方法二通过字符串首尾比较优化了反转操作；方法三使用纯数学运算避免了类型转换。三种方法都通过了单元测试验证，在1-200范围内正确找出28个回文数。视频强调了算法看似简单但实现细节很重要，并预告下节课将进行性能对比分析，帮助开发者选择最优方案。