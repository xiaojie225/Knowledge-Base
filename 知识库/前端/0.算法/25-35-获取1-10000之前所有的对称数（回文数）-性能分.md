# 获取1-10000之前所有的对称数（回文数）- 性能分析

## 目录

- [性能测试准备](#性能测试准备)
- [测试结果与分析](#测试结果与分析)
- [性能差异原因分析](#性能差异原因分析)
- [优化建议与总结](#优化建议与总结)
- [AI 总结](#ai-总结)

## 性能测试准备

本节对三个不同的算法实现进行性能测试，通过实际运行来对比它们的执行效率。

### 测试代码设置

使用 `Time` 和 `Time end` 来测量每个算法的执行时间：

- **测试数据规模**：设置 `max` 为 100万（1,000,000）
- **测试方法**：
  - 方法1：使用数组转换实现
  - 方法2：使用字符串操作实现
  - 方法3：使用数字反转实现

测试代码结构：
```
Time
findPalindromNumbers1(max)  // 或 2、3
Time end
```

## 测试结果与分析

### 实测数据

在100万数量级的测试下，三种方法的执行时间（毫秒级）：

- **方法1（数组转换）**：408ms / 401ms
- **方法2（字符串操作）**：52ms / 53ms
- **方法3（数字反转）**：42ms / 43ms

### 性能对比结论

1\. **数组转换方式最慢**：耗时约408ms，比其他方法慢约10倍

2\. **字符串和数字方式相近**：都比较快，耗时在40-50ms之间

3\. **数字操作最快**：耗时约42ms，是最优解决方案

## 性能差异原因分析

### 方法1（数组转换）为何最慢

虽然看似时间复杂度为 O(n)，只有一层循环，但实际上包含大量隐藏的时间消耗：

- **数字转数组**：需要时间进行类型转换
- **数组组织**：构建数组结构需要额外开销
- **数组反转**：`reverse()` 等内置方法的执行时间
- **数组转字符串**：最终转换回来也需要时间

这些数据结构转换操作累积起来，导致整体性能下降约10倍。

### 方法2和方法3的差异

- **方法2（字符串操作）**：虽然也是 O(n) 复杂度，但字符串操作相对数组更轻量
- **方法3（数字操作）**：直接操作数字，计算机本质是计算器，数字运算（加减乘除）是最底层、最快的操作

关于栈的使用：
- 用栈虽然能实现功能，但**不合适**
- 栈一般也是用数组实现的，会有类似数组的性能问题

## 优化建议与总结

### 核心优化原则

**在算法中的数据结构选择优先级**：

1\. **首选数字操作**：能操作数字就操作数字（最快）

2\. **其次字符串操作**：不能操作数字时，可以用字符串

3\. **尽量避免复杂数据结构**：不要转换成数组等复杂、有序的数据结构

### 具体建议

**避免的做法**：
- ❌ 不要频繁转换数据结构
- ❌ 不要转换成数组这种比较复杂的结构
- ❌ 尽量不要用内置方法（如 `reverse()`），因为不清楚其算法复杂度，难以评估性能

**推荐的做法**：
- ✅ 尽量使用低级的数据结构（数字、字符串）
- ✅ 数字是所有方式中最快的
- ✅ 操作数字优于操作字符串，操作字符串优于操作数组

### 计算机原理支撑

电脑的原型本身就是**计算器**，计算器就是用来算数的（加减乘除），因此**数字操作是最快的**。

### 工作实践说明

在实际工作中：
- 对于**大型系统的数据建模**：该用数组还是要用数组
- **工作是工作，面试是面试**：实际开发要考虑可维护性和业务需求
- 但对于**单一算法优化**：数字操作确实是性能最优选择

## AI 总结

本视频通过实际性能测试对比了三种查找回文数的算法实现。测试结果显示，在100万数量级下：数组转换方式最慢（408ms），字符串操作居中（53ms），数字直接操作最快（42ms）。

**关键发现**：虽然三种方法的时间复杂度都是 O(n)，但数组方式涉及大量类型转换和数据结构操作，导致实际性能下降10倍。

**核心建议**：在算法优化中，应遵循"数字 > 字符串 > 数组"的优先级原则，尽量使用低级数据结构，避免频繁的类型转换，因为计算机本质是计算器，数字运算是最底层、最快的操作。