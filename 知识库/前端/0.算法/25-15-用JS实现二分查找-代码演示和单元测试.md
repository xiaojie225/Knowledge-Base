# 用 JS 实现二分查找 - 代码演示和单元测试

## 目录

- [二分查找的两种实现方式](#二分查找的两种实现方式)
- [循环方式实现二分查找](#循环方式实现二分查找)
- [递归方式实现二分查找](#递归方式实现二分查找)
- [单元测试](#单元测试)
- [AI 总结](#ai-总结)

---

## 二分查找的两种实现方式

本视频演示了用 JavaScript 实现二分查找算法的两种方式：

1\. **循环方式**：代码执行速度稍快
2\. **递归方式**：代码看起来更简洁

两种方式的核心思路完全相同，只是实现形式不同。

---

## 循环方式实现二分查找

### 函数签名

创建函数 `binarySearch1`，接受以下参数：

- `array`: 一个**已排序**的数字数组（Number 类型数组）
- `target`: 要查找的目标数字
- 返回值：Number 类型，表示目标数字在数组中的索引（index）
  - 如果找到，返回该数字的索引位置
  - 如果找不到，返回负一（-1）

### 实现步骤

**1\. 初始化变量**

```javascript
// 获取数组长度
let len = array.length;

// 如果数组为空，直接返回 -1
if (len === 0) {
  return -1;
}

// 定义开始位置（startIndex）
let startIndex = 0;

// 定义结束位置（endIndex）
let endIndex = len - 1;
```

这里的 `startIndex` 和 `endIndex` 定义了当前查找的范围：
- 初始时，范围是整个数组（从第一个元素到最后一个元素）
- 随着查找过程，范围会不断缩小
- 使用 `let` 定义是因为这两个变量会在后续过程中被修改

**2\. 循环查找**

```javascript
while (startIndex <= endIndex) {
  // 查找逻辑
}
```

循环条件：`startIndex <= endIndex`
- 当 `startIndex` 小于等于 `endIndex` 时，说明还有查找范围
- 当两者相交（startIndex > endIndex）时，说明已经查找完整个范围还没找到目标值，此时应返回 -1

**3\. 计算中间位置和中间值**

```javascript
// 计算中间索引
let midIndex = Math.floor((startIndex + endIndex) / 2);

// 获取中间位置的值
let midValue = array[midIndex];
```

`Math.floor()` 的作用：将小数点后的部分去除，确保索引是整数。

**4\. 比较并调整查找范围**

根据目标值与中间值的比较结果，决定下一步在哪个区间继续查找：

```javascript
if (target < midValue) {
  // 目标值较小，继续在左侧查找
  endIndex = midIndex - 1;
} else if (target > midValue) {
  // 目标值较大，继续在右侧查找
  startIndex = midIndex + 1;
} else {
  // 相等，找到目标值
  return midIndex;
}
```

**为什么要减一或加一？**
- 因为 `midValue` 这个值已经做过比较了，没必要再比较
- 直接跳过它，从它的左侧或右侧继续查找

**5\. 未找到的情况**

如果循环结束后仍未找到目标值，返回 -1：

```javascript
return -1;
```

### 功能测试

```javascript
// 测试数组
let arr = [10, 20, 30, 40, 50, 60];

// 查找 20
console.log(binarySearch1(arr, 20)); // 输出: 1

// 查找不存在的值
console.log(binarySearch1(arr, 200)); // 输出: -1
```

---

## 递归方式实现二分查找

### 函数签名

创建函数 `binarySearch2`，参数与循环方式不同：

```javascript
function binarySearch2(
  array,        // 数组
  target,       // 目标值
  startIndex?,  // 可选参数：开始索引
  endIndex?     // 可选参数：结束索引
) {
  // 实现代码
}
```

**参数说明：**
- 前两个参数与循环方式相同
- 后两个参数是**可选参数**（用 `?` 标记）
  - 可传可不传
  - 如果传入，表示明确了查找范围
  - 如果不传，则默认查找整个数组

### 实现步骤

**1\. 初始化检查**

```javascript
let len = array.length;

// 如果数组为空，返回 -1
if (len === 0) {
  return -1;
}
```

**2\. 处理可选参数**

如果 `startIndex` 和 `endIndex` 没有传入，给它们设置默认值：

```javascript
// 如果 startIndex 未定义，默认为 0
if (startIndex === undefined) {
  startIndex = 0;
}

// 如果 endIndex 未定义，默认为数组最后一个索引
if (endIndex === undefined) {
  endIndex = len - 1;
}
```

**3\. 递归结束条件**

```javascript
// 如果 startIndex 大于 endIndex，说明范围已经相交，找不到目标值
if (startIndex > endIndex) {
  return -1;
}
```

**注意：** 这里是 `>` 而不是 `>=`
- 当 `startIndex === endIndex` 时，还有一个元素需要检查
- 只有当 `startIndex > endIndex` 时才真正结束

**4\. 计算中间位置和中间值**

```javascript
let midIndex = Math.floor((startIndex + endIndex) / 2);
let midValue = array[midIndex];
```

**5\. 递归调用**

根据比较结果，递归调用自身：

```javascript
if (target < midValue) {
  // 目标值较小，继续在左侧查找
  return binarySearch2(array, target, startIndex, midIndex - 1);
} else if (target > midValue) {
  // 目标值较大，继续在右侧查找
  return binarySearch2(array, target, midIndex + 1, endIndex);
} else {
  // 相等，找到目标值
  return midIndex;
}
```

**递归思路：**
- 在左侧查找：保持 `startIndex` 不变，将 `endIndex` 设为 `midIndex - 1`
- 在右侧查找：将 `startIndex` 设为 `midIndex + 1`，保持 `endIndex` 不变

### 与循环方式的对比

两种方式的核心思路完全相同：
- **循环方式**：通过修改 `startIndex` 和 `endIndex` 的值来缩小查找范围
- **递归方式**：通过传递不同的 `startIndex` 和 `endIndex` 参数来缩小查找范围

### 功能测试

```javascript
// 测试数组
let arr = [10, 20, 30, 40, 50, 60];

// 查找 20
console.log(binarySearch2(arr, 20)); // 输出: 1

// 查找 30
console.log(binarySearch2(arr, 30)); // 输出: 2

// 查找 40
console.log(binarySearch2(arr, 40)); // 输出: 3
```

### 调试过程中的问题

**初始代码的错误：**
```javascript
if (startIndex === endIndex) {
  return -1;
}
```

这个条件太严格了。当 `startIndex === endIndex` 时，还有一个元素没有检查。

**修正后的代码：**
```javascript
if (startIndex > endIndex) {
  return -1;
}
```

修改原因：
- 当 `startIndex === endIndex` 时，范围内还有一个元素，应该继续执行计算和比较
- 只有当 `startIndex > endIndex` 时，才真正表示查找范围为空，应该返回 -1

---

## 单元测试

单元测试是一个良好的职业素养，就像算法敏感度一样。写习惯之后，如果不写单元测试会感到很不舒服。

### 测试用例设计

需要导出函数才能进行测试：

```javascript
export { binarySearch1, binarySearch2 };
```

使用 Jest 框架编写测试用例，测试三种情况：

**1\. 正常情况**

```javascript
describe('二分查找', () => {
  it('正常情况', () => {
    const array = [10, 20, 30, 40, 50];
    const target = 40;
    const index = binarySearch1(array, target);
    
    expect(index).toBe(3); // 40 在索引 3 的位置
  });
});
```

**2\. 空数组**

```javascript
it('空数组', () => {
  expect(binarySearch1([], 10)).toBe(-1);
});
```

空数组应该返回 -1，因为没有任何元素可查找。

**3\. 找不到目标值**

```javascript
it('找不到目标值', () => {
  const array = [10, 20, 30, 40, 50];
  expect(binarySearch1(array, 400)).toBe(-1);
});
```

当目标值不在数组中时，应该返回 -1。

### 运行测试

使用 Jest 命令运行测试：

```bash
jest
```

测试通过后，确认两种实现方式都工作正常。

---

## AI 总结

本视频详细讲解了二分查找算法的两种 JavaScript 实现方式：循环和递归。两种方式的核心思路相同，都是通过不断缩小查找范围来定位目标值。关键要点包括：

1. **核心思想**：每次取中间位置的值与目标值比较，根据大小关系决定在左半部分还是右半部分继续查找
2. **循环实现**：通过修改 `startIndex` 和 `endIndex` 变量来调整查找范围
3. **递归实现**：通过传递不同的参数来调整查找范围，需要正确处理可选参数和递归终止条件
4. **边界条件**：注意 `midIndex ± 1` 的处理，以及 `startIndex > endIndex` 作为终止条件
5. **单元测试**：良好的职业习惯，应涵盖正常情况、空数组和找不到目标值三种场景

画图是理解算法的好方法，但实现时需要注意代码细节，如索引的加减一操作和循环/递归的终止条件。