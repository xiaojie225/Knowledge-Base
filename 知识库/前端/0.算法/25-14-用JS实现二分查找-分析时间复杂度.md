# 用 JS 实现二分查找 - 分析时间复杂度

## 目录

- [什么是二分查找](#什么是二分查找)
- [二分查找的原理与过程](#二分查找的原理与过程)
- [二分查找的实现方式](#二分查找的实现方式)
- [时间复杂度分析](#时间复杂度分析)
- [O(log n) 的强大优势](#olog-n-的强大优势)
- [二分思想的实际应用案例](#二分思想的实际应用案例)
- [log n 的数学含义](#log-n-的数学含义)
- [AI 总结](#ai-总结)

---

## 什么是二分查找

二分查找是一个非常常见、非常经典且非常常用的算法。它在面试和工作中都经常出现。虽然日常工作中不会自己手写二分查找，但在使用的所有 API 中，二分查找扮演着非常重要的角色。

**核心要求**：二分查找必须应用于**有序数组**（递增或递减），即可排序的数组。

---

## 二分查找的原理与过程

假设有一个递增数组：`[1, 2, 3, 5, 6, 10, ..., 10000]`

现在要查找数字 `100` 是否存在于数组中。

**查找步骤**：

1. **第一次二分**：找到数组中间位置的元素，假设是 `5000`
   - 因为 `5000 > 100`，且数组递增
   - 所以 `100` 只可能在左半部分

2. **第二次二分**：在左半部分找到中间位置，假设是 `1000`
   - 因为 `1000 > 100`
   - 所以 `100` 只可能在更左边的部分

3. **第三次二分**：继续在左半部分找中间位置，假设是 `80`
   - 因为 `80 < 100`
   - 所以 `100` 只可能在右半部分

4. **持续二分**：不断将范围一分为二，从中间位置继续二分，直到找到目标值 `100`

**关键特点**：每次都将查找范围缩小一半，性能非常优秀。**输入量越大，二分查找的性能优势越明显**。

- 10 万数据一分为二 → 5 万
- 100 万数据一分为二 → 50 万（节省 50 万次比较）

---

## 二分查找的实现方式

二分查找是一个基础且常用的算法，属于**固定公式**类型的算法。

### 两种实现方式

1. **递归实现**
   - 每次都二分之一，逻辑更加清晰
   - 代码结构清晰易懂

2. **非递归实现（循环实现）**
   - 使用无限循环（while 循环）
   - 性能更好（在同一时间复杂度量级内表现更优）
   - 例如：递归可能需要 20 次操作，循环可能只需 15 次

**注意**：所有递归都可以改成非递归形式，所有无限循环的递归都可以改成递归形式，它们是可以相互转换的。

---

## 时间复杂度分析

二分查找的时间复杂度为 **$O(\log n)$**

### 时间复杂度对比

根据时间复杂度曲线图：

- **$O(1)$**：无论输入量如何增加，计算量都不变，非常快
- **$O(\log n)$**：仅次于 $O(1)$，随着输入量增加，计算量增长曲线趋于平缓
- **$O(n)$**：线性增长，输入量是多少，计算量就是多少
- **$O(n^2)$**：输入量的平方级增长

### O(log n) 的特点

1. **随着输入量增加，增长曲线越来越平缓**
2. **输入量越大，与 $O(n)$ 的差距越大**（呈喇叭口形式）
3. **输入量小的时候看不出优势**，但输入量大时优势极其明显
4. **是算法设计中追求的黄金标准之一**

很多复杂的数据结构（如红黑树、平衡树、B 树等）的设计目的，就是为了将整体算法复杂度控制在 $O(\log n)$ 级别。

---

## O(log n) 的强大优势

### 案例一：百度后台系统问题排查

多年前，百度一个非常复杂的后台系统出现性能问题，系统很慢但难以定位。

**排查方法**：某位工程师使用二分思想

1. 将整个系统视为一个线性流程关系：输入 → 多个子系统 → 输出
2. 从中间位置设置断点，对比时间消耗
3. 假设总耗时 10 秒：
   - 前半部分耗时 8 秒
   - 后半部分耗时 2 秒
   - **问题定位在前半部分**
4. 继续在前半部分二分：
   - 某段耗时 7 秒
   - 另一段耗时 1 秒
   - **问题进一步缩小到 7 秒的部分**
5. 不断二分，最终高效定位问题

**启示**：二分思想不仅适用于算法，也适用于问题排查等实际场景。

### 案例二：离婚财产分割（比喻）

假设一个人有 1 亿资产：

- 离婚一次 → 二分 → 剩 5000 万
- 再离婚一次 → 二分 → 剩 2500 万
- 再离婚一次 → 二分 → 剩 1250 万
- 再离婚一次 → 二分 → 剩 600 多万

**只需几次就降到原来的十分之一**，说明二分的速度极快。

---

## 二分思想的实际应用案例

### 重要性

二分法是算法中**最重要的思路之一**。

在面试或考试中：
- 如果连二分查找都不会，会被认为**基础不扎实**
- 遇到问题时要主动思考能否用二分法优化
- 将暴力解法转化为二分形式

---

## log n 的数学含义

$O(\log n)$ 中的 **log n** 可以理解为 **$n^2$ 的镜像反转**。

### 数学关系

- **$n^2$（平方）**：
  - 输入量 = 2 → 计算量 = 4
  - 输入量 = 3 → 计算量 = 9
  - 输入量 = 100 → 计算量 = 10000

- **$\log n$（对数）**：正好相反
  - 输入量 = 4 → 计算量 ≈ 2
  - 输入量 = 9 → 计算量 ≈ 3
  - 输入量 = 10000 → 计算量 ≈ 100

### 形象理解

将 $n^2$ 曲线像"手心变手背"一样镜面翻转，就得到 $\log n$ 曲线。

**结论**：$n^2$ 增长有多迅速，$\log n$ 就有多淡定。

---

## AI 总结

本节详细讲解了二分查找算法的原理、实现方式及其时间复杂度。二分查找要求数组有序，通过每次将查找范围缩小一半，实现高效查找。其时间复杂度为 $O(\log n)$，是仅次于 $O(1)$ 的优秀算法。输入量越大，二分查找的性能优势越明显。二分思想不仅适用于算法实现，还可应用于实际问题排查等场景。掌握二分查找是算法学习中的基础且重要的一环,在面试和工作中都极为常用。