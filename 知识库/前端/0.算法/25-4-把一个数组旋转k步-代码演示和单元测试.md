# 数组旋转 K 步 - 代码演示和单元测试

## 目录

- [问题描述](#问题描述)
- [解题思路](#解题思路)
- [第一种实现方法 - Pop 和 Unshift](#第一种实现方法---pop-和-unshift)
- [第二种实现方法 - Concat 拼接](#第二种实现方法---concat-拼接)
- [单元测试](#单元测试)
- [代码细节补充说明](#代码细节补充说明)
- [AI 总结](#ai-总结)

## 问题描述

给定一个数组，例如 `[1, 2, 3, 4, 5, 6, 7]`，要求将其旋转 K 步。

**旋转规则**：
- 当 K = 3 时，旋转 3 步
- 第一步：将最后一个元素 7 移到最前面，得到 `[7, 1, 2, 3, 4, 5, 6]`
- 第二步：将最后一个元素 6 移到最前面，得到 `[6, 7, 1, 2, 3, 4, 5]`
- 第三步：将最后一个元素 5 移到最前面，得到 `[5, 6, 7, 1, 2, 3, 4]`

**最终结果**：`[5, 6, 7, 1, 2, 3, 4]`

## 解题思路

针对这个问题，有两种主要的实现思路：

### 思路一：Pop 和 Unshift

在原数组上直接操作：
1. 使用 `pop()` 方法弹出数组最后一个元素
2. 使用 `unshift()` 方法将该元素插入到数组最前面
3. 重复 K 次

**示例**：`[1, 2, 3, 4, 5, 6, 7]` → 旋转 3 步
- 第一步：pop 出 7，unshift 到前面
- 第二步：pop 出 6，unshift 到前面
- 第三步：pop 出 5，unshift 到前面
- 结果：`[5, 6, 7, 1, 2, 3, 4]`

**特点**：在原数组上操作，不创建新数组

### 思路二：Concat 拼接

通过数组切片和拼接实现：
1. 将数组切分成两部分
2. `part1`：取后 K 个元素（`slice(-K)`）→ `[5, 6, 7]`
3. `part2`：取前面的元素（`slice(0, length - K)`）→ `[1, 2, 3, 4]`
4. 将两部分拼接：`part1.concat(part2)` → `[5, 6, 7, 1, 2, 3, 4]`

**特点**：创建新数组，通过切片和拼接实现

### 性能对比

在前端开发中，我们遵循"重时间轻空间"的原则：
- **时间复杂度**权重更高
- **空间复杂度**权重相对较低

需要通过分析时间复杂度和空间复杂度来选择最优解法。

## 第一种实现方法 - Pop 和 Unshift

### 代码实现

创建文件 `array-rotate.ts`：

```typescript
/**
 * 旋转数组 K 步 - 使用 pop 和 unshift
 * @param arr - Number 类型的数组
 * @param k - 旋转步数
 * @returns Number 类型的数组
 */
export function rotate1(arr: number[], k: number): number[] {
  const length = arr.length;
  
  // 边界情况处理
  if (!k || length === 0) {
    return arr;
  }
  
  // 计算实际步数（处理负数和大于 length 的情况）
  const step = Math.abs(k % length);
  
  // 循环 step 次，每次将最后一个元素移到最前面
  for (let i = 0; i < step; i++) {
    const n = arr.pop();
    if (n != null) {  // 注意：使用 != null 而不是 !== null，因为可能是 0
      arr.unshift(n);
    }
  }
  
  return arr;
}
```

### TypeScript 语法说明

- `arr: number[]`：表示参数是 Number 类型的数组
- `k: number`：表示参数是 Number 类型
- `: number[]`：表示函数返回 Number 类型的数组

如果使用 JavaScript，可以去掉类型标注。

### 关键点

1. **边界处理**：
   - 如果 K 没有值或数组长度为 0，直接返回原数组
   
2. **步数计算**：
   - 使用 `Math.abs()` 取绝对值，处理负数情况
   - 使用取余 `k % length` 处理 K 大于数组长度的情况
   
3. **循环操作**：
   - 时间复杂度：$O(n)$，其中 n 为 step 的值
   - 每次循环执行 `pop()` 和 `unshift()` 操作

4. **判断条件**：
   - 使用 `!= null` 而不是 `!== null`，因为弹出的值可能是 0

### 功能测试

```typescript
const arr1 = [1, 2, 3, 4, 5, 6, 7];
const result1 = rotate1(arr1, 3);
console.log(result1);  // [5, 6, 7, 1, 2, 3, 4]
```

## 第二种实现方法 - Concat 拼接

### 代码实现

```typescript
/**
 * 旋转数组 K 步 - 使用 concat
 * @param arr - Number 类型的数组
 * @param k - 旋转步数
 * @returns Number 类型的数组
 */
export function rotate2(arr: number[], k: number): number[] {
  const length = arr.length;
  
  // 边界情况处理
  if (!k || length === 0) {
    return arr;
  }
  
  // 计算实际步数
  const step = Math.abs(k % length);
  
  // 切分数组并拼接
  const part1 = arr.slice(-step);        // 取后 step 个元素
  const part2 = arr.slice(0, length - step);  // 取前面的元素
  const part3 = part1.concat(part2);     // 拼接
  
  return part3;
}
```

### Slice 方法说明

**`slice(-step)`**：
- 从数组末尾开始取 step 个元素
- 例如：`[1, 2, 3, 4].slice(-2)` → `[3, 4]`

**`slice(0, length - step)`**：
- 从索引 0 开始，取到 `length - step` 位置（不包含）
- 例如：`[1, 2, 3, 4].slice(0, 2)` → `[1, 2]`

### 关键特点

1. **不修改原数组**：创建新数组进行操作
2. **步骤清晰**：切分 → 拼接
3. **空间复杂度**：需要额外空间存储新数组

## 单元测试

### 测试环境配置

使用 Jest 进行单元测试，创建文件 `array-rotate.test.ts`：

```typescript
import { rotate1, rotate2 } from './array-rotate';

describe('数组旋转', () => {
  // 测试用例 1: 正常情况
  it('正常情况', () => {
    const arr = [1, 2, 3, 4, 5, 6, 7];
    const k = 3;
    const result = rotate1(arr, k);
    expect(result).toEqual([5, 6, 7, 1, 2, 3, 4]);
  });

  // 测试用例 2: 数组为空
  it('数组为空', () => {
    const arr: number[] = [];
    const k = 3;
    const result = rotate1(arr, k);
    expect(result).toEqual([]);
  });

  // 测试用例 3: K 是负数
  it('K 是负数', () => {
    const arr = [1, 2, 3, 4, 5, 6, 7];
    const k = -3;
    const result = rotate1(arr, k);
    expect(result).toEqual([5, 6, 7, 1, 2, 3, 4]);
  });

  // 测试用例 4: K 不是数字
  it('K 不是数字', () => {
    const arr = [1, 2, 3, 4, 5, 6, 7];
    // @ts-ignore
    const k = 'abc';
    const result = rotate1(arr, k);
    expect(result).toEqual([1, 2, 3, 4, 5, 6, 7]);
  });

  // 测试用例 5: K 是 0
  it('K 是 0', () => {
    const arr = [1, 2, 3, 4, 5, 6, 7];
    const k = 0;
    const result = rotate1(arr, k);
    expect(result).toEqual([1, 2, 3, 4, 5, 6, 7]);
  });
});
```

### 单元测试语法

**`describe()`**：描述一个测试用例组
- 第一个参数：测试组的描述
- 第二个参数：包含多个测试用例的函数

**`it()`**：定义单个测试用例
- 第一个参数：测试用例的描述
- 第二个参数：测试逻辑的函数

**`expect().toEqual()`**：断言
- `expect(result)`：期望的结果
- `.toEqual([...])`：应该等于某个值

### 运行测试

```bash
npx jest src/array-rotate.test
```

测试结果会显示所有测试用例是否通过。

### 测试覆盖的场景

1. **正常情况**：标准的旋转操作
2. **数组为空**：边界情况处理
3. **K 是负数**：通过 `Math.abs()` 处理
4. **K 不是数字**：异常输入处理
5. **K 是 0**：无需旋转的情况

### 单元测试的重要性

**在工作中**：
- 保证代码的健壮性
- 防止改动引入 bug
- 特别是对于复杂算法，单元测试必不可少

**在面试中**：
- 展现单元测试思维是巨大的加分项
- 大多数候选人不会主动写单元测试
- 即使在纸上写 3-5 个测试用例也能体现专业性
- 在大厂中，复杂逻辑的单元测试非常被看重

## 代码细节补充说明

### 问题一：判断条件修正

在第一版代码中，判断条件写错了：

```typescript
// 错误写法
if (n === null) {
  arr.unshift(n);
}

// 正确写法
if (n != null) {  // 使用 != 而不是 !==
  arr.unshift(n);
}
```

**原因**：
- 使用 `!= null` 可以同时判断 `null` 和 `undefined`
- 如果弹出的值是 0，`0 != null` 返回 `true`，逻辑正确

### 问题二：K 不是数字的处理机制

当 K 不是数字时，代码为什么能正常工作？

**分析过程**：

```typescript
const step = Math.abs(k % length);
```

如果 K 不是数字：
1. `k % length` 的结果是 `NaN`
2. `Math.abs(NaN)` 的结果仍然是 `NaN`
3. `step` 被赋值为 `NaN`

在循环判断中：
```typescript
for (let i = 0; i < step; i++) {
  // ...
}
```

**关键点**：`0 < NaN` 的结果是 `false`

**NaN 的特性**：
- 任何数值与 NaN 进行比较运算，结果都是 `false`
- 因此循环不会执行
- 直接返回原数组

**验证**：
```javascript
console.log(0 < NaN);  // false
```

所以当 K 不是数字时，循环不会执行，函数直接返回原数组，行为符合预期。

## AI 总结

本节课程详细讲解了"数组旋转 K 步"这道算法题的两种实现方法：

**方法一（Pop + Unshift）**：在原数组上操作，通过循环将末尾元素移到前面，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。

**方法二（Concat 拼接）**：通过数组切片和拼接创建新数组，代码简洁清晰，但需要额外的空间复杂度 $O(n)$。

课程特别强调了**单元测试的重要性**，展示了如何使用 Jest 编写完整的测试用例，覆盖正常情况、边界情况（空数组、K 为 0）、异常情况（K 为负数、K 不是数字）等多种场景。在工作和面试中，主动编写单元测试能够体现工程师的专业素养和代码质量意识，是一个重要的加分项。

课程还详细解释了 TypeScript 语法、边界处理逻辑，以及为什么当 K 不是数字时代码仍能正常工作（NaN 的比较特性）。整体内容注重实践和细节，帮助学习者掌握算法实现的同时，培养良好的编码习惯。