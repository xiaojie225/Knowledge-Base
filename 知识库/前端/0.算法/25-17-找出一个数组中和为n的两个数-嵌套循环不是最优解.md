# 找出数组中和为 n 的两个数 - 嵌套循环不是最优解

## 目录

- [问题描述](#问题描述)
- [基础解法：嵌套循环](#基础解法嵌套循环)
- [代码实现](#代码实现)
- [单元测试](#单元测试)
- [性能分析](#性能分析)
- [AI 总结](#ai-总结)

## 问题描述

给定一个**递增的数组**，找出其中和为 n 的两个元素。

**示例：**
- 输入数组：`[1, 2, 4, 7, 11, 15]`
- 目标和：`n = 15`
- 输出结果：`[4, 11]`（因为 4 + 11 = 15）

**题目特点：**
- 数组是**递增**的（这是优化的关键）
- 只需找**两个数**（不是多个数）
- 题目设计合理，通常只有一组解（不会有多组答案）
- 如果数组不是递增的，就无法利用递增特性来优化算法

## 基础解法：嵌套循环

### 算法思路

最基本的思路是使用**嵌套循环**：
1. 外层循环遍历第一个数
2. 内层循环从当前位置往后查找第二个数
3. 判断两数之和是否等于目标值 n

**时间复杂度：** $O(n^2)$

虽然这个方法基本不可用（性能太差），但这是最直观的解法，任何人都能想到。然而作为大厂前端算法题，这显然不是最优答案。

## 代码实现

```javascript
/**
 * 嵌套循环找和为 n 的两个数
 */
function findTwoNum1(arr, n) {
  // 定义结果数组
  const res = [];
  
  // 获取数组长度
  const length = arr.length;
  
  // 如果数组为空，直接返回空数组
  if (length === 0) return res;
  
  // 外层循环：遍历第一个数
  for (let i = 0; i < length - 1; i++) {
    const n1 = arr[i];
    let flag = false; // 标记是否找到结果
    
    // 内层循环：从 i+1 开始遍历第二个数
    // 注意：j 从 i+1 开始，因为前面的数已经比较过了
    for (let j = i + 1; j < length; j++) {
      const n2 = arr[j];
      
      // 判断两数之和是否等于 n
      if (n1 + n2 === n) {
        res.push(n1);
        res.push(n2);
        flag = true;
        break; // 找到结果后立即跳出内层循环
      }
    }
    
    // 如果已经找到结果，跳出外层循环
    if (flag) {
      break;
    }
  }
  
  return res;
}

// 功能测试
const arr = [1, 2, 4, 7, 11, 15];
console.log(findTwoNum1(arr, 15)); // 输出: [4, 11]
```

### 代码要点

1\. **内层循环起始位置**：`j = i + 1`
   - 从当前位置往后开始取值
   - 前面的数已经比较过，无需重复比较
   - 虽然不是完整遍历，但时间复杂度仍是 $O(n^2)$

2\. **及早断开循环**：使用 `flag` 和 `break`
   - 找到结果后立即跳出循环
   - 可以减少无意义的循环次数
   - 但如果结果在最后才找到，优化效果不明显

3\. **边界处理**：
   - 空数组直接返回空结果
   - 外层循环到 `length - 1`，因为最后一个元素无需比较

## 单元测试

```javascript
/**
 * 两数之和测试
 */
describe('两数之和', () => {
  // 用例1：正常情况
  it('正常情况', () => {
    const arr = [1, 2, 4, 7, 11, 15];
    const result = findTwoNum1(arr, 15);
    expect(result).toEqual([4, 11]);
  });
  
  // 用例2：空数组
  it('空数组', () => {
    const result = findTwoNum1([], 100);
    expect(result).toEqual([]);
  });
  
  // 用例3：找不到结果
  it('找不到结果', () => {
    const arr = [1, 2, 4, 7, 11, 15];
    const result = findTwoNum1(arr, 100);
    expect(result).toEqual([]);
  });
});
```

**运行测试：**
```bash
npx jest
```

### 测试用例设计

至少需要三类用例：

1. **正常情况**：能找到符合条件的两个数
2. **空数组情况**：测试边界条件
3. **找不到结果**：目标值不存在对应的两数之和

所有测试通过后，说明基础功能实现正确。

## 性能分析

### 时间复杂度

虽然内层循环没有完整遍历数组，但从**数量级**角度来说，只要有两层循环且没有使用二分等优化算法，**时间复杂度就是 $O(n^2)$**。

**时间复杂度讲的是数量级，不扣细节。**

### 优化空间

当前的嵌套循环解法基本不可用，因为：
- $O(n^2)$ 的时间复杂度在大数据量下性能很差
- 没有利用**数组递增**这个重要特性
- 大厂面试题不会接受这种基础解法

**下一步优化方向：**
- 利用递增特性优化算法
- 降低时间复杂度（目标：$O(n)$ 或 $O(n \log n)$）
- 后续会讲解更优的解法（如双指针法）

### 总结

这个基础解法虽然能解决问题，但：
- ✅ 逻辑清晰，容易理解
- ✅ 功能完整，测试通过
- ❌ 性能较差，不适合生产环境
- ❌ 未利用数组递增特性

单元测试已经准备好，后续优化算法时可以直接复用这些测试用例。

## AI 总结

本节讲解了"找出数组中和为 n 的两个数"这个经典算法题的基础解法。题目给定一个递增数组和目标和 n，要求找出数组中两个元素使其和等于 n。

**嵌套循环解法**是最直观的方法：外层循环选择第一个数，内层循环从后续位置选择第二个数，判断两数之和。代码实现中注意内层循环从 `i+1` 开始以避免重复比较，并使用 `flag` 和 `break` 及早终止循环。虽然这样做能减少一些不必要的循环，但整体时间复杂度仍为 $O(n^2)$，在大数据量下性能较差。

完整的单元测试覆盖了正常情况、空数组和找不到结果三种典型场景，为后续算法优化提供了验证基础。这个基础解法虽然能通过测试，但未能利用数组递增这一关键特性，因此不是最优解，后续需要进一步优化（如使用双指针法）来降低时间复杂度。