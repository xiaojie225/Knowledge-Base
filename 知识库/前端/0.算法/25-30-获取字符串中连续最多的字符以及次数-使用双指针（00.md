# 获取字符串中连续最多的字符以及次数 - 使用双指针

## 目录

- [双指针思路介绍](#双指针思路介绍)
- [双指针算法原理](#双指针算法原理)
- [代码实现](#代码实现)
- [代码细节说明](#代码细节说明)
- [性能测试与验证](#性能测试与验证)
- [AI 总结](#ai-总结)

## 双指针思路介绍

除了使用嵌套循环的方式，解决字符串中连续字符问题还有一个非常好的思路：**双指针**。

双指针是解决嵌套循环问题的一个非常经典的方法。在很多场景中都需要使用双指针，因此需要熟练掌握这种思路。一旦遇到嵌套循环的问题，都可以考虑使用双指针能否解决。

## 双指针算法原理

### 基本思想

定义两个指针 `i` 和 `j`：

1. 初始时，`i` 和 `j` 都指向字符串的起始位置
2. `i` 指针不断向前移动
3. 当 `i` 和 `j` 指向的字符相等时，`i` 继续移动
4. 当 `i` 和 `j` 指向的字符不相等时，记录并处理当前连续字符的长度，然后让 `j` 追上 `i`
5. 重复上述过程直到遍历完整个字符串

### 具体示例

以字符串 `"aaabbcccd"` 为例：

- 初始：`j` 和 `i` 都指向第一个 `a`
- `i` 向前移动，指向第二个 `a`，与 `j` 相等，继续移动
- `i` 指向第三个 `a`，与 `j` 相等，继续移动
- `i` 指向 `b`，与 `j` 的 `a` 不相等，此时计算连续 `a` 的长度（3个），然后让 `j` 追上 `i`，指向 `b`
- `i` 继续向前，指向第二个 `b`，与 `j` 相等，继续移动
- `i` 指向 `c`，与 `j` 的 `b` 不相等，计算连续 `b` 的长度（2个），`j` 追上 `i`
- 以此类推，直到遍历完整个字符串

### 时间复杂度

双指针方法只需要一次循环，时间复杂度为 **O(n)**，这一点非常明显，不需要过多解释。相比嵌套循环的方式，双指针的时间复杂度更加清晰易懂。

## 代码实现

### 初始化部分

```javascript
// 定义函数名为 findContinuousStr2（使用双指针）
function findContinuousStr2(str) {
  // 初始化结果对象
  let result = { char: '', length: 0 };
  
  // 如果字符串长度为0，直接返回空结果
  if (str.length === 0) {
    return result;
  }
  
  // 定义临时长度变量
  let tempLength = 0;
  
  // 定义双指针
  let i = 0;
  let j = 0;
  
  // 主循环逻辑
  for (; i < str.length; i++) {
    // 如果当前字符与 j 指向的字符相等
    if (str[i] === str[j]) {
      // 累加临时长度
      tempLength++;
    }
    
    // 如果不相等或者 i 到达字符串末尾
    if (str[i] !== str[j] || i === str.length - 1) {
      // 如果当前临时长度大于结果长度，更新结果
      if (tempLength > result.length) {
        result.char = str[j];  // 注意：这里使用 j 而不是 i
        result.length = tempLength;
      }
      
      // 重置临时长度
      tempLength = 0;
      
      // 如果 i 没有到达末尾，让 j 追上 i
      if (i < str.length - 1) {
        j = i;
        i--;  // i 减1，因为循环会自动 i++
      }
    }
  }
  
  return result;
}
```

## 代码细节说明

### 关键点1：使用 `str[j]` 而不是 `str[i]`

在处理不相等的情况时，应该使用 `str[j]` 来记录字符：

```javascript
result.char = str[j];  // 正确
// result.char = str[i];  // 错误
```

**原因**：当 `i` 和 `j` 不相等时，`i` 已经指向了下一个不同的字符，而 `j` 仍然指向当前正在统计的字符。例如，当 `i` 指向 `b` 而 `j` 指向 `a` 时，我们应该处理的是 `a` 的长度，而不是 `b`。

### 关键点2：`i--` 的细节处理

```javascript
if (i < str.length - 1) {
  j = i;
  i--;  // 关键：i 减1
}
```

**原因**：当 `j` 追上 `i` 后，由于 `for` 循环会自动执行 `i++`，如果不先执行 `i--`，就会导致 `i` 和 `j` 错开一位。通过 `i--`，可以确保下一次循环时 `i` 和 `j` 在同一位置。

这个细节虽然不影响整体思路的理解，但在实际代码运行时是必需的。在面试中，即使这个细节没有写对，只要整体思路正确，通常也不会有太大问题。

## 性能测试与验证

### 测试代码

```javascript
// 构造一个包含100万个字符的测试字符串
let s = '';
for (let i = 0; i < 1000000; i++) {
  s += i % 10;
}

// 测试方法1（嵌套循环）
console.time('time1');
findContinuousStr1(s);
console.timeEnd('time1');

// 测试方法2（双指针）
console.time('time2');
findContinuousStr2(s);
console.timeEnd('time2');
```

### 测试结果

- 方法1（嵌套循环）：约 219 毫秒
- 方法2（双指针）：约 228 毫秒

两种方法的执行时间基本相同，差异不到 0.1 倍，这验证了两种方法的时间复杂度都是 **O(n)** 级别。

相比之前测试的云函数和递归的差异（差距达到2倍），这两种方法在性能上几乎没有差别。

### 结论

从空间复杂度来讲，这两种方法也没有什么差别。虽然嵌套循环在最坏情况下是 O(n²)，但在实际场景中，由于字符串中连续字符的特性，其平均时间复杂度也接近 O(n)。

双指针方法的优势在于：
- 时间复杂度 O(n) 非常明显，不需要过多解释
- 代码逻辑清晰，易于理解
- 只需要一次遍历，效率稳定

## AI 总结

本视频详细讲解了使用双指针解决"获取字符串中连续最多的字符及次数"问题的方法。双指针是解决嵌套循环问题的经典思路，通过定义两个指针 `i` 和 `j`，让 `i` 不断向前移动，当遇到不同字符时记录长度并让 `j` 追上 `i`，从而实现一次遍历完成统计。

关键技术点包括：使用 `str[j]` 而非 `str[i]` 记录字符，以及在 `j` 追上 `i` 时需要执行 `i--` 来保证指针位置正确。性能测试表明，双指针方法与嵌套循环方法的实际执行时间相近，都达到了 O(n) 的时间复杂度，但双指针的优势在于逻辑更清晰、复杂度分析更直观。