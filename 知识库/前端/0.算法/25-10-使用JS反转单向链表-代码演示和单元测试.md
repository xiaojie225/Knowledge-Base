# 使用 JS 反转单向链表 - 代码演示和单元测试

## 目录

- [测试报错问题处理](#测试报错问题处理)
- [反转链表算法实现](#反转链表算法实现)
  - [第一个元素的特殊处理](#第一个元素的特殊处理)
  - [中间元素的反转逻辑](#中间元素的反转逻辑)
  - [指针整体后移](#指针整体后移)
  - [最后一个元素的处理](#最后一个元素的处理)
- [代码测试与验证](#代码测试与验证)
- [单元测试编写](#单元测试编写)
  - [测试用例设计](#测试用例设计)
  - [单个元素测试](#单个元素测试)
  - [多个元素测试](#多个元素测试)
- [TypeScript 类型处理](#typescript-类型处理)
- [学习方法建议](#学习方法建议)
- [AI 总结](#ai-总结)


## 反转链表算法实现

反转链表的核心思路是使用 `nextNode` 作为循环条件，只要 `nextNode` 还有值，就继续执行循环体中的代码。

### 第一个元素的特殊处理

```javascript
if (current && !prev) {
  delete current.next;
}
```

这段代码处理第一个元素的特殊情况：

- 当 `prev` 没有值，`current` 有值时，说明当前处于第一个元素
- 第一个元素是特殊的，因为它的 `next` 在反转后应该指向 `null`（没有前一个元素）
- 第二、三、四个元素都可以往前指向它们的前一个元素
- 但第一个元素没有前置元素可以指向，所以需要删除它的 `next` 属性

### 中间元素的反转逻辑

```javascript
if (current && prev) {
  current.next = prev;
}
```

这是处理中间元素的情况：

- 当 `prev` 有值且 `current` 也有值时，表示处于中间位置
- 反转指针：将 `current.next` 指向 `prev`，实现向前指向
- 指针本质上是一个引用或变量，`next` 就是一个指针，因为它指向了下一个节点

### 指针整体后移

```javascript
prev = current;
current = next;
next = next?.next;
```

反转完当前节点后，需要整体向后移动三个指针：

- `prev` 赋值为 `current`
- `current` 赋值为 `next`
- `next` 赋值为 `next.next`

这里使用了 TypeScript 的可选链操作符 `?.`：

- `?.` 的含义是：如果属性取不到，就返回 `null`
- 相当于一个判断：如果 `next` 有值，就返回 `next.next`；如果没有，就返回 `undefined`

### 最后一个元素的处理

```javascript
current!.next = prev;
```

当 `next` 为空时，循环就不会执行了，但还差最后一步：

- 此时 `current` 指向最后一个元素（例如 E）
- D 的 `next` 已经指向 C，C 的 `next` 指向 B，B 的 `next` 指向 A，A 的 `next` 被删除
- 但 E 和 D 之间还没有建立连接
- 因为当 `next` 为空时，循环体不会被执行，所以 E 的 `next` 还是空的
- 需要手动补上这一步：`current.next = prev`

这里使用了 TypeScript 的非空断言操作符 `!`，表示确定 `current` 有值，告诉 TypeScript 不要报错。

最后返回 `current!` 作为新的链表头节点。

## 代码测试与验证

创建测试链表并进行反转：

```javascript
const list = createLinkList([100, 200, 300, 400, 500]);
const list1 = reverseLinkList(list);
console.log(list1);
```

测试结果：

- 原链表：100 → 200 → 300 → 400 → 500
- 反转后：500 → 400 → 300 → 200 → 100

反转成功！

## 单元测试编写

### 测试用例设计

单元测试需要考虑两种情况：

1. **单个元素**：链表只有一个节点的特殊情况
2. **多个元素**：正常的多节点链表

### 单个元素测试

```javascript
describe('反转单向链表', () => {
  it('单个元素', () => {
    const node: ILinkListNode = { value: 100 };
    const node1 = reverseLinkList(node);
    expect(node1).toEqual({ value: 100 });
  });
});
```

测试单个元素的反转，确保特殊情况能正确处理。

### 多个元素测试

```javascript
it('多个元素', () => {
  const node = createLinkList([100, 200, 300]);
  const node1 = reverseLinkList(node);
  expect(node1).toEqual({
    value: 300,
    next: {
      value: 200,
      next: {
        value: 100
      }
    }
  });
});
```

测试多个元素的反转：

- 输入：100 → 200 → 300
- 预期输出：300 → 200 → 100
- 使用 `toEqual` 进行对象对比（对象对比用 `toEqual`，基本类型对比用 `toBe`）

运行测试：

```bash
npx jest src/reverse-link-list.test.ts
```

测试全部通过！

## TypeScript 类型处理

在代码中使用了几个 TypeScript 特性：

1. **可选链操作符 `?.`**：安全地访问可能不存在的属性
2. **非空断言操作符 `!`**：告诉 TypeScript 确定某个值不为空，不要报类型错误
3. **类型导入**：从实现文件导入接口和函数，保持类型一致性

这些是强制性的语法，用于告诉 TypeScript："这个我自己处理，你不要给我报错"。

## 学习方法建议

反转链表的核心要点：

1. **链表概念**：理解链表的结构和与数组的区别
   - 数组是连续存储，链表是离散存储
   - 它们的时间复杂度不同

2. **三个指针**：通过定义三个变量防止 `nextNode` 丢失
   - `prev`：指向前一个节点
   - `current`：指向当前节点
   - `next`：指向下一个节点

3. **特殊处理**：
   - 第一个元素的处理（删除 `next`）
   - 最后一个元素的处理（补充最后一次反转）

4. **画图分析**：一定要拿笔画图
   - 好记性不如烂笔头
   - 画出每个步骤的指针变化
   - 这是最好的学习方法

5. **动手实践**：
   - 多看几遍代码
   - 亲手写一遍
   - 亲自调试一遍

链表代码比较复杂，调试难度也比较高，需要仔细认真地编写和调试。后面还会有双向链表的内容，会更加复杂，所以必须把基础打好。如果前面的基础不扎实，后面会更加困难。

最后关于语法报错的问题：在讲课过程中突然出现，但调试后又消失了。如果这种问题不影响整体学习进度，可以先忽略，最后再去排查。如果在本地遇到类似问题，可以及时提问。

## AI 总结

本节课详细讲解了如何使用 JavaScript 实现单向链表的反转算法。核心思路是使用三个指针（`prev`、`current`、`next`）来遍历链表，同时反转每个节点的指向。重点需要处理两个特殊情况：第一个元素需要删除其 `next` 属性（因为反转后它成为最后一个节点），最后一个元素需要单独设置 `next` 指向前一个节点（因为循环结束时这步没有执行）。

课程还演示了完整的单元测试编写，包括单个元素和多个元素两种测试用例，强调了对象对比使用 `toEqual`、基本类型对比使用 `toBe` 的规范。在 TypeScript 类型处理方面，讲解了可选链操作符 `?.` 和非空断言操作符 `!` 的使用场景。

最重要的学习建议是：一定要通过画图来理解算法逻辑，好记性不如烂笔头；同时要多动手实践，亲自编写和调试代码，为后续更复杂的双向链表打好基础。