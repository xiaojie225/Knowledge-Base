# 移动0到数组的末尾 - splice会导致性能问题

## 目录

- [问题描述](#问题描述)
- [传统解法的问题](#传统解法的问题)
- [代码实现](#代码实现)
- [单元测试](#单元测试)
- [AI 总结](#ai-总结)

## 问题描述

将数组中的所有0移动到数组末尾，例如：`[0, 1, 3, 0, 11, 0]` 转换为 `[1, 3, 11, 0, 0, 0]`

**核心要求：**
- 移动0后其他元素顺序不变
- 必须在原数组上进行操作，不能创建新数组
- 这是面试要求，工作中通常会创建新数组而不修改原数据

**简单解法（不符合要求）：**
如果没有"必须在原数组操作"的限制，可以：
1. 定义两个数组
2. 遍历原数组，非0元素放入数组1，0元素放入数组2
3. 连接两个数组

这种方法简单但不符合面试要求。

## 传统解法的问题

**传统思路：**
遍历数组，遇到0就：
1. 将0 push 到数组末尾
2. 使用 splice 删除当前位置的0

**性能问题：**
- 时间复杂度：**O(n²)**，基本不可用
- splice 操作本身就是 O(n) 级别
- 外加遍历循环，整体达到 O(n²)

**原因分析：**
数组是连续存储结构，使用 splice 删除元素时：
- 删除位置后的所有元素都需要向前移动
- 例如删除索引2的元素，索引3、4、5...的元素都要前移一位
- 每次 splice 都会触发大量元素移动操作

**示例说明：**
对于数组 `[1, 0, 1, 0, 1]`：
1. 遇到第一个0，push到末尾变成 `[1, 0, 1, 0, 1, 0]`，splice删除变成 `[1, 1, 0, 1, 0]`
2. 遇到第二个0，push到末尾变成 `[1, 1, 0, 1, 0, 0]`，splice删除变成 `[1, 1, 1, 0, 0]`
3. 最终得到 `[1, 1, 1, 0, 0]`

**警告：**
网上很多人对这种算法点赞，但这是一个性能很差的方案。不要盲目跟从网上的代码，要独立思考，理解算法的真正复杂度。

## 代码实现

```typescript
// moveZero1.ts
export function moveZero1(arr: number[]): void {
    const length = arr.length;
    if (length === 0) return;
    
    let zeroLength = 0; // 记录当前有多少个0
    
    // 优化：只遍历到 length - zeroLength，因为后面都是0
    for (let i = 0; i < length - zeroLength; i++) {
        if (arr[i] === 0) {
            arr.push(0); // 将0添加到末尾
            arr.splice(i, 1); // 删除当前位置的0
            i--; // 处理连续0的情况，需要回退一位
            zeroLength++; // 累加0的个数
        }
    }
}
```

**代码细节说明：**

1. **循环优化：** `i < length - zeroLength`
   - 不需要遍历到数组末尾
   - 因为0会被移到最后，后面全是0无需再处理

2. **i-- 的作用：** 处理连续0的情况
   - 例如 `[1, 0, 0, 0, 1]` 有连续的0
   - 删除一个0后，后面的元素会前移
   - 需要回退一位重新检查当前位置

3. **zeroLength 的作用：**
   - 记录已处理的0的个数
   - 用于优化循环边界

**功能测试：**
```typescript
const arr = [1, 0, 3, 4, 0, 0, 11, 0];
moveZero1(arr);
console.log(arr); // [1, 3, 4, 11, 0, 0, 0, 0]
```

## 单元测试

```typescript
// moveZero.test.ts
import { moveZero1 } from './moveZero';

describe('移动0到数组末尾', () => {
    it('正常情况', () => {
        const arr = [1, 0, 3, 4, 0, 0, 11, 0];
        moveZero1(arr);
        expect(arr).toEqual([1, 3, 4, 11, 0, 0, 0, 0]);
    });
    
    it('没有0的情况', () => {
        const arr = [1, 3, 4, 11];
        moveZero1(arr);
        expect(arr).toEqual([1, 3, 4, 11]);
    });
    
    it('全是0', () => {
        const arr = [0, 0, 0, 0, 0];
        moveZero1(arr);
        expect(arr).toEqual([0, 0, 0, 0, 0]);
    });
});
```

**测试用例覆盖：**
- 正常情况：包含连续0的情况
- 边界情况：没有0
- 极端情况：全是0

**单元测试的重要性：**
在面试中编写单元测试是一个巨大优势，因为大部分候选人都没有这个习惯。完善的测试用例能体现：
- 对边界情况的考虑
- 代码质量意识
- 工程化思维

## AI 总结

本视频讲解了"移动数组中的0到末尾"这道算法题，重点分析了传统解法的性能问题。

**核心要点：**
- 使用 splice 删除元素会导致 O(n²) 的时间复杂度，因为数组是连续存储结构，删除操作会触发大量元素移动
- 处理连续0时需要注意索引回退（i--）
- 面试要求在原数组操作，但实际工作中更推荐创建新数组
- 不要盲目相信网上的代码，要独立思考算法的真实复杂度
- 编写完整的单元测试能在面试中脱颖而出

**后续优化：**
视频提到这个算法基本不可用，后续会介绍更优的解决方案。