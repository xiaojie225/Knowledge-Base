# 链表实现队列 - 代码演示和单元测试

## 目录

- [链表节点类型定义](#链表节点类型定义)
- [MyQueue 类的实现](#myqueue-类的实现)
- [add 方法 - 入队操作](#add-方法---入队操作)
- [delete 方法 - 出队操作](#delete-方法---出队操作)
- [length 方法 - 获取长度](#length-方法---获取长度)
- [功能测试](#功能测试)
- [单元测试](#单元测试)
- [AI 总结](#ai-总结)

---

## 链表节点类型定义

创建新文件 `linkWithList`，用于实现基于链表的队列数据结构。

首先定义链表节点的类型结构：

```typescript
type ListNode = {
  value: number;
  next: ListNode | null;
}
```

**关键说明**：
- `value` 使用 `number` 类型（也可以使用泛型）
- `next` 可以是下一个 `ListNode` 节点或 `null`
- `next` 后面加问号 `next?` 等同于 `next: ListNode | undefined`
- 更规范的写法是明确使用 `ListNode | null`

**两种初始化方式示例**：
```typescript
// 方式1：next 为 undefined
const node1 = { value: 100, next: undefined };

// 方式2：next 为 null
const node2 = { value: 100, next: null };
```

---

## MyQueue 类的实现

使用 `class` 关键字定义队列类：

```typescript
export class MyQueue {
  // 私有属性
  private head: ListNode | null;  // 队首指针
  private tail: ListNode | null;  // 队尾指针
  private length: number = 0;     // 队列长度
  
  // 公共方法
  add(n: number): void { }        // 入队
  delete(): number | null { }     // 出队
  get length(): number { }        // 获取长度
}
```

**设计要点**：
1. **头尾指针**：`head` 和 `tail` 是实现队列的关键
   - `head`：指向队首，用于出队
   - `tail`：指向队尾，用于入队
2. **私有属性**：使用 `private` 关键字，仅供内部使用
3. **长度单独存储**：不能通过遍历链表获取长度，时间复杂度太高（O(n)），必须用变量记录

---

## add 方法 - 入队操作

**核心原则**：队列必须在 `tail` 位置入队。

```typescript
add(n: number): void {
  // 1. 创建新节点
  const newNode: ListNode = {
    value: n,
    next: null  // 队尾的 next 肯定为 null
  };
  
  // 2. 处理 tail
  const tailNode = this.tail;
  if (tailNode) {
    // 如果 tail 存在，让当前尾节点的 next 指向新节点
    tailNode.next = newNode;
  }
  
  // 3. 更新 tail 指针
  this.tail = newNode;
  
  // 4. 处理 head（首次插入时）
  if (this.head === null) {
    this.head = newNode;
  }
  
  // 5. 记录长度
  this.length++;
}
```

**逻辑详解**：

**情况1：队列为空**
- `head` 和 `tail` 都是 `null`
- 需要同时让 `head` 和 `tail` 指向新节点
- 因为只有一个元素时，头尾是同一个节点

**情况2：队列非空**
```
原状态：head -> [节点X] -> tail
操作步骤：
1. 取出当前 tail 节点（节点X）
2. 让节点X的 next 指向新节点
3. 更新 tail 指向新节点

结果：head -> [节点X] -> [新节点] <- tail
```

---

## delete 方法 - 出队操作

**核心原则**：队列必须在 `head` 位置出队（先进先出）。

```typescript
delete(): number | null {
  // 1. 获取头节点
  const headNode = this.head;
  
  // 2. 异常情况判断
  if (headNode === null) {
    return null;
  }
  if (this.length <= 0) {
    return null;
  }
  
  // 3. 取出头节点的值
  const value = headNode.value;
  
  // 4. 更新 head 指针（关键步骤）
  this.head = headNode.next;
  
  // 5. 记录长度
  this.length--;
  
  // 6. 返回值
  return value;
}
```

**关键步骤详解**：

**步骤1-2：边界检查**
- 如果 `head` 为 `null`，说明队列为空，返回 `null`
- 如果 `length <= 0`，也说明队列为空

**步骤3：取值**
- 节点的 `value` 才是真正的数据
- 不能直接返回节点对象

**步骤4：更新 head（最重要）**
```
原状态：head -> [节点A] -> [节点B] -> [节点C]
操作：this.head = headNode.next
结果：head -> [节点B] -> [节点C]
```
这一步相当于删除了节点A，让 head 指向下一个节点。

---

## length 方法 - 获取长度

使用 `get` 关键字，可以像访问属性一样调用：

```typescript
get length(): number {
  return this.length;
}
```

**使用方式**：
```typescript
const q = new MyQueue();
console.log(q.length);  // 不需要加括号，像属性一样访问
```

**重要注释**：
```typescript
// 长度要单独存储
// 不能遍历链表来获取
// 否则时间复杂度太高（O(n)）
```

---

## 功能测试

```typescript
const q = new MyQueue();

// 测试入队
q.add(100);
q.add(200);
q.add(300);
console.log('length:', q.length);  // 输出: 3

// 测试出队
console.log(q.delete());  // 输出: 100（先进先出）
console.log('length:', q.length);  // 输出: 2

console.log(q.delete());  // 输出: 200
console.log('length:', q.length);  // 输出: 1

console.log(q.delete());  // 输出: 300
console.log('length:', q.length);  // 输出: 0

console.log(q.delete());  // 输出: null（队列为空）
console.log('length:', q.length);  // 输出: 0
```

**测试结果符合预期**：
- 长度从 3 递减到 0
- 出队顺序为 100 → 200 → 300（先进先出）
- 队列为空时返回 `null`

---

## 单元测试

创建测试文件 `ways-list.test.ts`：

```typescript
import { MyQueue } from './linkWithList';

describe('链表实现队列', () => {
  
  // 测试用例1：add 和 length
  test('add and length', () => {
    const q = new MyQueue();
    
    expect(q.length).toBe(0);  // 初始长度为0
    
    q.add(100);
    q.add(200);
    q.add(300);
    
    expect(q.length).toBe(3);  // 添加3个元素后长度为3
  });
  
  // 测试用例2：delete
  test('delete', () => {
    const q = new MyQueue();
    
    // 空队列删除
    expect(q.delete()).toBeNull();
    
    // 添加元素
    q.add(100);
    q.add(200);
    q.add(300);
    
    // 测试删除
    expect(q.delete()).toBe(100);  // 第1次删除
    expect(q.delete()).toBe(200);  // 第2次删除
    expect(q.delete()).toBe(300);  // 第3次删除
    expect(q.delete()).toBeNull(); // 第4次删除（队列已空）
  });
  
});
```

**测试说明**：
- 使用 `toBe()` 断言数值类型
- 使用 `toBeNull()` 断言空值
- 测试覆盖边界情况（空队列）和正常操作

**执行测试**：
```bash
npm test
```

**测试通过**，说明代码逻辑正确。

---

## 单元测试的重要性

**面试优势**：
- 绝大部分同学在面试算法题时没有单元测试思维
- 如果能展示单元测试能力，会有非常大的优势
- 面试时没有这个习惯，工作中更不可能有

**关键观点**：
- 逻辑搞明白后，测试代码并不麻烦
- 单元测试思维能显著提升代码质量
- 养成写测试的习惯对职业发展很重要

---

## AI 总结

本视频详细讲解了如何使用链表实现队列数据结构，并进行了完整的单元测试。

**核心要点**：

1\. **设计原则**：
   - 必须有 `head` 和 `tail` 两个指针
   - 从 `tail` 入队，从 `head` 出队
   - 长度单独存储，不能遍历链表计算

2\. **关键操作**：
   - **入队**：在 `tail` 位置添加，更新 `tail` 指针；首次插入时需同时更新 `head`
   - **出队**：从 `head` 位置删除，更新 `head` 指针为 `head.next`
   - **获取长度**：直接返回 `length` 属性（O(1) 时间复杂度）

3\. **边界处理**：
   - 队列为空时的特殊处理
   - 只有一个元素时 `head` 和 `tail` 指向同一节点
   - 删除操作需判断队列是否为空

4\. **测试实践**：
   - 功能测试验证基本操作
   - 单元测试覆盖边界情况
   - 单元测试思维在面试和工作中都很重要

通过链表实现队列，入队和出队的时间复杂度都是 O(1)，相比数组实现效率更高（数组的 `shift` 操作是 O(n)）。