# 获取字符串中连续最多的字符以及次数 - 使用嵌套循环

## 目录

- [问题描述](#问题描述)
- [解题思路](#解题思路)
- [时间复杂度分析](#时间复杂度分析)
- [跳步机制详解](#跳步机制详解)
- [代码实现](#代码实现)
- [功能测试](#功能测试)
- [单元测试](#单元测试)
- [AI 总结](#ai-总结)

## 问题描述

求字符串中连续最多的字符及其出现次数。

**示例输入**：`"aaabbbccccddeeee"`

**示例输出**：字符 `c` 或 `e`，连续出现 4 次

这是一道常见的面试题，在网上和面经中经常出现。

## 解题思路

基本思路是使用嵌套循环：

1. 外层循环遍历字符串的每个字符
2. 内层循环计算当前字符的连续出现次数
3. 记录过程中只保留最大的连续次数
4. 忽略较小的连续次数

## 时间复杂度分析

虽然使用了嵌套循环，但时间复杂度并不是 $O(n^2)$，而是 **$O(n)$**。

原因在于：**跳步机制**

## 跳步机制详解

以字符串 `"aaabbcccd"` 为例：

**传统嵌套循环**：
- `i` 指向第 1 个 `a`，`j` 遍历后续字符
- `i` 指向第 2 个 `a`，`j` 遍历后续字符
- `i` 指向第 3 个 `a`，`j` 遍历后续字符
- 依此类推...

**带跳步的嵌套循环**：
- `i` 指向第 1 个 `a`
- `j` 从 `i` 开始向后遍历，直到遇到不同字符 `b`
- 计算 `a` 连续出现 3 次
- **关键**：`i` 直接跳到 `b` 的位置（跳过已经处理的 `a`）
- `i` 指向第 1 个 `b`
- `j` 从 `i` 开始向后遍历，直到遇到不同字符 `c`
- 计算 `b` 连续出现 2 次
- `i` 直接跳到 `c` 的位置
- 依此类推...

**跳步效果**：
- `i` 的移动路径：第 1 个 `a` → 第 1 个 `b` → 第 1 个 `c` → 第 1 个 `d`
- `j` 的移动路径：遍历每个字符一次
- 总操作次数：`i` 的跳步次数 + `j` 的遍历次数 = 字符串长度 `n`
- 因此时间复杂度为 $O(n)$

## 代码实现

### 接口定义

```typescript
interface IResult {
  char: string;
  length: number;
}
```

### 核心函数

```typescript
export function findContinuousChar1(str: string): IResult {
  // 初始化结果
  const result: IResult = {
    char: '',
    length: 0
  };

  // 处理空字符串
  const length = str.length;
  if (length === 0) return result;

  // 临时变量，记录当前连续字符的长度
  let tempLength = 0;

  // 外层循环：遍历字符串
  for (let i = 0; i < length; i++) {
    tempLength = 0; // 重置临时长度

    // 内层循环：从 i 开始计算连续字符
    for (let j = i; j < length; j++) {
      if (str[i] === str[j]) {
        // 字符相等，累加长度
        tempLength++;
      }

      // 不相等或到达最后一个元素时，判断最大值
      if (str[i] !== str[j] || j === length - 1) {
        if (tempLength > result.length) {
          // 更新结果
          result.char = str[i];
          result.length = tempLength;
        }

        // 跳步：i 跳到 j 的位置
        if (i < length - 1) {
          i = j - 1; // -1 是因为外层循环会 i++
        }

        break; // 跳出内层循环
      }
    }
  }

  return result;
}
```

### 关键点说明

1. **内层循环从 `i` 开始**：`for (let j = i; j < length; j++)`，不需要从头开始
2. **跳步实现**：`i = j - 1`，将 `i` 跳到下一个不同字符的位置
3. **判断条件**：不相等或到达最后一个元素时，进行最大值判断
4. **结果更新**：只有当 `tempLength > result.length` 时才更新结果

## 功能测试

```typescript
const str = 'aabbccccddeeee';
console.log(findContinuousChar1(str));
// 输出: { char: 'c', length: 4 } 或 { char: 'e', length: 4 }
```

## 单元测试

```typescript
describe('连续字符和长度', () => {
  it('正常情况', () => {
    const str = 'aabbccccddeeee';
    const result = findContinuousChar1(str);
    expect(result).toEqual({ char: 'c', length: 4 });
  });

  it('空字符串', () => {
    const str = '';
    const result = findContinuousChar1(str);
    expect(result).toEqual({ char: '', length: 0 });
  });

  it('无连续字符', () => {
    const str = 'abc';
    const result = findContinuousChar1(str);
    expect(result).toEqual({ char: 'a', length: 1 });
  });

  it('全部都是连续字符', () => {
    const str = 'aaa';
    const result = findContinuousChar1(str);
    expect(result).toEqual({ char: 'a', length: 3 });
  });
});
```

### 测试用例说明

1. **正常情况**：包含多个连续字符段，验证能找到最长的
2. **空字符串**：边界情况，返回空结果
3. **无连续字符**：每个字符都不同，返回第一个字符，长度为 1
4. **全部连续**：整个字符串都是同一字符

## AI 总结

本视频讲解了如何使用嵌套循环求解字符串中连续最多的字符及其次数。核心要点：

1. **算法思路**：外层循环遍历字符，内层循环计算连续次数
2. **时间复杂度**：虽然是嵌套循环，但通过跳步机制实现了 $O(n)$ 的时间复杂度，而非 $O(n^2)$
3. **跳步机制**：处理完一段连续字符后，`i` 直接跳到下一个不同字符的位置，避免重复遍历
4. **实现细节**：内层循环从 `i` 开始，判断条件包括字符不相等或到达末尾，跳步通过 `i = j - 1` 实现
5. **测试覆盖**：包括正常情况、空字符串、无连续字符、全部连续字符等边界情况

这道题是常见的面试题，理解跳步机制是关键，不要被嵌套循环的表象迷惑，要仔细分析实际的遍历次数。