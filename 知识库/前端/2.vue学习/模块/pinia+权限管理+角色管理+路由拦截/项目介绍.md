 Vue 3 设备管理系统开发文档

  项目概述

  这是一个基于 Vue 3 的设备管理系统，实现了基于角色的访问控制（RBAC），使用 Vite
  构建。项目展示了用户认证、角色管理和基于路由的权限控制的完整实现。

  项目结构分析

  device-management/
  ├── src/
  │   ├── components/        # 可重用的 Vue 组件
  │   ├── stores/           # Pinia 状态管理
  │   ├── router/           # Vue Router 配置
  │   ├── views/            # 页面级组件
  │   ├── assets/           # 静态资源
  │   ├── App.vue           # 根组件
  │   ├── main.js           # 应用程序入口点
  │   └── style.css         # 全局样式
  ├── public/               # 公共资源
  └── dist/                 # 构建输出

  应用程序运行流程

  1. 应用启动流程

  main.js → App.vue → 路由初始化 → 权限检查 → 页面渲染

  详细流程：

  1. main.js 入口点
    - 导入 Vue 3 和 createApp 函数
    - 导入 Element Plus UI 库
    - 导入 Pinia 状态管理
    - 导入 Vue Router 路由管理
    - 导入根组件 App.vue
    - 创建 Vue 应用实例
    - 注册全局插件（Element Plus、Pinia、Router）
    - 挂载应用到 DOM
  2. App.vue 根组件
    - 提供应用的基本布局结构
    - 渲染路由视图 <router-view>
    - 可能包含全局导航栏和侧边栏
  3. 路由初始化
    - 加载路由配置
    - 设置路由守卫
    - 执行权限验证
  4. 权限检查
    - 检查用户是否已认证
    - 验证用户角色权限
    - 重定向到适当的页面
  5. 页面渲染
    - 根据路由配置渲染对应组件
    - 应用组件级权限控制

  2. 认证和授权流程

  用户登录 → 用户验证 → Token 存储 → 状态更新 → 路由访问

  详细流程：

  1. 用户登录
    - 用户在登录页面输入凭据
    - 调用用户 store 的 login 方法
    - 发送认证请求到后端（模拟）
  2. 用户验证
    - 验证用户名和密码
    - 生成认证 token
    - 确定用户角色
  3. Token 存储
    - 将 token 存储到 localStorage
    - 更新用户状态
  4. 状态更新
    - 更新 Pinia store 中的用户信息
    - 触发响应式更新
  5. 路由访问
    - 路由守卫检查用户认证状态
    - 验证用户角色权限
    - 允许或拒绝访问

  核心文件分析

  1. main.js - 应用程序入口点

  import { createApp } from 'vue'
  import { createPinia } from 'pinia'
  import ElementPlus from 'element-plus'
  import 'element-plus/dist/index.css'
  import router from './router'
  import App from './App.vue'
  import './style.css'

  const app = createApp(App)

  app.use(createPinia())
  app.use(router)
  app.use(ElementPlus)

  app.mount('#app')

  函数分析：

  - createApp(App): 创建 Vue 应用实例，接收根组件 App.vue 作为参数
    - 作用：初始化 Vue 应用程序
    - 参数：App.vue 组件对象
    - 返回值：Vue 应用实例
  - app.use(createPinia()): 注册 Pinia 状态管理插件
    - 作用：启用全局状态管理
    - 参数：Pinia 实例
    - 为什么需要：为了在组件中使用 useStore() 访问状态
  - app.use(router): 注册 Vue Router 插件
    - 作用：启用路由功能
    - 参数：路由实例
    - 为什么需要：为了使用 <router-view> 和路由导航
  - app.use(ElementPlus): 注册 Element Plus UI 库
    - 作用：启用 UI 组件库
    - 参数：ElementPlus 实例
    - 为什么需要：为了使用 Element Plus 的组件
  - app.mount('#app'): 挂载应用到 DOM
    - 作用：将 Vue 应用挂载到 HTML 元素
    - 参数：DOM 选择器字符串
    - 为什么需要：让 Vue 应用在浏览器中运行

  2. router/index.js - 路由配置

  import { createRouter, createWebHistory } from 'vue-router'
  import { useUserStore } from '../stores/user'

  const router = createRouter({
    history: createWebHistory(),
    routes: [
      {
        path: '/',
        redirect: '/dashboard'
      },
      {
        path: '/login',
        name: 'Login',
        component: () => import('../views/Login.vue'),
        meta: { requiresAuth: false }
      },
      {
        path: '/dashboard',
        name: 'Dashboard',
        component: () => import('../views/Dashboard.vue'),
        meta: { requiresAuth: true, roles: ['admin', 'user'] }
      },
      {
        path: '/device-management',
        name: 'DeviceManagement',
        component: () => import('../views/DeviceManagement.vue'),
        meta: { requiresAuth: true, roles: ['admin'] }
      }
    ]
  })

  router.beforeEach((to, from, next) => {
    const userStore = useUserStore()

    if (to.meta.requiresAuth && !userStore.isLoggedIn) {
      next('/login')
    } else if (to.path === '/login' && userStore.isLoggedIn) {
      next('/dashboard')
    } else if (to.meta.roles && !to.meta.roles.includes(userStore.role)) {
      next('/dashboard')
    } else {
      next()
    }
  })

  export default router

  函数分析：

  - createRouter({ history, routes }): 创建路由实例
    - 作用：初始化 Vue Router
    - 参数：配置对象（历史记录模式、路由配置）
    - 返回值：路由实例
  - createWebHistory(): 创建 HTML5 历史记录模式
    - 作用：启用基于浏览器历史记录的路由
    - 参数：无
    - 返回值：历史记录实例
    - 为什么使用：提供更友好的 URL（无 # 号）
  - router.beforeEach((to, from, next) => {}): 全局路由守卫
    - 作用：在每次路由跳转前执行权限检查
    - 参数：
        - to: 即将进入的目标路由
      - from: 当前离开的路由
      - next: 必须调用的函数，用于控制导航
    - 权限检查逻辑：
        i. 检查路由是否需要认证 (requiresAuth)
      ii. 检查用户是否已登录 (isLoggedIn)
      iii. 检查用户角色权限 (roles)
      iv. 根据检查结果调用 next() 进行重定向或放行

  3. stores/user.js - 用户状态管理

  import { defineStore } from 'pinia'
  import { ref, computed } from 'vue'

  export const useUserStore = defineStore('user', () => {
    const username = ref('')
    const role = ref('')
    const token = ref('')

    const isLoggedIn = computed(() => !!token.value)
    const isAdmin = computed(() => role.value === 'admin')

    async function login(credentials) {
      // 模拟登录逻辑
      if (credentials.username === 'admin' && credentials.password === 'admin') {
        username.value = 'admin'
        role.value = 'admin'
        token.value = 'admin-token'
        localStorage.setItem('token', token.value)
        localStorage.setItem('username', username.value)
        localStorage.setItem('role', role.value)
        return { success: true }
      } else if (credentials.username === 'user' && credentials.password === 'user') {
        username.value = 'user'
        role.value = 'user'
        token.value = 'user-token'
        localStorage.setItem('token', token.value)
        localStorage.setItem('username', username.value)
        localStorage.setItem('role', role.value)
        return { success: true }
      } else {
        return { success: false, message: '用户名或密码错误' }
      }
    }

    function logout() {
      username.value = ''
      role.value = ''
      token.value = ''
      localStorage.removeItem('token')
      localStorage.removeItem('username')
      localStorage.removeItem('role')
    }

    return { username, role, token, isLoggedIn, isAdmin, login, logout }
  })

  函数分析：

  - defineStore('user', () => {}): 定义 Pinia store
    - 作用：创建用户状态管理 store
    - 参数：store 名称和设置函数
    - 返回值：store 函数
  - ref(''): 创建响应式引用
    - 作用：创建响应式数据
    - 参数：初始值
    - 返回值：响应式引用对象
    - 为什么使用：为了在状态变化时自动更新 UI
  - computed(() => !!token.value): 创建计算属性
    - 作用：基于其他响应式数据计算值
    - 参数：计算函数
    - 返回值：计算属性对象
    - 为什么使用：isLoggedIn 自动根据 token 状态更新
  - async function login(credentials): 异步登录函数
    - 作用：处理用户登录逻辑
    - 参数：用户凭据对象
    - 返回值：Promise，解析为登录结果
    - 功能：
        i. 验证用户凭据
      ii. 更新 store 状态
      iii. 持久化数据到 localStorage
      iv. 返回登录结果
  - function logout(): 登出函数
    - 作用：处理用户登出逻辑
    - 参数：无
    - 返回值：无
    - 功能：
        i. 清空 store 状态
      ii. 清除 localStorage 数据

  4. views/Login.vue - 登录组件

  <template>
    <div class="login-container">
      <div class="login-form">
        <h2>设备管理系统</h2>
        <el-form :model="form" :rules="rules" ref="formRef">
          <el-form-item prop="username">
            <el-input v-model="form.username" placeholder="用户名" />
          </el-form-item>
          <el-form-item prop="password">
            <el-input v-model="form.password" type="password" placeholder="密码" />
          </el-form-item>
          <el-form-item>
            <el-button type="primary" @click="handleLogin" :loading="loading">登录</el-button>
          </el-form-item>
        </el-form>
      </div>
    </div>
  </template>

  <script setup>
  import { ref, reactive } from 'vue'
  import { useRouter } from 'vue-router'
  import { useUserStore } from '../stores/user'
  import { ElMessage } from 'element-plus'

  const router = useRouter()
  const userStore = useUserStore()
  const formRef = ref()
  const loading = ref(false)

  const form = reactive({
    username: '',
    password: ''
  })

  const rules = {
    username: [
      { required: true, message: '请输入用户名', trigger: 'blur' }
    ],
    password: [
      { required: true, message: '请输入密码', trigger: 'blur' }
    ]
  }

  async function handleLogin() {
    if (!formRef.value) return

    try {
      await formRef.value.validate()
      loading.value = true

      const result = await userStore.login(form)

      if (result.success) {
        ElMessage.success('登录成功')
        router.push('/dashboard')
      } else {
        ElMessage.error(result.message || '登录失败')
      }
    } catch (error) {
      ElMessage.error('表单验证失败')
    } finally {
      loading.value = false
    }
  }
  </script>

  函数分析：

  - useRouter(): 获取路由实例
    - 作用：在组件中访问路由功能
    - 参数：无
    - 返回值：路由实例对象
    - 为什么使用：为了进行页面导航
  - useUserStore(): 获取用户 store
    - 作用：在组件中访问用户状态
    - 参数：无
    - 返回值：用户 store 实例
    - 为什么使用：为了调用登录方法和获取用户状态
  - ref(): 创建响应式引用
    - 作用：创建响应式数据
    - 参数：初始值
    - 返回值：响应式引用对象
    - 使用场景：表单引用、加载状态
  - reactive({}): 创建响应式对象
    - 作用：创建响应式对象
    - 参数：初始对象
    - 返回值：响应式代理对象
    - 为什么使用：为了表单数据的响应式更新
  - async function handleLogin(): 处理登录函数
    - 作用：处理用户登录操作
    - 参数：无
    - 返回值：Promise
    - 功能：
        i. 表单验证
      ii. 调用 store 登录方法
      iii. 根据结果显示消息
      iv. 成功后跳转到仪表板

  5. views/Dashboard.vue - 仪表板组件

  <template>
    <div class="dashboard-container">
      <div class="dashboard-header">
        <h1>仪表板</h1>
        <div class="user-info">
          <span>欢迎，{{ userStore.username }}</span>
          <el-button type="danger" @click="handleLogout">退出登录</el-button>
        </div>
      </div>

      <div class="dashboard-content">
        <div class="stats-cards">
          <el-card class="stat-card">
            <div class="stat-content">
              <h3>设备总数</h3>
              <p class="stat-number">42</p>
            </div>
          </el-card>

          <el-card class="stat-card">
            <div class="stat-content">
              <h3>在线设备</h3>
              <p class="stat-number">38</p>
            </div>
          </el-card>

          <el-card class="stat-card">
            <div class="stat-content">
              <h3>离线设备</h3>
              <p class="stat-number">4</p>
            </div>
          </el-card>
        </div>

        <div class="quick-actions" v-if="userStore.isAdmin">
          <h2>快速操作</h2>
          <el-button type="primary" @click="$router.push('/device-management')">
            设备管理
          </el-button>
        </div>
      </div>
    </div>
  </template>

  <script setup>
  import { useRouter } from 'vue-router'
  import { useUserStore } from '../stores/user'
  import { ElMessage } from 'element-plus'

  const router = useRouter()
  const userStore = useUserStore()

  function handleLogout() {
    userStore.logout()
    ElMessage.success('退出登录成功')
    router.push('/login')
  }
  </script>

  函数分析：

  - handleLogout(): 处理登出函数
    - 作用：处理用户登出操作
    - 参数：无
    - 返回值：无
    - 功能：
        i. 调用 store 登出方法
      ii. 显示成功消息
      iii. 跳转到登录页面
  - $router.push('/device-management'): 路由跳转
    - 作用：导航到指定路由
    - 参数：目标路径
    - 返回值：Promise
    - 为什么使用：为了页面间导航

  6. views/DeviceManagement.vue - 设备管理组件

  <template>
    <div class="device-management-container">
      <div class="page-header">
        <h1>设备管理</h1>
        <el-button type="primary" @click="showAddDialog = true">
          添加设备
        </el-button>
      </div>

      <div class="device-table">
        <el-table :data="devices" style="width: 100%">
          <el-table-column prop="id" label="设备ID" width="100" />
          <el-table-column prop="name" label="设备名称" width="200" />
          <el-table-column prop="status" label="状态" width="100">
            <template #default="{ row }">
              <el-tag :type="row.status === 'online' ? 'success' : 'danger'">
                {{ row.status === 'online' ? '在线' : '离线' }}
              </el-tag>
            </template>
          </el-table-column>
          <el-table-column prop="location" label="位置" width="150" />
          <el-table-column prop="lastUpdate" label="最后更新" width="180" />
          <el-table-column label="操作">
            <template #default="{ row }">
              <el-button size="small" @click="editDevice(row)">编辑</el-button>
              <el-button size="small" type="danger" @click="deleteDevice(row)">删除</el-button>
            </template>
          </el-table-column>
        </el-table>
      </div>

      <!-- 添加设备对话框 -->
      <el-dialog v-model="showAddDialog" title="添加设备" width="500px">
        <el-form :model="newDevice" label-width="80px">
          <el-form-item label="设备名称">
            <el-input v-model="newDevice.name" />
          </el-form-item>
          <el-form-item label="位置">
            <el-input v-model="newDevice.location" />
          </el-form-item>
        </el-form>
        <template #footer>
          <el-button @click="showAddDialog = false">取消</el-button>
          <el-button type="primary" @click="addDevice">确定</el-button>
        </template>
      </el-dialog>
    </div>
  </template>

  <script setup>
  import { ref, reactive, onMounted } from 'vue'
  import { ElMessage, ElMessageBox } from 'element-plus'

  const devices = ref([
    {
      id: 1,
      name: '设备001',
      status: 'online',
      location: '办公室A',
      lastUpdate: '2024-01-15 10:30:00'
    },
    {
      id: 2,
      name: '设备002',
      status: 'offline',
      location: '办公室B',
      lastUpdate: '2024-01-15 09:15:00'
    }
  ])

  const showAddDialog = ref(false)
  const newDevice = reactive({
    name: '',
    location: ''
  })

  function addDevice() {
    if (!newDevice.name || !newDevice.location) {
      ElMessage.warning('请填写完整信息')
      return
    }

    const device = {
      id: devices.value.length + 1,
      name: newDevice.name,
      status: 'online',
      location: newDevice.location,
      lastUpdate: new Date().toLocaleString()
    }

    devices.value.push(device)
    showAddDialog.value = false
    newDevice.name = ''
    newDevice.location = ''
    ElMessage.success('设备添加成功')
  }

  function editDevice(device) {
    ElMessage.info(`编辑设备: ${device.name}`)
  }

  function deleteDevice(device) {
    ElMessageBox.confirm(
      `确定要删除设备 "${device.name}" 吗？`,
      '确认删除',
      {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }
    ).then(() => {
      const index = devices.value.findIndex(d => d.id === device.id)
      if (index > -1) {
        devices.value.splice(index, 1)
        ElMessage.success('设备删除成功')
      }
    }).catch(() => {
      ElMessage.info('已取消删除')
    })
  }

  onMounted(() => {
    // 这里可以添加从后端获取设备数据的逻辑
  })
  </script>

  函数分析：

  - onMounted(() => {}): 生命周期钩子
    - 作用：组件挂载后执行
    - 参数：回调函数
    - 返回值：无
    - 为什么使用：为了在组件加载完成后执行初始化逻辑
  - addDevice(): 添加设备函数
    - 作用：添加新设备
    - 参数：无
    - 返回值：无
    - 功能：
        i. 验证表单数据
      ii. 创建设备对象
      iii. 添加到设备列表
      iv. 重置表单
      v. 显示成功消息
  - editDevice(device): 编辑设备函数
    - 作用：编辑设备信息
    - 参数：设备对象
    - 返回值：无
    - 功能：显示编辑提示（可扩展为编辑对话框）
  - deleteDevice(device): 删除设备函数
    - 作用：删除设备
    - 参数：设备对象
    - 返回值：无
    - 功能：
        i. 显示确认对话框
      ii. 确认后从列表中删除设备
      iii. 显示操作结果消息

  关键变量和概念分析

  1. 响应式数据系统

  ref() vs reactive()

  // ref() - 用于基本类型和对象引用
  const username = ref('')  // 字符串
  const loading = ref(false) // 布尔值
  const devices = ref([])   // 数组

  // reactive() - 用于对象
  const form = reactive({
    username: '',
    password: ''
  })

  作用：
  - ref(): 创建包装对象的响应式引用，通过 .value 访问
  - reactive(): 创建响应式代理对象，直接访问属性

  为什么这样设计：
  - ref() 适合简单值和需要替换整个对象的情况
  - reactive() 适合复杂对象，保持引用不变

  2. 计算属性

  const isLoggedIn = computed(() => !!token.value)
  const isAdmin = computed(() => role.value === 'admin')

  作用：
  - 基于其他响应式数据计算派生值
  - 自动缓存，只有依赖项变化时才重新计算
  - 提供只读的数据访问

  为什么使用：
  - 避免重复计算
  - 保持数据的一致性
  - 提供更清晰的代码结构

  3. 路由元信息

  meta: { requiresAuth: true, roles: ['admin'] }

  作用：
  - 为路由添加自定义元数据
  - 用于权限控制和路由守卫
  - 可以包含任意自定义信息

  为什么使用：
  - 声明式的权限配置
  - 集中管理路由权限
  - 便于维护和扩展

  4. localStorage 持久化

  localStorage.setItem('token', token.value)
  localStorage.setItem('username', username.value)
  localStorage.setItem('role', role.value)

  作用：
  - 在浏览器中持久化存储数据
  - 页面刷新后数据不丢失
  - 支持跨会话的用户状态保持

  为什么使用：
  - 提供更好的用户体验
  - 减少重复登录
  - 简单的客户端存储方案

  使用指南

  1. 项目初始化

  # 创建项目
  npm create vite@latest device-management -- --template vue

  # 安装依赖
  cd device-management
  npm install

  # 安装额外依赖
  npm install pinia vue-router element-plus

  # 启动开发服务器
  npm run dev

  2. 快速集成到其他项目

  步骤 1：复制核心文件结构
  src/
  ├── stores/
  │   └── user.js          # 用户状态管理
  ├── router/
  │   └── index.js         # 路由配置
  ├── views/
  │   ├── Login.vue        # 登录页面
  │   ├── Dashboard.vue    # 仪表板
  │   └── DeviceManagement.vue # 设备管理
  ├── components/          # 自定义组件
  ├── App.vue             # 根组件
  └── main.js             # 入口文件

  步骤 2：安装必要依赖
  npm install pinia vue-router element-plus

  步骤 3：配置 main.js
  import { createApp } from 'vue'
  import { createPinia } from 'pinia'
  import ElementPlus from 'element-plus'
  import 'element-plus/dist/index.css'
  import router from './router'
  import App from './App.vue'

  const app = createApp(App)
  app.use(createPinia())
  app.use(router)
  app.use(ElementPlus)
  app.mount('#app')

  步骤 4：配置路由权限
  // router/index.js
  import { createRouter, createWebHistory } from 'vue-router'
  import { useUserStore } from '../stores/user'

  const routes = [
    // 复制路由配置
  ]

  const router = createRouter({
    history: createWebHistory(),
    routes
  })

  // 添加路由守卫
  router.beforeEach((to, from, next) => {
    const userStore = useUserStore()

    if (to.meta.requiresAuth && !userStore.isLoggedIn) {
      next('/login')
    } else if (to.path === '/login' && userStore.isLoggedIn) {
      next('/dashboard')
    } else if (to.meta.roles && !to.meta.roles.includes(userStore.role)) {
      next('/dashboard')
    } else {
      next()
    }
  })

  export default router

  步骤 5：配置用户状态管理
  // stores/user.js
  import { defineStore } from 'pinia'
  import { ref, computed } from 'vue'

  export const useUserStore = defineStore('user', () => {
    // 复制 store 配置
  })

  步骤 6：测试系统
  # 启动项目
  npm run dev

  # 测试登录
  # 管理员：admin/admin
  # 普通用户：user/user

  3. 自定义和扩展

  添加新角色：
  1. 在 stores/user.js 中添加新角色验证
  2. 在路由配置中添加新的角色权限
  3. 更新登录逻辑以支持新角色

  添加新页面：
  1. 在 views/ 目录创建新组件
  2. 在 router/index.js 中添加路由配置
  3. 设置适当的权限元信息

  修改 UI 主题：
  1. 在 main.js 中导入 Element Plus 主题
  2. 在 CSS 中覆盖默认样式
  3. 使用 CSS 变量自定义颜色

  常见问题解决

  1. 路由权限不生效

  问题： 用户可以访问未授权的页面

  解决方案：
  1. 检查路由配置中的 meta 字段
  2. 确认路由守卫逻辑正确
  3. 验证用户 store 中的角色状态

  2. 登录状态丢失

  问题： 页面刷新后用户需要重新登录

  解决方案：
  1. 确认 localStorage 数据正确存储
  2. 在应用启动时从 localStorage 恢复用户状态
  3. 检查 token 验证逻辑

  3. 样式不生效

  问题： Element Plus 组件样式未加载

  解决方案：
  1. 确认在 main.js 中导入了 CSS 文件
  2. 检查 CSS 文件路径是否正确
  3. 验证 Element Plus 是否正确注册

  总结

  这个 Vue 3 设备管理系统展示了现代前端开发的最佳实践：

  1. 架构清晰：使用 Vue 3 + Pinia + Vue Router + Element Plus 的技术栈
  2. 权限完善：实现了基于角色的访问控制
  3. 状态管理：使用 Pinia 进行集中式状态管理
  4. 路由保护：通过路由守卫实现页面级权限控制
  5. 用户体验：提供了完整的登录、登出、权限验证流程

  通过这个项目，可以学习到如何构建一个具有完整权限管理的前端应用，并且可以很容易地将其集成到其他项目中使用。