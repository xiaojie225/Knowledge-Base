
## uni.getImageInfo获取图片信息


*   **获取图片的原始宽度和高度**（通过 `uni.getImageInfo`）。
*   **将原始尺寸保存到组件的数据属性中**（`this.imageNaturalWidth` 和 `this.imageNaturalHeight`）。
*   **调用 `calculateDisplaySize()` 方法**，用于计算图片在容器中的显示尺寸。

```
    // 获取图片原始尺寸
    uni.getImageInfo({
        src: this.currentImagePath, // 图片路径
        success: (res) => {
            this.imageNaturalWidth = res.width;     // 原始宽度
            this.imageNaturalHeight = res.height;   // 原始高度
            console.log('图片原始尺寸:', res.width, res.height);
            
            // 计算图片在容器中的显示尺寸（等比例缩放，贴近边框）
            this.calculateDisplaySize();
        },
        fail: (error) => {
            console.error('获取图片信息失败:', error);
        }
    });
```
    




# 其他

## ` Watch深度监听`

### `全局事件监听使用`

```
// 在页面中监听蓝牙事件
uni.$on('deviceFound', (device) => {
    console.log('发现设备:', device);
});

uni.$on('userDeviceListChanged', (deviceList) => {
    this.deviceList = deviceList;
});

// 页面销毁时取消监听
onUnload() {
    uni.$off('deviceFound');
    uni.$off('userDeviceListChanged');
}
```

## `将批量大量数据 转换为响应式对象`

```
			app.globalData = new Vue({
			  data() {
				return {
				  lang: 'zh',
				  time: null,
				  bluetooth_state:0,
				  zim:null,
				  audio:true,
				  text_box:[],
				  text_box_left:[],
				  text_box_right:[],
				  send:0,
				  is_call:false,
				  Disconnect:false,
				  myToast(title, icon) {
				  	uni.showToast({
				  		title,
				  		icon
				  	})
				  }
				};
			  }
			});
```


## 父子组件通信

`<ShopItem :datalist="styleList" :itemstyle="itemStyle" :imgstyle="imgStyle" @event="onNav">` 
展示了一个典型的 Vue.js 或 Uni-app 组件使用场景，它传递了数据和样式，并监听了一个自定义事件。

**核心功能点：**

1.  **组件引用 (`<ShopItem>`):** 使用了一个名为 `ShopItem` 的自定义组件，表明了组件化开发的思想。
2.  **Props 数据传递 (`:` 绑定):**
    *   `:datalist="styleList"`：父组件向子组件传递一个数据列表。
    *   `:itemstyle="itemStyle"`：父组件向子组件传递单个项的样式配置。
    *   `:imgstyle="imgStyle"`：父组件向子组件传递图片元素的样式配置。
    这些都体现了父组件向子组件传递数据的能力。
3.  **自定义事件监听 (`@` 绑定):**
    *   `@event="onNav"`：父组件监听子组件发出的一个名为 `event` 的自定义事件，当此事件被触发时，父组件会执行 `onNav` 方法。这体现了子组件向父组件通信的能力。
4.  **插槽（评论部分暗示）:**
    *   `<!-- <u-icon name="arrow-right" color="#e4e4e4" slot-scope="{ scope }"></u-icon> -->`：虽然被注释掉，但 `slot-scope` 的存在强烈暗示 `ShopItem` 组件内部使用了**作用域插槽**，允许父组件在渲染子组件特定区域时，不仅提供自己的内容，还能访问子组件内部的数据。


*   **Props：** 父组件 -> 子组件传递数据和配置。
*   **Events (`$emit`)：** 子组件 -> 父组件报告状态变化或用户交互。
*   **Slots (尤其是 scoped slots)：** 父组件定制子组件内部的渲染内容，同时访问子组件内部的数据。这是实现高度灵活和可复用组件的关键。
*   **组件化思想：** 将复杂界面拆分为独立的、可复用的模块。
*   **动态绑定：** 使用 `:` 绑定 JavaScript 表达式到 HTML 属性。

---

## 跨组件通信


returnImage(imagePath) {
			    console.log('返回图片路径:', imagePath);
			    
			    // 获取当前页面栈
			    const pages = getCurrentPages();
				console.log(pages.length)
			    if (pages.length >= 2) {
			        const prevPage = pages[pages.length - 2]; // 上一个页面
			        // 将编辑后的图片信息存储到上一个页面的data中
			        prevPage.$vm.editedImage = {
			            path: imagePath,
			            hasEdits: this.hasEdits,
			            rotationAngle: this.rotationAngle
			        };
					console.log("++++2+",prevPage.editedImage)
			    }
			    
			    uni.showToast({
			        title: '编辑完成',
			        icon: 'success'
			    });
			    
			    // 返回上一页
			    setTimeout(() => {
			        uni.navigateBack();
			    }, 1000);
			}



* * *


*   `getCurrentPages()`  API，用于获取当前页面栈（即用户访问过的页面列表）。


### **获取上一个页面**

    const prevPage = pages[pages.length - 2]; // 上一个页面
    

*   `pages[pages.length - 2]` 获取的是当前页面栈中的倒数第二个页面，也就是上一个页面。

* * *

### **将编辑后的图片信息存储到上一个页面的 data 中**

    prevPage.$vm.editedImage = {
        path: imagePath,
        hasEdits: this.hasEdits,
        rotationAngle: this.rotationAngle
    };
    


*   `prevPage.$vm` 访问上一个页面实例的方法。
*   `editedImage` 是一个对象，包含以下属性：
    *   `path`: 图片路径。
    *   `hasEdits`: 是否有编辑（布尔值）。
    *   `rotationAngle`: 图片旋转角度。

### **提示信息**

    uni.showToast({
        title: '编辑完成',
        icon: 'success'
    });

*   使用 `uni.showToast` 显示一个提示信息，内容为“编辑完成”，图标为成功。

### **总结**

这段代码的作用是：

1.  在图片编辑完成后，将编辑后的图片信息（路径、是否有编辑、旋转角度）传递给上一个页面。
2.  显示一个提示信息，告知用户编辑已完成。
3.  延迟 1 秒后返回上一页。

* * *
