# 微信简单登录
## 🤔 理解确认

在看代码之前，我们先明确一个“分工”问题。在整个登录流程里，你觉得小程序（我们称之为**前端**）和我们自己的服务器（我们称之为**后端**）各自扮演了什么角色？谁更像是“申请人”，谁更像是“审批和发证的官员”？

## 💡 思路拆解

为了让你看得更清晰，我会把整个登录功能的代码实现，也拆解成和刚才故事对应的四个步骤：

1.  **第一步：创建“登录”按钮** (WXML & JS) - 用户能看到和点击的东西。
2.  **第二步：响应点击，调用“授权”窗口** (`wx.getUserProfile`) - 向用户请求授权。
3.  **第三步：发起“登录认证”核心请求** (`wx.login` + `wx.request`) - 用授权信息和`code`去换`token`。
4.  **第四步：登录成功后的“跳转”逻辑** (Callback & `wx.navigateBack`) - 引导用户到下一步。

## 📚 相关概念

在深入代码前，你需要理解一个小程序开发中的核心概念：**异步操作与回调函数 (Asynchronous & Callback)**。

*   **什么是异步？** 很多微信API（比如请求用户信息、发起网络请求）都不是立刻就能完成的，需要一点时间。小程序不会傻傻地卡在那里等待结果，而是会先去干别的事，这就是“异步”。
*   **什么是回调函数？** 为了处理异步操作的结果，我们会给这些API传递一个函数（通常放在 `success: function() {}` 里）。当API成功完成任务后，就会“回过头来调用”我们传给它的这个函数，并把结果作为参数给我们。

你可以把它想象成网上购物：你下单（调用API），然后关掉App干别的事（异步）。等快递到了（API成功返回），快递员给你打电话（执行`success`回调函数），并把包裹给你（返回结果数据）。

接下来，让我们一步步看代码。

---

## ✍️ 你的任务：理解并复用代码片段

### 第一步：创建登录按钮 (在 `login.wxml` 和 `login.js` 中)

这是用户交互的起点。

**可复用代码片段 1：**

```html
<!-- login.wxml 文件：这是页面的样子 -->
<!-- 
  open-type="getUserProfile" 是旧的用法，现在推荐用 @tap 事件
  我们将用 @tap="handleLogin" 来触发JS中的函数
-->
<button class="login-button" @tap="handleLogin">微信授权登录</button>
```

```javascript
// login.js 文件：这是页面的逻辑
Page({
  // 当用户点击上面那个按钮时，这个函数就会被触发
  handleLogin() {
    console.log("用户点击了登录按钮，准备请求授权...");
    // 在这里，我们将调用第二步的代码
    this.getUserProfile(); 
  }
});
```

**代码解释：**
*   `@tap="handleLogin"`：这是WXML的事件绑定语法，意思是“当这个按钮被点击（tap）时，就去调用`login.js`里的`handleLogin`函数”。
*   `Page({...})`：这是每个小程序页面的标准结构，所有的函数和数据都写在这个大括号里。

---

### 第二步：请求用户授权 (在 `login.js` 中)

用户点击按钮后，我们弹出授权窗口。

**可复用代码片段 2：**

```javascript
// login.js 文件
Page({
  // ... handleLogin 函数 ...

  getUserProfile() {
    let that = this; // 提前保存this,防止在回调函数中丢失
    wx.getUserProfile({
      desc: '用于完善您的会员资料', // 必须填写，告诉用户要干嘛
      success: (res) => {
        // 授权成功！res 对象里包含了用户的头像、昵称等信息
        console.log("用户授权成功，获取到的信息：", res);
      
        // 拿到用户信息后，立即进行最核心的第三步
        // 我们把 res 这个宝贵的用户信息传递过去
        getApp().loginToServer(res); 
      },
      fail: (err) => {
        // 授权失败
        console.error("用户拒绝授权：", err);
        wx.showToast({ title: '授权失败', icon: 'error' });
      }
    });
  }
});
```

**代码解释：**
*   `wx.getUserProfile({...})`：这就是调用微信授权弹窗的API。
*   `desc`: 必须声明获取信息的用途，这是微信的硬性规定，为了保护用户隐私。
*   `success: (res) => {}`：这就是一个**回调函数**。当用户点击“同意”后，这个函数就会被执行，`res`参数就是微信返回的用户信息对象。
*   `getApp().loginToServer(res)`：`getApp()`可以获取到`app.js`的实例。这里我们调用一个定义在`app.js`里的全局登录方法，并把用户信息`res`传给它。这样做的好处是，登录这种全局功能，写在`app.js`里更方便管理和复用。

---

### 第三步：核心！用 Code 换 Token (在 `app.js` 中)

这是最关键的一步，包含了两次异步请求的嵌套。

**可复用代码片段 3：**

```javascript
// app.js 文件
App({
  loginToServer(userInfoRes) {
    wx.showLoading({ title: '正在登录...' }); // 显示一个加载提示

    // 第1层：调用 wx.login 获取 code
    wx.login({
      success: (loginRes) => {
        // 获取 code 成功！loginRes.code 就是我们要的临时票据
        console.log("获取code成功：", loginRes.code);

        // 准备发送给后端的数据
        let postData = {
          code: loginRes.code,             // 临时登录凭证 code
          user_info: userInfoRes.rawData,  // 用户信息的原始JSON字符串
          // ... 其他加密数据，根据后端要求传递 ...
        };

        // 第2层：调用 wx.request 将 code 和用户信息发到我们自己的服务器
        wx.request({
          url: 'https://你的服务器域名/api/user/login', // 你的后端接口地址
          method: 'POST',
          data: postData,
          success: (serverRes) => {
            // 服务器成功返回数据
            if (serverRes.data.code === 1) { // 假设 code=1 代表成功
              console.log("登录成功，服务器返回的token:", serverRes.data.data.token);
              // 登录成功，把 token 和 user_id 存起来！
              wx.setStorageSync('token', serverRes.data.data.token);
              wx.setStorageSync('user_id', serverRes.data.data.user_id);

              // TODO: 在这里执行登录成功后的回调，比如跳转页面
              wx.navigateBack(); // 最简单的，直接返回上一页
            } else {
              // 服务器返回了业务错误，比如“账号被冻结”
              wx.showToast({ title: serverRes.data.msg, icon: 'none' });
            }
          },
          fail: (err) => {
            // 网络请求失败
            console.error("请求后端服务器失败：", err);
            wx.showToast({ title: '服务器开小差了...', icon: 'error' });
          },
          complete: () => {
            wx.hideLoading(); // 无论成功失败，都隐藏加载提示
          }
        });
      },
      fail: (err) => {
        console.error("wx.login 失败：", err);
        wx.showToast({ title: '微信登录失败', icon: 'error' });
        wx.hideLoading();
      }
    });
  }
});
```

**代码解释：**
*   这是一个典型的**回调地狱（Callback Hell）**：`wx.request` 嵌套在 `wx.login` 的 `success` 回调里。这是因为我们必须先拿到`code`，才能去请求自己的服务器。
*   `wx.login`：它的唯一使命就是从微信服务器换取 `code`。
*   `wx.request`：这是小程序里负责发送网络请求的API，就像浏览器里的 `ajax`。
*   `wx.setStorageSync('token', ...)`：这是将数据同步存入本地缓存。只要用户不清理小程序缓存，这个`token`就会一直存在手机里，下次打开小程序就可以用来验证登录状态。

---

这样，从用户点击到登录成功，再到数据本地化的全过程代码就都解释清楚了。你可以把这些片段收藏起来，它们基本构成了一个完整且通用的微信登录模块。


没问题！我们马上将这些高级概念转化为实际的代码。这部分代码会让你的登录功能从“能用”提升到“可靠”和“优雅”的水平。

# 微信优化登录
## 🤔 理解确认

在我们开始之前，我想确认一下你的想法：
1.  你认为，检查用户是否已登录的逻辑，应该放在哪个文件里最合适？是 `login.js` 页面，还是全局的 `app.js`？为什么？
2.  如果一个 `token` 过期了，我们应该怎么做？是直接弹框告诉用户“登录过期，请重新登录”，还是在用户无感知的情况下，悄悄地帮他换一个新的 `token`？你觉得哪种体验更好？

## 💡 思路拆解

我们将分三步来实现一个健壮的登录及请求流程：

1.  **启动时检查**：在 `app.js` 的 `onLaunch` 生命周期中，检查本地缓存（storage）里有没有 `token`。
2.  **封装统一请求函数**：创建一个通用的请求模块（比如放在 `utils/request.js`），以后小程序里所有的网络请求都走这个函数。这是实现“请求拦截器”的基础。
3.  **实现请求拦截器**：在这个统一的请求函数里，加入 `token` 处理逻辑：
    *   **请求前**：自动给每个请求的 `header` 里加上 `token`。
    *   **响应后**：检查服务器返回的状态码，如果发现是 `token` 过期（比如 `401`），就触发静默登录（重新获取 `token`），然后自动重新发送刚才失败的请求。

## 📚 相关概念

为了解决“回调地狱”问题，我们将引入现代 JavaScript 中处理异步操作的利器：**Promise** 和 **async/await**。

*   **Promise 是什么？** 它是一个“承诺”。当你调用一个异步函数时，它不会马上给你结果，而是先给你一个“承诺”（Promise对象）。你可以用 `.then()` 来指定“承诺”成功兑现后做什么，用 `.catch()` 来指定“承诺”失败后做什么。
    *   **类比**：就像你在咖啡店点单，店员不会让你干等着，而是给你一个取餐号（Promise）。你可以先去玩手机（做别的事），等叫到你的号（Promise成功），你再去取咖啡（执行`.then()`）。如果被告知咖啡豆没了（Promise失败），你就去处理这个意外情况（执行`.catch()`）。

*   **async/await 是什么？** 它是 `Promise` 的“语法糖”，让你可以用写同步代码的方式来写异步代码，看起来更清晰。
    *   `async` 用来声明一个函数是异步的。
    *   `await` 只能用在 `async` 函数里，它会“等待”一个 `Promise` 完成，并直接返回它的结果。它让代码从嵌套的 `.then()` 中解放出来，变成像剧本一样从上到下执行。

---

## ✍️ 你的任务：理解并实现健壮的登录检查与请求

### 第一步：在 `app.js` 中增加启动检查

**可复用代码片段 4：**

```javascript
// app.js
App({
  onLaunch() {
    // 小程序启动时，执行一次
    this.checkLoginStatus();
  },

  checkLoginStatus() {
    const token = wx.getStorageSync('token');
    if (token) {
      // 本地有 token，我们还需要验证这个 token 是否在服务器端依然有效
      // 这里可以发一个简单的请求给后端，比如 /api/user/check_token
      // 如果后端说有效，就更新用户信息
      console.log("本地存在token，需要验证其有效性");
      // this.globalData.isLoggedIn = true; // 示例：先假设它是有效的
    } else {
      // 本地没有 token，说明是新用户或用户清了缓存
      console.log("本地无token，用户未登录");
      // this.globalData.isLoggedIn = false;
    }
  },

  globalData: {
    // isLoggedIn: false // 可以用一个全局变量来标识登录状态
  }

  // ... loginToServer 函数 ...
})
```

**代码解释：**
*   `onLaunch()`：这是小程序的生命周期函数，当小程序初始化完成时，会触发一次。这是进行全局检查的最佳时机。
*   `wx.getStorageSync('token')`：从本地同步缓存中读取 `token`。如果用户之前登录过，这里就能读到值。
*   **关键点**：仅仅本地有 `token` 是不够的！因为这个 `token` 可能在服务器端已经因为超时、或者用户在其他设备登录而被判定为失效。所以最严谨的做法是再发一个请求去校验它的有效性。

---

### 第二步：封装统一请求函数 (Promise 版本)

在你的项目根目录下创建一个 `utils` 文件夹，再在里面创建一个 `request.js` 文件。

**可复用代码片段 5：**

```javascript
// utils/request.js
const BASE_URL = 'https://你的服务器域名/api';

const request = (options) => {
  return new Promise((resolve, reject) => {
    wx.request({
      url: BASE_URL + options.url,
      method: options.method || 'GET',
      data: options.data || {},
      header: {
        'Content-Type': 'application/json',
        // 在这里可以统一添加 token
        'Authorization': 'Bearer ' + wx.getStorageSync('token') 
      },
      success: (res) => {
        // 在这里实现拦截器逻辑
        if (res.statusCode === 200) {
          if (res.data.code === 1) { // code = 1 假设为业务成功
            resolve(res.data.data); // Promise 成功，并返回核心数据
          } else {
            wx.showToast({ title: res.data.msg, icon: 'none' });
            reject(res.data); // Promise 失败，返回错误信息
          }
        } else if (res.statusCode === 401) {
          // 401: Unauthorized，代表 token 失效
          console.error("Token 失效，需要重新登录");
          // TODO: 调用静默登录/刷新token，然后重发请求
          reject({ code: 401, msg: '登录已过期' });
        } else {
          // 其他 HTTP 错误
          wx.showToast({ title: '网络错误: ' + res.statusCode, icon: 'error' });
          reject({ code: res.statusCode, msg: '网络错误' });
        }
      },
      fail: (err) => {
        wx.showToast({ title: '请求失败', icon: 'error' });
        reject(err); // Promise 失败
      }
    });
  });
};

// 导出这个模块，让其他页面可以使用
module.exports = {
  request
}
```

**代码解释：**
*   `new Promise(...)`：我们将 `wx.request` 这个回调风格的 API 包装成了一个 `Promise`。
*   `resolve(res.data.data)`：当一切正常时，调用 `resolve`，这会让 `Promise` 的状态变为 "fulfilled"（成功），`.then()` 里的代码会被执行。
*   `reject(...)`：当发生任何错误时（业务错误、网络错误），调用 `reject`，`Promise` 状态变为 "rejected"（失败），`.catch()` 里的代码会被执行。
*   `'Authorization': 'Bearer ' + ...`：这是业界标准的 `JWT (JSON Web Token)` 认证方式，将 `token` 放在 `Authorization` 请求头里，并通常会带一个 `Bearer` 前缀。

---

### 第三步：在页面中优雅地使用封装好的请求

有了 `request.js`，我们来改造一下页面里的调用方式。

**可复用代码片段 6 (使用 async/await)：**

```javascript
// 在需要发起请求的页面的 js 文件中
// 1. 先在文件顶部引入我们封装的模块
const { request } = require('../../utils/request.js');

Page({
  async getMyOrderList() {
    try {
      wx.showLoading({ title: '加载中...' });
    
      // 2. 使用 async/await 调用
      const orderList = await request({
        url: '/order/list', // 只需要写相对路径
        method: 'GET',
        data: {
          page: 1,
          limit: 10
        }
      });
    
      // 能走到这里，说明请求一定是成功的，orderList 就是后端返回的核心数据
      console.log("获取到的订单列表:", orderList);
      this.setData({
        list: orderList
      });

    } catch (error) {
      // 如果 Promise 被 reject，代码会直接跳到 catch 块
      console.error("获取订单失败:", error);
      // 在 request 函数里已经弹过 toast 了，这里可以不用再弹
      if (error.code === 401) {
        // 如果是 token 过期，跳转到登录页
        wx.navigateTo({ url: '/pages/login/login' });
      }
    } finally {
      // 3. 无论成功失败，最后都执行
      wx.hideLoading();
    }
  }
})
```

**代码解释：**
*   `const { request } = require(...)`：通过 `require` 语法引入我们导出的模块。
*   `async getMyOrderList() {...}`：使用 `async` 关键字声明这是一个异步函数。
*   `const orderList = await request(...)`：`await` 关键字会暂停函数的执行，直到 `request` 这个 `Promise` 完成，然后把 `resolve` 出来的数据赋值给 `orderList`。代码看起来就像同步执行一样，非常干净！
*   `try...catch...finally`：这是处理 `async/await` 错误的经典结构。`try` 块里放可能出错的代码，一旦出错就跳到 `catch`，`finally` 里的代码总会被执行。

通过这三步，你的小程序就有了一套非常健壮和现代化的登录状态管理和网络请求机制。

## 🆘 需要帮助?

这部分内容比基础登录要复杂，你可能会有疑问：
*   关于 `Promise` 和 `async/await` 的概念还不是很清晰？
*   对于“静默登录/刷新 `token` 然后重发请求”这部分最复杂的逻辑，想知道具体如何实现？
*   `try...catch` 结构和 `.then().catch()` 有什么区别？

随时可以提出来，我们可以深入探讨任何一个细节！
