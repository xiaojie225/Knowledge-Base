# å¾®ä¿¡æ”¯ä»˜æŠ€æœ¯æ¶æ„æ·±åº¦è§£æ

## ğŸ“‘ æ–‡æ¡£ç›®å½•

1. [æ–‡æ¡£æ¦‚è¿°](#æ–‡æ¡£æ¦‚è¿°)
2. [å®Œæ•´äº¤æ˜“æµç¨‹è¯¦è§£](#å®Œæ•´äº¤æ˜“æµç¨‹è¯¦è§£)
   - [æ ‡å‡†æ”¯ä»˜æµç¨‹](#æ ‡å‡†æ”¯ä»˜æµç¨‹)
   - [å…³é”®èŠ‚ç‚¹åˆ†æ](#å…³é”®èŠ‚ç‚¹åˆ†æ)
   - [å¼‚å¸¸æµç¨‹å¤„ç†](#å¼‚å¸¸æµç¨‹å¤„ç†)
3. [ç­¾åç®—æ³•å®æˆ˜](#ç­¾åç®—æ³•å®æˆ˜)
   - [V2ç­¾åç®—æ³•ï¼ˆMD5/HMAC-SHA256ï¼‰](#v2ç­¾åç®—æ³•)
   - [V3ç­¾åç®—æ³•ï¼ˆSHA256-RSA2048ï¼‰](#v3ç­¾åç®—æ³•)
   - [ç­¾åéªŒè¯å®ç°](#ç­¾åéªŒè¯å®ç°)
   - [å¸¸è§ç­¾åé”™è¯¯æ’æŸ¥](#å¸¸è§ç­¾åé”™è¯¯æ’æŸ¥)
4. [è¯ä¹¦ä½“ç³»æ·±åº¦è§£æ](#è¯ä¹¦ä½“ç³»æ·±åº¦è§£æ)
   - [è¯ä¹¦ç±»å‹ä¸ä½œç”¨](#è¯ä¹¦ç±»å‹ä¸ä½œç”¨)
   - [è¯ä¹¦è·å–ä¸æ›´æ–°](#è¯ä¹¦è·å–ä¸æ›´æ–°)
   - [è¯ä¹¦ç®¡ç†è‡ªåŠ¨åŒ–](#è¯ä¹¦ç®¡ç†è‡ªåŠ¨åŒ–)
5. [æ•æ„Ÿä¿¡æ¯åŠ å¯†å®æˆ˜](#æ•æ„Ÿä¿¡æ¯åŠ å¯†å®æˆ˜)
   - [åŠ å¯†åœºæ™¯ä¸ç®—æ³•](#åŠ å¯†åœºæ™¯ä¸ç®—æ³•)
   - [åŠ å¯†å®ç°ä»£ç ](#åŠ å¯†å®ç°ä»£ç )
   - [è§£å¯†æµç¨‹](#è§£å¯†æµç¨‹)
6. [å›è°ƒæœºåˆ¶ä¸éªŒç­¾](#å›è°ƒæœºåˆ¶ä¸éªŒç­¾)
   - [å›è°ƒé€šçŸ¥æœºåˆ¶](#å›è°ƒé€šçŸ¥æœºåˆ¶)
   - [éªŒç­¾æµç¨‹å®ç°](#éªŒç­¾æµç¨‹å®ç°)
   - [å›è°ƒå¤„ç†æœ€ä½³å®è·µ](#å›è°ƒå¤„ç†æœ€ä½³å®è·µ)
   - [é‡è¯•æœºåˆ¶ä¸å¹‚ç­‰è®¾è®¡](#é‡è¯•æœºåˆ¶ä¸å¹‚ç­‰è®¾è®¡)
7. [å®‰å…¨æœºåˆ¶ç»¼åˆåº”ç”¨](#å®‰å…¨æœºåˆ¶ç»¼åˆåº”ç”¨)
   - [é˜²é‡æ”¾æ”»å‡»](#é˜²é‡æ”¾æ”»å‡»)
   - [é˜²ç¯¡æ”¹ä¿æŠ¤](#é˜²ç¯¡æ”¹ä¿æŠ¤)
   - [å¯†é’¥ç®¡ç†ç­–ç•¥](#å¯†é’¥ç®¡ç†ç­–ç•¥)
8. [åç»­æ–‡æ¡£å¯¼èˆª](#åç»­æ–‡æ¡£å¯¼èˆª)

---

## æ–‡æ¡£æ¦‚è¿°

**æ–‡æ¡£ç›®æ ‡**ï¼šæ·±å…¥ç†è§£å¾®ä¿¡æ”¯ä»˜çš„æŠ€æœ¯æ¶æ„ï¼ŒæŒæ¡ç­¾åç®—æ³•ã€è¯ä¹¦ç®¡ç†ã€åŠ å¯†è§£å¯†ç­‰æ ¸å¿ƒæŠ€æœ¯ï¼Œä¸ºå®é™…å¼€å‘å¥ å®šåšå®åŸºç¡€ã€‚

**é€‚ç”¨åœºæ™¯**ï¼š
- ç†è§£æ”¯ä»˜ç³»ç»Ÿçš„å®‰å…¨æœºåˆ¶
- è§£å†³å¼€å‘ä¸­çš„ç­¾å/éªŒç­¾é—®é¢˜
- å®ç°å›è°ƒå¤„ç†çš„æœ€ä½³å®è·µ
- å­¦ä¹ è¯ä¹¦ç®¡ç†è‡ªåŠ¨åŒ–æ–¹æ¡ˆ

**é˜…è¯»æ—¶é•¿**ï¼šçº¦ 30 åˆ†é’Ÿ

**å‰ç½®çŸ¥è¯†**ï¼šå»ºè®®å…ˆé˜…è¯»ã€Šæ–‡æ¡£1ï¼šå¾®ä¿¡æ”¯ä»˜å…¨æ™¯è®¤çŸ¥ä¸å‡†å¤‡å·¥ä½œã€‹

---

## å®Œæ•´äº¤æ˜“æµç¨‹è¯¦è§£

### æ ‡å‡†æ”¯ä»˜æµç¨‹

å¾®ä¿¡æ”¯ä»˜çš„å®Œæ•´æµç¨‹åŒ…å«7ä¸ªå…³é”®é˜¶æ®µï¼Œä¸‹é¢æˆ‘ä»¬é€šè¿‡è¯¦ç»†çš„æ—¶åºå›¾å’Œåˆ†æ­¥è§£ææ¥ç†è§£ï¼š

```mermaid
sequenceDiagram
    autonumber
    participant User as ğŸ‘¤ ç”¨æˆ·
    participant Frontend as ğŸ–¥ï¸ å‰ç«¯
    participant Backend as âš™ï¸ å•†æˆ·åç«¯
    participant WxPay as ğŸ’³ å¾®ä¿¡æ”¯ä»˜
    participant WxCallback as ğŸ“¢ å¾®ä¿¡å›è°ƒç³»ç»Ÿ
    participant Database as ğŸ’¾ æ•°æ®åº“

    rect rgb(230, 245, 255)
        Note over User,Database: é˜¶æ®µ1ï¼šè®¢å•åˆ›å»º
        User->>Frontend: é€‰æ‹©å•†å“ï¼Œç‚¹å‡»æ”¯ä»˜
        Frontend->>Backend: POST /api/order/create<br/>{å•†å“ID, æ•°é‡, é‡‘é¢}
        Backend->>Database: åˆ›å»ºè®¢å•è®°å½•<br/>çŠ¶æ€ï¼šå¾…æ”¯ä»˜
        Database-->>Backend: è®¢å•å·ï¼š2024102301234567
        Backend-->>Frontend: {orderId, amount}
    end

    rect rgb(255, 245, 230)
        Note over User,Database: é˜¶æ®µ2ï¼šç»Ÿä¸€ä¸‹å•
        Frontend->>Backend: POST /api/pay/prepare<br/>{orderId}
        Backend->>Backend: ç”Ÿæˆç­¾åå‚æ•°
        Backend->>WxPay: POST /v3/pay/transactions/jsapi<br/>{å•†æˆ·è®¢å•å·, é‡‘é¢, openid...}
        WxPay->>WxPay: éªŒç­¾+é£æ§æ£€æŸ¥
        WxPay-->>Backend: {prepay_id: wx20241023...}
        Backend->>Backend: äºŒæ¬¡ç­¾åï¼ˆä¾›å‰ç«¯è°ƒç”¨ï¼‰
        Backend-->>Frontend: {timeStamp, nonceStr, package, signType, paySign}
    end

    rect rgb(230, 255, 230)
        Note over User,Database: é˜¶æ®µ3ï¼šå”¤èµ·æ”¯ä»˜
        Frontend->>User: è°ƒèµ·å¾®ä¿¡æ”¯ä»˜æ§ä»¶
        User->>WxPay: è¾“å…¥å¯†ç ç¡®è®¤
        WxPay->>WxPay: æ‰£æ¬¾å¤„ç†
    end

    rect rgb(255, 230, 230)
        Note over User,Database: é˜¶æ®µ4ï¼šå‰ç«¯ç»“æœï¼ˆä¸å¯ä¿¡ï¼‰
        WxPay-->>User: æ”¯ä»˜ç»“æœé¡µé¢
        User->>Frontend: è¿”å›å•†æˆ·é¡µé¢
        Frontend->>Backend: GET /api/order/status/{orderId}
        Note right of Frontend: âš ï¸ å‰ç«¯ç»“æœä»…ä¾›å±•ç¤º<br/>ä¸èƒ½ä½œä¸ºè®¢å•çŠ¶æ€ä¾æ®
    end

    rect rgb(245, 230, 255)
        Note over User,Database: é˜¶æ®µ5ï¼šå¼‚æ­¥é€šçŸ¥ï¼ˆæƒå¨ç»“æœï¼‰
        WxPay->>WxCallback: è§¦å‘å¼‚æ­¥é€šçŸ¥
        WxCallback->>Backend: POST /api/pay/notify<br/>{resource: åŠ å¯†æ•°æ®}
        Backend->>Backend: éªŒç­¾+è§£å¯†
        Backend->>Database: æ›´æ–°è®¢å•çŠ¶æ€ï¼šå·²æ”¯ä»˜
        Backend->>Backend: æ‰§è¡Œä¸šåŠ¡é€»è¾‘<br/>ï¼ˆå‘è´§/å¢åŠ ç§¯åˆ†ç­‰ï¼‰
        Backend-->>WxCallback: {"code": "SUCCESS"}
        WxCallback->>WxPay: æ ‡è®°é€šçŸ¥æˆåŠŸ
    end

    rect rgb(240, 240, 240)
        Note over User,Database: é˜¶æ®µ6ï¼šçŠ¶æ€è½®è¯¢ï¼ˆå…œåº•æ–¹æ¡ˆï¼‰
        Frontend->>Backend: è½®è¯¢è®¢å•çŠ¶æ€ï¼ˆæ¯2ç§’ï¼‰
        Backend->>Database: æŸ¥è¯¢è®¢å•çŠ¶æ€
        Database-->>Backend: çŠ¶æ€ï¼šå·²æ”¯ä»˜
        Backend-->>Frontend: {status: "paid"}
        Frontend->>User: å±•ç¤ºæ”¯ä»˜æˆåŠŸé¡µé¢
    end

    rect rgb(255, 250, 230)
        Note over User,Database: é˜¶æ®µ7ï¼šä¸»åŠ¨æŸ¥è¯¢ï¼ˆå¼‚å¸¸å…œåº•ï¼‰
        Note over Backend: è‹¥10åˆ†é’Ÿæœªæ”¶åˆ°é€šçŸ¥
        Backend->>WxPay: GET /v3/pay/transactions/out-trade-no/{è®¢å•å·}
        WxPay-->>Backend: {trade_state: "SUCCESS"}
        Backend->>Database: æ›´æ–°è®¢å•çŠ¶æ€
    end
```

---

### å…³é”®èŠ‚ç‚¹åˆ†æ

#### **èŠ‚ç‚¹1-5ï¼šè®¢å•åˆ›å»º**

**å‰ç«¯ä»£ç ç¤ºä¾‹**ï¼ˆVue3ï¼‰ï¼š
```javascript
// åˆ›å»ºè®¢å•
async function createOrder() {
  try {
    const response = await axios.post('/api/order/create', {
      productId: 'PROD_001',
      quantity: 1,
      amount: 9900, // å•ä½ï¼šåˆ†ï¼ˆ99å…ƒï¼‰
      description: 'ç²¾å“è¯¾ç¨‹-Vue3å®æˆ˜'
    });
  
    const { orderId, amount } = response.data;
  
    // ç«‹å³å‘èµ·æ”¯ä»˜
    await preparePayment(orderId);
  } catch (error) {
    console.error('è®¢å•åˆ›å»ºå¤±è´¥:', error);
  }
}
```

**åç«¯ä»£ç ç¤ºä¾‹**ï¼ˆNode.jsï¼‰ï¼š
```javascript
// åˆ›å»ºè®¢å•æ¥å£
app.post('/api/order/create', async (req, res) => {
  const { productId, quantity, amount, description } = req.body;

  // 1. ç”Ÿæˆå•†æˆ·è®¢å•å·ï¼ˆå¿…é¡»å”¯ä¸€ï¼‰
  const outTradeNo = generateOrderNo(); // ä¾‹å¦‚ï¼š20241023123456789

  // 2. ä¿å­˜è®¢å•åˆ°æ•°æ®åº“
  await db.orders.create({
    outTradeNo,
    productId,
    quantity,
    amount,
    description,
    status: 'PENDING', // å¾…æ”¯ä»˜
    userId: req.user.id,
    createdAt: new Date()
  });

  res.json({
    orderId: outTradeNo,
    amount
  });
});

// è®¢å•å·ç”Ÿæˆè§„åˆ™
function generateOrderNo() {
  const date = new Date();
  const dateStr = date.toISOString().replace(/[-T:\.Z]/g, '').slice(0, 14);
  const random = Math.random().toString(36).substr(2, 9).toUpperCase();
  return `${dateStr}${random}`; // ä¾‹å¦‚ï¼š20241023103045ABC123DEF
}
```

> **ğŸ’¡ è®¾è®¡è¦ç‚¹**ï¼š
> - è®¢å•å·å¿…é¡»å…¨å±€å”¯ä¸€ï¼Œå»ºè®®åŒ…å«æ—¶é—´æˆ³+éšæœºæ•°
> - é‡‘é¢å•ä½ç»Ÿä¸€ä¸º**åˆ†**ï¼Œé¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
> - è®¢å•åˆ›å»ºå’Œæ”¯ä»˜åˆ†ç¦»ï¼Œæ”¯æŒç”¨æˆ·å¤šæ¬¡å°è¯•æ”¯ä»˜

---

#### **èŠ‚ç‚¹6-12ï¼šç»Ÿä¸€ä¸‹å•**

è¿™æ˜¯æ•´ä¸ªæµç¨‹ä¸­æœ€å¤æ‚çš„ç¯èŠ‚ï¼Œæ¶‰åŠç­¾åç”Ÿæˆã€å‚æ•°ç»„è£…ç­‰ã€‚

**åç«¯å®ç°**ï¼ˆNode.js + V3 APIï¼‰ï¼š
```javascript
const axios = require('axios');
const crypto = require('crypto');
const fs = require('fs');

// ç»Ÿä¸€ä¸‹å•æ¥å£
app.post('/api/pay/prepare', async (req, res) => {
  const { orderId } = req.body;

  // 1. æŸ¥è¯¢è®¢å•ä¿¡æ¯
  const order = await db.orders.findOne({ outTradeNo: orderId });
  if (!order) {
    return res.status(404).json({ error: 'è®¢å•ä¸å­˜åœ¨' });
  }

  // 2. è·å–ç”¨æˆ·openidï¼ˆJSAPIæ”¯ä»˜å¿…éœ€ï¼‰
  const openid = req.user.openid; // ä»session/tokenä¸­è·å–

  // 3. ç»„è£…è¯·æ±‚å‚æ•°
  const params = {
    appid: config.appId,
    mchid: config.mchId,
    description: order.description,
    out_trade_no: order.outTradeNo,
    notify_url: config.notifyUrl,
    amount: {
      total: order.amount,
      currency: 'CNY'
    },
    payer: {
      openid: openid
    }
  };

  // 4. ç”Ÿæˆç­¾åå¹¶è°ƒç”¨å¾®ä¿¡API
  const prepayId = await unifiedOrder(params);

  // 5. ç”Ÿæˆå‰ç«¯è°ƒèµ·æ”¯ä»˜æ‰€éœ€å‚æ•°
  const paymentParams = generatePaymentParams(prepayId);

  res.json(paymentParams);
});

// è°ƒç”¨å¾®ä¿¡ç»Ÿä¸€ä¸‹å•API
async function unifiedOrder(params) {
  const url = 'https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi';
  const method = 'POST';
  const body = JSON.stringify(params);

  // ç”Ÿæˆç­¾å
  const signature = generateSignature(method, url, body);

  try {
    const response = await axios.post(url, body, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': buildAuthHeader(signature),
        'User-Agent': 'MyMerchant/1.0'
      }
    });
  
    return response.data.prepay_id;
  } catch (error) {
    console.error('ç»Ÿä¸€ä¸‹å•å¤±è´¥:', error.response?.data);
    throw new Error('æ”¯ä»˜å‡†å¤‡å¤±è´¥');
  }
}

// ç”ŸæˆV3ç­¾åï¼ˆè¯¦ç»†å®ç°è§ä¸‹ä¸€èŠ‚ï¼‰
function generateSignature(method, url, body) {
  const timestamp = Math.floor(Date.now() / 1000);
  const nonceStr = crypto.randomBytes(16).toString('hex');
  const urlObj = new URL(url);
  const urlPath = urlObj.pathname + urlObj.search;

  // æ„é€ ç­¾åä¸²
  const signStr = `${method}\n${urlPath}\n${timestamp}\n${nonceStr}\n${body}\n`;

  // ä½¿ç”¨å•†æˆ·ç§é’¥ç­¾å
  const privateKey = fs.readFileSync(config.privateKeyPath);
  const sign = crypto.createSign('RSA-SHA256');
  sign.update(signStr);
  const signature = sign.sign(privateKey, 'base64');

  return {
    timestamp,
    nonceStr,
    signature
  };
}

// æ„é€ Authorizationå¤´
function buildAuthHeader({ timestamp, nonceStr, signature }) {
  return `WECHATPAY2-SHA256-RSA2048 mchid="${config.mchId}",nonce_str="${nonceStr}",signature="${signature}",timestamp="${timestamp}",serial_no="${config.serialNo}"`;
}

// ç”Ÿæˆå‰ç«¯è°ƒèµ·æ”¯ä»˜çš„å‚æ•°
function generatePaymentParams(prepayId) {
  const timestamp = Math.floor(Date.now() / 1000).toString();
  const nonceStr = crypto.randomBytes(16).toString('hex');
  const packageStr = `prepay_id=${prepayId}`;

  // äºŒæ¬¡ç­¾åï¼ˆä¾›å‰ç«¯ä½¿ç”¨ï¼‰
  const signStr = `${config.appId}\n${timestamp}\n${nonceStr}\n${packageStr}\n`;
  const sign = crypto.createSign('RSA-SHA256');
  sign.update(signStr);
  const paySign = sign.sign(fs.readFileSync(config.privateKeyPath), 'base64');

  return {
    timeStamp: timestamp,
    nonceStr,
    package: packageStr,
    signType: 'RSA',
    paySign
  };
}
```

**å‰ç«¯è°ƒèµ·æ”¯ä»˜**ï¼ˆVue3 + å°ç¨‹åºï¼‰ï¼š
```javascript
// å°ç¨‹åºæ”¯ä»˜
async function payInMiniProgram(orderId) {
  try {
    // 1. è·å–æ”¯ä»˜å‚æ•°
    const payParams = await axios.post('/api/pay/prepare', { orderId });
  
    // 2. è°ƒèµ·å¾®ä¿¡æ”¯ä»˜
    const result = await new Promise((resolve, reject) => {
      wx.requestPayment({
        timeStamp: payParams.timeStamp,
        nonceStr: payParams.nonceStr,
        package: payParams.package,
        signType: payParams.signType,
        paySign: payParams.paySign,
        success: resolve,
        fail: reject
      });
    });
  
    console.log('æ”¯ä»˜æˆåŠŸï¼ˆå‰ç«¯ç»“æœï¼‰:', result);
  
    // 3. è½®è¯¢è®¢å•çŠ¶æ€ï¼ˆä¸èƒ½ç›´æ¥ä¿¡ä»»å‰ç«¯ç»“æœï¼‰
    await pollOrderStatus(orderId);
  
  } catch (error) {
    if (error.errMsg.includes('cancel')) {
      console.log('ç”¨æˆ·å–æ¶ˆæ”¯ä»˜');
    } else {
      console.error('æ”¯ä»˜å¤±è´¥:', error);
    }
  }
}

// è½®è¯¢è®¢å•çŠ¶æ€
async function pollOrderStatus(orderId, maxAttempts = 30) {
  for (let i = 0; i < maxAttempts; i++) {
    await new Promise(resolve => setTimeout(resolve, 2000)); // ç­‰å¾…2ç§’
  
    const order = await axios.get(`/api/order/status/${orderId}`);
  
    if (order.data.status === 'PAID') {
      console.log('æ”¯ä»˜ç¡®è®¤æˆåŠŸ');
      // è·³è½¬åˆ°æˆåŠŸé¡µé¢
      wx.redirectTo({ url: '/pages/order/success?orderId=' + orderId });
      return;
    }
  }

  console.warn('æ”¯ä»˜çŠ¶æ€ç¡®è®¤è¶…æ—¶ï¼Œè¯·æ‰‹åŠ¨æŸ¥è¯¢è®¢å•');
}
```

---

#### **èŠ‚ç‚¹18-23ï¼šå¼‚æ­¥é€šçŸ¥å¤„ç†**

è¿™æ˜¯ç¡®è®¤è®¢å•çŠ¶æ€çš„**æƒå¨æ¥æº**ï¼Œå¿…é¡»ä¸¥æ ¼éªŒç­¾å¹¶ä¿è¯å¹‚ç­‰æ€§ã€‚

**åç«¯å›è°ƒå¤„ç†**ï¼š
```javascript
const crypto = require('crypto');

// æ”¯ä»˜å›è°ƒæ¥å£
app.post('/api/pay/notify', async (req, res) => {
  try {
    // 1. éªŒè¯ç­¾å
    const isValid = await verifyNotifySignature(req);
    if (!isValid) {
      console.error('å›è°ƒç­¾åéªŒè¯å¤±è´¥');
      return res.status(401).json({ code: 'FAIL', message: 'ç­¾åéªŒè¯å¤±è´¥' });
    }
  
    // 2. è§£å¯†resourceæ•°æ®
    const resource = req.body.resource;
    const decryptedData = decryptResource(resource);
    const paymentData = JSON.parse(decryptedData);
  
    console.log('æ”¯ä»˜å›è°ƒæ•°æ®:', paymentData);
  
    // 3. å¹‚ç­‰æ€§æ£€æŸ¥ï¼ˆé˜²æ­¢é‡å¤å¤„ç†ï¼‰
    const outTradeNo = paymentData.out_trade_no;
    const order = await db.orders.findOne({ outTradeNo });
  
    if (order.status === 'PAID') {
      console.log('è®¢å•å·²å¤„ç†ï¼Œè·³è¿‡é‡å¤é€šçŸ¥');
      return res.json({ code: 'SUCCESS' });
    }
  
    // 4. éªŒè¯é‡‘é¢
    if (order.amount !== paymentData.amount.total) {
      console.error('é‡‘é¢ä¸åŒ¹é…');
      return res.status(400).json({ code: 'FAIL', message: 'é‡‘é¢å¼‚å¸¸' });
    }
  
    // 5. æ›´æ–°è®¢å•çŠ¶æ€ï¼ˆä½¿ç”¨äº‹åŠ¡ï¼‰
    await db.transaction(async (trx) => {
      await db.orders.update(
        { outTradeNo },
        {
          status: 'PAID',
          transactionId: paymentData.transaction_id,
          paidAt: new Date(paymentData.success_time)
        },
        { transaction: trx }
      );
    
      // 6. æ‰§è¡Œä¸šåŠ¡é€»è¾‘
      await executeBusinessLogic(order, trx);
    });
  
    // 7. è¿”å›æˆåŠŸåº”ç­”ï¼ˆå¿…é¡»ï¼ï¼‰
    res.json({ code: 'SUCCESS' });
  
  } catch (error) {
    console.error('å›è°ƒå¤„ç†å¼‚å¸¸:', error);
    res.status(500).json({ code: 'FAIL', message: error.message });
  }
});

// éªŒè¯å›è°ƒç­¾å
async function verifyNotifySignature(req) {
  const signature = req.headers['wechatpay-signature'];
  const timestamp = req.headers['wechatpay-timestamp'];
  const nonce = req.headers['wechatpay-nonce'];
  const body = JSON.stringify(req.body);

  // æ„é€ éªŒç­¾ä¸²
  const signStr = `${timestamp}\n${nonce}\n${body}\n`;

  // è·å–å¾®ä¿¡å¹³å°è¯ä¹¦å…¬é’¥
  const publicKey = await getPlatformPublicKey();

  // éªŒç­¾
  const verify = crypto.createVerify('RSA-SHA256');
  verify.update(signStr);
  return verify.verify(publicKey, signature, 'base64');
}

// è§£å¯†resourceæ•°æ®
function decryptResource(resource) {
  const { ciphertext, associated_data, nonce } = resource;

  // AES-256-GCMè§£å¯†
  const decipher = crypto.createDecipheriv(
    'aes-256-gcm',
    config.v3Key, // APIv3å¯†é’¥
    nonce
  );

  decipher.setAuthTag(Buffer.from(resource.tag || '', 'base64'));
  decipher.setAAD(Buffer.from(associated_data));

  let decrypted = decipher.update(ciphertext, 'base64', 'utf8');
  decrypted += decipher.final('utf8');

  return decrypted;
}

// æ‰§è¡Œä¸šåŠ¡é€»è¾‘
async function executeBusinessLogic(order, trx) {
  // ç¤ºä¾‹ï¼šå¢åŠ ç”¨æˆ·ç§¯åˆ†
  await db.users.increment(
    { id: order.userId },
    { points: Math.floor(order.amount / 100) },
    { transaction: trx }
  );

  // ç¤ºä¾‹ï¼šå‘é€æ”¯ä»˜æˆåŠŸé€šçŸ¥
  await sendNotification(order.userId, {
    type: 'PAYMENT_SUCCESS',
    orderId: order.outTradeNo,
    amount: order.amount
  });

  // ç¤ºä¾‹ï¼šå¦‚æœæ˜¯è™šæ‹Ÿå•†å“ï¼Œè‡ªåŠ¨å‘è´§
  if (order.productType === 'VIRTUAL') {
    await deliverVirtualProduct(order, trx);
  }
}
```

> **âš ï¸ å…³é”®æ³¨æ„äº‹é¡¹**ï¼š
> 1. **å¿…é¡»éªŒç­¾**ï¼šæ‹’ç»æ‰€æœ‰éªŒç­¾å¤±è´¥çš„è¯·æ±‚
> 2. **å¹‚ç­‰è®¾è®¡**ï¼šæ”¯ä»˜æˆåŠŸçš„è®¢å•ä¸èƒ½é‡å¤å¤„ç†
> 3. **å¿«é€Ÿå“åº”**ï¼šä¸šåŠ¡é€»è¾‘å»ºè®®å¼‚æ­¥å¤„ç†ï¼Œå›è°ƒæ¥å£åº”åœ¨5ç§’å†…è¿”å›
> 4. **è¿”å›æ ¼å¼**ï¼šå¿…é¡»è¿”å›`{"code": "SUCCESS"}`ï¼Œå¦åˆ™å¾®ä¿¡ä¼šæŒç»­é‡è¯•
> 5. **å¼‚å¸¸å¤„ç†**ï¼šè¿”å›é200çŠ¶æ€ç ï¼Œå¾®ä¿¡ä¼šæŒ‰ç…§å›ºå®šé¢‘ç‡é‡è¯•ï¼ˆ15s/15s/30s/3m/10m/20m/30m/30m...æœ€å¤šé€šçŸ¥10æ¬¡ï¼‰

---

### å¼‚å¸¸æµç¨‹å¤„ç†

```mermaid
graph TD
    A[ç”¨æˆ·å‘èµ·æ”¯ä»˜] --> B{ç½‘ç»œè¶…æ—¶?}
    B -->|æ˜¯| C[å‰ç«¯é‡è¯•3æ¬¡]
    C --> D{ä»è¶…æ—¶?}
    D -->|æ˜¯| E[æç¤ºç”¨æˆ·æ£€æŸ¥ç½‘ç»œ<br/>ä¿ç•™è®¢å•å·ä¾›æŸ¥è¯¢]
    D -->|å¦| F[ç»§ç»­æ”¯ä»˜æµç¨‹]
  
    B -->|å¦| G{æ”¯ä»˜è¿‡ç¨‹å¼‚å¸¸?}
    G -->|ç”¨æˆ·å–æ¶ˆ| H[ä¿ç•™è®¢å•<br/>å…è®¸é‡æ–°æ”¯ä»˜]
    G -->|ä½™é¢ä¸è¶³| I[æç¤ºå……å€¼<br/>ä¿ç•™è®¢å•]
    G -->|ç³»ç»Ÿé”™è¯¯| J[è®°å½•é”™è¯¯æ—¥å¿—<br/>äººå·¥ä»‹å…¥]
  
    F --> K{æ”¶åˆ°å›è°ƒ?}
    K -->|æ˜¯| L[æ­£å¸¸å¤„ç†]
    K -->|å¦10åˆ†é’Ÿ| M[ä¸»åŠ¨æŸ¥è¯¢è®¢å•]
  
    M --> N{æŸ¥è¯¢ç»“æœ?}
    N -->|å·²æ”¯ä»˜| O[è¡¥å‘é€šçŸ¥<br/>æ›´æ–°çŠ¶æ€]
    N -->|æœªæ”¯ä»˜| P[æ ‡è®°è®¢å•å¼‚å¸¸<br/>æç¤ºç”¨æˆ·è”ç³»å®¢æœ]
    N -->|è®¢å•ä¸å­˜åœ¨| Q[æ ¸å¯¹è®¢å•å·<br/>æ£€æŸ¥ç³»ç»Ÿæ—¥å¿—]
```

**ä¸»åŠ¨æŸ¥è¯¢è®¢å•å®ç°**ï¼š
```javascript
// å®šæ—¶ä»»åŠ¡ï¼šæ£€æŸ¥é•¿æ—¶é—´æœªæ”¶åˆ°å›è°ƒçš„è®¢å•
async function checkPendingOrders() {
  const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000);

  // æŸ¥è¯¢10åˆ†é’Ÿå‰åˆ›å»ºä½†ä»æœªæ”¯ä»˜çš„è®¢å•
  const pendingOrders = await db.orders.find({
    status: 'PENDING',
    createdAt: { $lt: tenMinutesAgo }
  });

  for (const order of pendingOrders) {
    try {
      // è°ƒç”¨å¾®ä¿¡æŸ¥å•æ¥å£
      const result = await queryOrder(order.outTradeNo);
    
      if (result.trade_state === 'SUCCESS') {
        // æ”¯ä»˜æˆåŠŸä½†æœªæ”¶åˆ°å›è°ƒï¼Œè¡¥å•å¤„ç†
        await processPaymentSuccess(order, result);
        console.log(`è®¢å•${order.outTradeNo}è¡¥å•æˆåŠŸ`);
      } else if (result.trade_state === 'CLOSED' || result.trade_state === 'PAYERROR') {
        // è®¢å•å…³é—­æˆ–æ”¯ä»˜å¤±è´¥
        await db.orders.update(
          { outTradeNo: order.outTradeNo },
          { status: 'CLOSED', closedAt: new Date() }
        );
      }
      // å…¶ä»–çŠ¶æ€ï¼ˆå¦‚NOTPAYï¼‰ç»§ç»­ç­‰å¾…
    } catch (error) {
      console.error(`æŸ¥è¯¢è®¢å•${order.outTradeNo}å¤±è´¥:`, error);
    }
  }
}

// æŸ¥è¯¢è®¢å•æ¥å£
async function queryOrder(outTradeNo) {
  const url = `https://api.mch.weixin.qq.com/v3/pay/transactions/out-trade-no/${outTradeNo}`;
  const method = 'GET';

  const signature = generateSignature(method, url, '');

  const response = await axios.get(url, {
    headers: {
      'Authorization': buildAuthHeader(signature),
      'Accept': 'application/json'
    },
    params: {
      mchid: config.mchId
    }
  });

  return response.data;
}

// å®šæ—¶æ‰§è¡Œï¼ˆæ¯åˆ†é’Ÿï¼‰
setInterval(checkPendingOrders, 60 * 1000);
```

---

## ç­¾åç®—æ³•å®æˆ˜

ç­¾åæ˜¯å¾®ä¿¡æ”¯ä»˜å®‰å…¨æœºåˆ¶çš„æ ¸å¿ƒï¼Œåˆ†ä¸ºV2å’ŒV3ä¸¤å¥—ç®—æ³•ã€‚

### V2ç­¾åç®—æ³•

> **ğŸ“Œ è¯´æ˜**ï¼šV2å·²é€æ­¥æ·˜æ±°ï¼Œä½†éƒ¨åˆ†æ¥å£ï¼ˆå¦‚é€€æ¬¾ã€çº¢åŒ…ï¼‰ä»åœ¨ä½¿ç”¨ã€‚

**ç­¾åæ­¥éª¤**ï¼š
1. å‚æ•°æŒ‰ASCIIç å‡åºæ’åº
2. æ‹¼æ¥æˆ`key=value`æ ¼å¼
3. æœ«å°¾è¿½åŠ `&key=å•†æˆ·å¯†é’¥`
4. è¿›è¡ŒMD5æˆ–HMAC-SHA256

**å®Œæ•´å®ç°**ï¼š
```javascript
const crypto = require('crypto');

// V2ç­¾åç”Ÿæˆ
function generateV2Signature(params, signType = 'HMAC-SHA256') {
  // 1. è¿‡æ»¤ç©ºå€¼å‚æ•°
  const filteredParams = Object.keys(params)
    .filter(key => params[key] !== '' && params[key] !== undefined)
    .reduce((obj, key) => {
      obj[key] = params[key];
      return obj;
    }, {});

  // 2. æŒ‰é”®åASCIIç å‡åºæ’åº
  const sortedKeys = Object.keys(filteredParams).sort();

  // 3. æ‹¼æ¥æˆ key=value& æ ¼å¼
  const stringA = sortedKeys
    .map(key => `${key}=${filteredParams[key]}`)
    .join('&');

  // 4. è¿½åŠ å¯†é’¥
  const stringSignTemp = `${stringA}&key=${config.v2Key}`;

  // 5. è®¡ç®—ç­¾å
  let signature;
  if (signType === 'MD5') {
    signature = crypto.createHash('md5').update(stringSignTemp, 'utf8').digest('hex');
  } else { // HMAC-SHA256
    signature = crypto.createHmac('sha256', config.v2Key).update(stringSignTemp, 'utf8').digest('hex');
  }

  return signature.toUpperCase();
}

// ä½¿ç”¨ç¤ºä¾‹
const params = {
  appid: 'wx1234567890abcdef',
  mch_id: '1234567890',
  nonce_str: 'ibuaiVcKdpRxkhJA',
  out_trade_no: '20241023123456',
  total_fee: 9900,
  sign_type: 'HMAC-SHA256'
};

const sign = generateV2Signature(params);
console.log('V2ç­¾å:', sign);
// è¾“å‡ºï¼š6A9AE1657590FD5B2A0DCADC7B0AFE0B
```

**éªŒç­¾ç¤ºä¾‹**ï¼š
```javascript
// V2éªŒç­¾
function verifyV2Signature(params) {
  const receivedSign = params.sign;
  const signType = params.sign_type || 'MD5';

  // ç§»é™¤signå­—æ®µ
  const paramsWithoutSign = { ...params };
  delete paramsWithoutSign.sign;

  // é‡æ–°è®¡ç®—ç­¾å
  const calculatedSign = generateV2Signature(paramsWithoutSign, signType);

  return receivedSign === calculatedSign;
}
```

---

### V3ç­¾åç®—æ³•

**ç­¾åæ­¥éª¤**ï¼š
1. æ„é€ ç­¾åä¸²ï¼ˆåŒ…å«HTTPæ–¹æ³•ã€URLã€æ—¶é—´æˆ³ã€éšæœºæ•°ã€è¯·æ±‚ä½“ï¼‰
2. ä½¿ç”¨å•†æˆ·ç§é’¥è¿›è¡ŒSHA256-RSA2048ç­¾å
3. Base64ç¼–ç 
4. æ”¾å…¥Authorizationå¤´

**å®Œæ•´å®ç°**ï¼š
```javascript
const crypto = require('crypto');
const fs = require('fs');

// V3ç­¾åç”Ÿæˆï¼ˆè¯·æ±‚æ—¶ä½¿ç”¨ï¼‰
function generateV3Signature(method, url, body = '') {
  const timestamp = Math.floor(Date.now() / 1000);
  const nonceStr = crypto.randomBytes(16).toString('hex');

  // è§£æURL
  const urlObj = new URL(url);
  const urlPath = urlObj.pathname + urlObj.search; // åŒ…å«queryå‚æ•°

  // æ„é€ ç­¾åä¸²ï¼ˆæ¯éƒ¨åˆ†ä»¥\nåˆ†éš”ï¼‰
  const signStr = [
    method.toUpperCase(),
    urlPath,
    timestamp,
    nonceStr,
    body // å¦‚æœæ˜¯GETè¯·æ±‚ï¼Œbodyä¸ºç©ºå­—ç¬¦ä¸²
  ].join('\n') + '\n'; // æ³¨æ„æœ«å°¾ä¹Ÿæœ‰\n

  console.log('å¾…ç­¾åå­—ç¬¦ä¸²:\n', signStr);

  // è¯»å–å•†æˆ·ç§é’¥
  const privateKey = fs.readFileSync(config.privateKeyPath, 'utf8');

  // ä½¿ç”¨ç§é’¥ç­¾å
  const sign = crypto.createSign('RSA-SHA256');
  sign.update(signStr);
  const signature = sign.sign(privateKey, 'base64');

  return {
    timestamp,
    nonceStr,
    signature
  };
}

// æ„é€ Authorizationå¤´
function buildV3AuthHeader(method, url, body = '') {
  const { timestamp, nonceStr, signature } = generateV3Signature(method, url, body);

  return `WECHATPAY2-SHA256-RSA2048 mchid="${config.mchId}",nonce_str="${nonceStr}",signature="${signature}",timestamp="${timestamp}",serial_no="${config.serialNo}"`;
}

// ä½¿ç”¨ç¤ºä¾‹
const url = 'https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi';
const method = 'POST';
const body = JSON.stringify({
  appid: config.appId,
  mchid: config.mch
  ç»§ç»­ç”Ÿæˆæ–‡æ¡£2çš„å‰©ä½™å†…å®¹...

---

```javascript
// ä½¿ç”¨ç¤ºä¾‹ï¼ˆæ¥ä¸Šæ–‡ï¼‰
const url = 'https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi';
const method = 'POST';
const body = JSON.stringify({
  appid: config.appId,
  mchid: config.mchId,
  description: 'æµ‹è¯•å•†å“',
  out_trade_no: '20241023123456',
  notify_url: config.notifyUrl,
  amount: {
    total: 100,
    currency: 'CNY'
  }
});

const authHeader = buildV3AuthHeader(method, url, body);
console.log('Authorization:', authHeader);
```

**V3éªŒç­¾å®ç°**ï¼ˆéªŒè¯å¾®ä¿¡è¿”å›/å›è°ƒçš„ç­¾åï¼‰ï¼š
```javascript
const crypto = require('crypto');

// V3éªŒç­¾ï¼ˆæ¥æ”¶å¾®ä¿¡å“åº”/å›è°ƒæ—¶ä½¿ç”¨ï¼‰
function verifyV3Signature(timestamp, nonce, body, signature) {
  // 1. æ„é€ éªŒç­¾ä¸²
  const signStr = [
    timestamp,
    nonce,
    body
  ].join('\n') + '\n';

  console.log('éªŒç­¾å­—ç¬¦ä¸²:\n', signStr);

  // 2. è·å–å¾®ä¿¡å¹³å°è¯ä¹¦å…¬é’¥
  const publicKey = getPlatformPublicKey();

  // 3. éªŒè¯ç­¾å
  const verify = crypto.createVerify('RSA-SHA256');
  verify.update(signStr);

  return verify.verify(publicKey, signature, 'base64');
}

// ä»HTTPå¤´ä¸­æå–å¹¶éªŒç­¾ï¼ˆExpressä¸­é—´ä»¶ï¼‰
function verifyWechatSignatureMiddleware(req, res, next) {
  const signature = req.headers['wechatpay-signature'];
  const timestamp = req.headers['wechatpay-timestamp'];
  const nonce = req.headers['wechatpay-nonce'];
  const body = JSON.stringify(req.body);

  // é˜²é‡æ”¾æ”»å‡»ï¼šæ£€æŸ¥æ—¶é—´æˆ³
  const now = Math.floor(Date.now() / 1000);
  if (Math.abs(now - timestamp) > 300) { // 5åˆ†é’Ÿ
    return res.status(401).json({ code: 'FAIL', message: 'è¯·æ±‚å·²è¿‡æœŸ' });
  }

  // éªŒç­¾
  const isValid = verifyV3Signature(timestamp, nonce, body, signature);

  if (!isValid) {
    console.error('ç­¾åéªŒè¯å¤±è´¥');
    return res.status(401).json({ code: 'FAIL', message: 'ç­¾åéªŒè¯å¤±è´¥' });
  }

  next();
}

// åœ¨å›è°ƒè·¯ç”±ä¸­ä½¿ç”¨
app.post('/api/pay/notify', verifyWechatSignatureMiddleware, async (req, res) => {
  // ç­¾åå·²éªŒè¯ï¼Œå¤„ç†ä¸šåŠ¡é€»è¾‘
  // ...
});
```

---

### ç­¾åéªŒè¯å®ç°

**å®Œæ•´çš„ç­¾åæµ‹è¯•å·¥å…·**ï¼š
```javascript
// ç­¾åè°ƒè¯•å·¥å…·
class SignatureTester {
  // æµ‹è¯•V2ç­¾å
  static testV2() {
    const params = {
      appid: 'wx1234567890abcdef',
      mch_id: '1234567890',
      nonce_str: 'test123456',
      out_trade_no: 'TEST20241023001',
      total_fee: 100
    };
  
    console.log('V2ç­¾åæµ‹è¯•');
    console.log('åŸå§‹å‚æ•°:', params);
  
    const signature = generateV2Signature(params);
    console.log('ç”Ÿæˆç­¾å:', signature);
  
    // éªŒè¯
    params.sign = signature;
    const isValid = verifyV2Signature(params);
    console.log('éªŒç­¾ç»“æœ:', isValid ? 'âœ… é€šè¿‡' : 'âŒ å¤±è´¥');
  }

  // æµ‹è¯•V3ç­¾å
  static testV3() {
    const method = 'POST';
    const url = 'https://api.mch.weixin.qq.com/v3/pay/transactions/jsapi';
    const body = '{"test":"data"}';
  
    console.log('\nV3ç­¾åæµ‹è¯•');
    console.log('è¯·æ±‚æ–¹æ³•:', method);
    console.log('è¯·æ±‚URL:', url);
    console.log('è¯·æ±‚ä½“:', body);
  
    const { timestamp, nonceStr, signature } = generateV3Signature(method, url, body);
    console.log('æ—¶é—´æˆ³:', timestamp);
    console.log('éšæœºä¸²:', nonceStr);
    console.log('ç­¾å:', signature);
  
    // æ¨¡æ‹ŸéªŒç­¾
    const signStr = `${method}\n/v3/pay/transactions/jsapi\n${timestamp}\n${nonceStr}\n${body}\n`;
    console.log('ç­¾ååŸæ–‡:\n', signStr);
  }

  // å¯¹æ¯”ä¸¤æ¬¡ç­¾å
  static compareSignatures(params) {
    const sign1 = generateV2Signature(params);
    const sign2 = generateV2Signature(params);
  
    console.log('\nç­¾åä¸€è‡´æ€§æµ‹è¯•');
    console.log('ç¬¬ä¸€æ¬¡:', sign1);
    console.log('ç¬¬äºŒæ¬¡:', sign2);
    console.log('ç»“æœ:', sign1 === sign2 ? 'âœ… ä¸€è‡´' : 'âŒ ä¸ä¸€è‡´ï¼ˆæ£€æŸ¥éšæœºæ•°ï¼‰');
  }
}

// è¿è¡Œæµ‹è¯•
SignatureTester.testV2();
SignatureTester.testV3();
```

---

### å¸¸è§ç­¾åé”™è¯¯æ’æŸ¥

```mermaid
graph TD
    A[ç­¾åé”™è¯¯] --> B{é”™è¯¯ç±»å‹}
  
    B -->|ç­¾åä¸åŒ¹é…| C{æ£€æŸ¥é¡¹ç›®}
    C --> D[å‚æ•°é¡ºåºæ˜¯å¦æ­£ç¡®?]
    C --> E[æ˜¯å¦åŒ…å«ç©ºå€¼å‚æ•°?]
    C --> F[å¯†é’¥æ˜¯å¦æ­£ç¡®?]
    C --> G[ç¼–ç æ ¼å¼æ˜¯å¦ä¸€è‡´?]
  
    B -->|æ—¶é—´æˆ³è¿‡æœŸ| H[æ£€æŸ¥æœåŠ¡å™¨æ—¶é—´<br/>ä¸åŒ—äº¬æ—¶é—´è¯¯å·®]
  
    B -->|è¯ä¹¦é”™è¯¯| I{è¯ä¹¦é—®é¢˜}
    I --> J[è¯ä¹¦åºåˆ—å·æ˜¯å¦æ­£ç¡®?]
    I --> K[ç§é’¥æ–‡ä»¶æ˜¯å¦å®Œæ•´?]
    I --> L[è¯ä¹¦æ˜¯å¦è¿‡æœŸ?]
  
    B -->|å‚æ•°ç¼ºå¤±| M[æ£€æŸ¥å¿…ä¼ å‚æ•°<br/>mchid/serial_noç­‰]
  
    style D fill:#ffe6e6
    style E fill:#ffe6e6
    style F fill:#ffe6e6
    style G fill:#ffe6e6
```

**æ’æŸ¥æ¸…å•**ï¼š

| é—®é¢˜ | æ’æŸ¥æ–¹æ³• | è§£å†³æ–¹æ¡ˆ |
|------|---------|---------|
| **V2ç­¾åå¤±è´¥** | æ‰“å°å¾…ç­¾åå­—ç¬¦ä¸² | 1. æ£€æŸ¥å‚æ•°æ’åº<br/>2. ç§»é™¤signå­—æ®µ<br/>3. ç¡®è®¤å¯†é’¥æ­£ç¡® |
| **V3ç­¾åå¤±è´¥** | æ‰“å°ç­¾ååŸæ–‡ | 1. æ£€æŸ¥URLè·¯å¾„ï¼ˆå«queryï¼‰<br/>2. ç¡®è®¤æ—¶é—´æˆ³æ ¼å¼ï¼ˆç§’çº§ï¼‰<br/>3. éªŒè¯ç§é’¥æ–‡ä»¶è·¯å¾„ |
| **æ—¶é—´æˆ³è¿‡æœŸ** | å¯¹æ¯”æœåŠ¡å™¨ä¸åŒ—äº¬æ—¶é—´ | ä½¿ç”¨NTPåŒæ­¥æœåŠ¡å™¨æ—¶é—´ |
| **è¯ä¹¦åºåˆ—å·é”™è¯¯** | æ£€æŸ¥è¯ä¹¦æ–‡ä»¶ | é‡æ–°ä¸‹è½½è¯ä¹¦<br/>æå–åºåˆ—å· |
| **ç¼–ç é—®é¢˜** | æ£€æŸ¥å­—ç¬¦ç¼–ç  | ç»Ÿä¸€ä½¿ç”¨UTF-8 |

**è°ƒè¯•ä»£ç **ï¼š
```javascript
// ç­¾åè°ƒè¯•è¾…åŠ©å‡½æ•°
function debugSignature(params, expectedSign) {
  console.log('========== ç­¾åè°ƒè¯• ==========');

  // 1. æ‰“å°åŸå§‹å‚æ•°
  console.log('1. åŸå§‹å‚æ•°:');
  console.log(JSON.stringify(params, null, 2));

  // 2. æ‰“å°æ’åºåçš„é”®
  const sortedKeys = Object.keys(params).sort();
  console.log('\n2. æ’åºåçš„é”®:', sortedKeys);

  // 3. æ‰“å°å¾…ç­¾åå­—ç¬¦ä¸²
  const stringA = sortedKeys
    .filter(key => params[key] !== '' && key !== 'sign')
    .map(key => `${key}=${params[key]}`)
    .join('&');
  console.log('\n3. å¾…ç­¾åå­—ç¬¦ä¸²ï¼ˆä¸å«keyï¼‰:');
  console.log(stringA);

  // 4. è®¡ç®—ç­¾å
  const calculatedSign = generateV2Signature(params);
  console.log('\n4. è®¡ç®—çš„ç­¾å:', calculatedSign);
  console.log('5. æœŸæœ›çš„ç­¾å:', expectedSign);

  // 5. å¯¹æ¯”ç»“æœ
  const isMatch = calculatedSign === expectedSign;
  console.log('\n6. éªŒç­¾ç»“æœ:', isMatch ? 'âœ… åŒ¹é…' : 'âŒ ä¸åŒ¹é…');

  if (!isMatch) {
    console.log('\nå·®å¼‚åˆ†æ:');
    console.log(`é•¿åº¦: è®¡ç®—=${calculatedSign.length}, æœŸæœ›=${expectedSign.length}`);
    for (let i = 0; i < Math.max(calculatedSign.length, expectedSign.length); i++) {
      if (calculatedSign[i] !== expectedSign[i]) {
        console.log(`ä½ç½®${i}: è®¡ç®—='${calculatedSign[i]}', æœŸæœ›='${expectedSign[i]}'`);
      }
    }
  }

  console.log('================================\n');
}
```

---

## è¯ä¹¦ä½“ç³»æ·±åº¦è§£æ

### è¯ä¹¦ç±»å‹ä¸ä½œç”¨

å¾®ä¿¡æ”¯ä»˜ä½¿ç”¨PKIä½“ç³»ï¼Œæ¶‰åŠä¸‰ç§è¯ä¹¦ï¼š

```mermaid
graph LR
    subgraph å•†æˆ·ä¾§
    A[å•†æˆ·ç§é’¥<br/>apiclient_key.pem] --> B[ç­¾åè¯·æ±‚]
    C[å•†æˆ·å…¬é’¥<br/>apiclient_cert.pem] --> D[ä¸Šä¼ åˆ°å¾®ä¿¡<br/>ç”¨äºéªŒè¯å•†æˆ·èº«ä»½]
    end
  
    subgraph å¾®ä¿¡ä¾§
    E[å¹³å°ç§é’¥<br/>å¾®ä¿¡æŒæœ‰] --> F[ç­¾åå“åº”/å›è°ƒ]
    G[å¹³å°å…¬é’¥<br/>å¹³å°è¯ä¹¦] --> H[å•†æˆ·ä¸‹è½½<br/>ç”¨äºéªŒç­¾]
    end
  
    B -.å‘é€.-> I[å¾®ä¿¡æ”¯ä»˜API]
    I -.éªŒè¯.-> D
    I -.è¿”å›.-> J[å“åº”æ•°æ®]
    F -.ç­¾å.-> J
    J -.éªŒè¯.-> H
  
    style A fill:#ffe6e6
    style C fill:#e6f3ff
    style E fill:#fff3e6
    style G fill:#e6ffe6
```

**è¯¦ç»†è¯´æ˜**ï¼š

| è¯ä¹¦ | æ–‡ä»¶å | ç”¨é€” | æŒæœ‰æ–¹ | æ›´æ–°é¢‘ç‡ |
|------|--------|------|--------|---------|
| **å•†æˆ·ç§é’¥** | apiclient_key.pem | ç­¾åè¯·æ±‚å‚æ•° | å•†æˆ·æœåŠ¡å™¨ | æ‰‹åŠ¨ï¼Œå»ºè®®æ¯å¹´ |
| **å•†æˆ·è¯ä¹¦** | apiclient_cert.pem | åŒ…å«å•†æˆ·å…¬é’¥ | ä¸Šä¼ åˆ°å¾®ä¿¡ | ä¸ç§é’¥åŒæ­¥ |
| **å¹³å°è¯ä¹¦** | wechatpay_SERIAL.pem | éªŒè¯å¾®ä¿¡è¿”å›/å›è°ƒ | å•†æˆ·æœåŠ¡å™¨ | è‡ªåŠ¨ï¼Œæœ‰æ•ˆæœŸ1å¹´ |

---

### è¯ä¹¦è·å–ä¸æ›´æ–°

**1. å•†æˆ·è¯ä¹¦è·å–**

ç™»å½•å¾®ä¿¡æ”¯ä»˜å•†æˆ·å¹³å°ï¼š
```
è´¦æˆ·ä¸­å¿ƒ â†’ APIå®‰å…¨ â†’ ç”³è¯·APIè¯ä¹¦
```

ä¸‹è½½åå¾—åˆ°å‹ç¼©åŒ…ï¼ŒåŒ…å«ä¸‰ä¸ªæ–‡ä»¶ï¼š
- `apiclient_cert.pem` - å•†æˆ·è¯ä¹¦ï¼ˆå…¬é’¥ï¼‰
- `apiclient_key.pem` - å•†æˆ·ç§é’¥
- `apiclient_cert.p12` - PKCS12æ ¼å¼è¯ä¹¦ï¼ˆJavaä½¿ç”¨ï¼‰

**æå–è¯ä¹¦åºåˆ—å·**ï¼š
```bash
# æ–¹æ³•1ï¼šä½¿ç”¨openssl
openssl x509 -in apiclient_cert.pem -noout -serial

# è¾“å‡ºç¤ºä¾‹ï¼š
# serial=5E4A3B2C1D0F9E8A7B6C5D4E3F2A1B0C

# æ–¹æ³•2ï¼šåœ¨å•†æˆ·å¹³å°æŸ¥çœ‹
# è´¦æˆ·ä¸­å¿ƒ â†’ APIå®‰å…¨ â†’ æŸ¥çœ‹è¯ä¹¦ â†’ è¯ä¹¦åºåˆ—å·
```

**2. å¹³å°è¯ä¹¦è·å–**

å¹³å°è¯ä¹¦å¿…é¡»é€šè¿‡APIåŠ¨æ€è·å–ï¼š

```javascript
const axios = require('axios');
const crypto = require('crypto');
const fs = require('fs');

// è·å–å¹³å°è¯ä¹¦
async function downloadPlatformCertificate() {
  const url = 'https://api.mch.weixin.qq.com/v3/certificates';
  const method = 'GET';

  // 1. ç”Ÿæˆç­¾å
  const { timestamp, nonceStr, signature } = generateV3Signature(method, url, '');

  try {
    // 2. è¯·æ±‚è¯ä¹¦åˆ—è¡¨
    const response = await axios.get(url, {
      headers: {
        'Authorization': buildV3AuthHeader(method, url, ''),
        'Accept': 'application/json'
      }
    });
  
    const certificates = response.data.data;
    console.log(`è·å–åˆ°${certificates.length}ä¸ªå¹³å°è¯ä¹¦`);
  
    // 3. è§£å¯†è¯ä¹¦å†…å®¹
    for (const cert of certificates) {
      const decryptedCert = decryptCertificate(cert.encrypt_certificate);
    
      // 4. ä¿å­˜è¯ä¹¦åˆ°æœ¬åœ°
      const filename = `wechatpay_${cert.serial_no}.pem`;
      fs.writeFileSync(filename, decryptedCert);
    
      console.log(`è¯ä¹¦å·²ä¿å­˜: ${filename}`);
      console.log(`åºåˆ—å·: ${cert.serial_no}`);
      console.log(`ç”Ÿæ•ˆæ—¶é—´: ${cert.effective_time}`);
      console.log(`è¿‡æœŸæ—¶é—´: ${cert.expire_time}`);
    
      // 5. ç¼“å­˜åˆ°å†…å­˜
      platformCertCache.set(cert.serial_no, {
        publicKey: decryptedCert,
        expireTime: new Date(cert.expire_time)
      });
    }
  
    return certificates;
  } catch (error) {
    console.error('è·å–å¹³å°è¯ä¹¦å¤±è´¥:', error.response?.data || error.message);
    throw error;
  }
}

// è§£å¯†è¯ä¹¦å†…å®¹
function decryptCertificate(encryptCert) {
  const { algorithm, nonce, associated_data, ciphertext } = encryptCert;

  if (algorithm !== 'AEAD_AES_256_GCM') {
    throw new Error(`ä¸æ”¯æŒçš„åŠ å¯†ç®—æ³•: ${algorithm}`);
  }

  // ä½¿ç”¨APIv3å¯†é’¥è§£å¯†
  const decipher = crypto.createDecipheriv(
    'aes-256-gcm',
    config.v3Key,
    nonce
  );

  decipher.setAuthTag(Buffer.from(ciphertext.slice(-16), 'base64'));
  decipher.setAAD(Buffer.from(associated_data));

  let decrypted = decipher.update(ciphertext.slice(0, -16), 'base64', 'utf8');
  decrypted += decipher.final('utf8');

  return decrypted;
}

// å†…å­˜ç¼“å­˜
const platformCertCache = new Map();

// è·å–æœ‰æ•ˆçš„å¹³å°å…¬é’¥
function getPlatformPublicKey(serialNo = null) {
  if (serialNo) {
    const cert = platformCertCache.get(serialNo);
    if (cert && cert.expireTime > new Date()) {
      return cert.publicKey;
    }
  }

  // è¿”å›æœ€æ–°çš„æœ‰æ•ˆè¯ä¹¦
  const validCerts = Array.from(platformCertCache.values())
    .filter(cert => cert.expireTime > new Date())
    .sort((a, b) => b.expireTime - a.expireTime);

  if (validCerts.length === 0) {
    throw new Error('æ²¡æœ‰æœ‰æ•ˆçš„å¹³å°è¯ä¹¦ï¼Œè¯·é‡æ–°ä¸‹è½½');
  }

  return validCerts[0].publicKey;
}
```

---

### è¯ä¹¦ç®¡ç†è‡ªåŠ¨åŒ–

**å®Œæ•´çš„è¯ä¹¦ç®¡ç†ç³»ç»Ÿ**ï¼š

```javascript
class CertificateManager {
  constructor() {
    this.certCache = new Map();
    this.updateInterval = null;
  }

  // åˆå§‹åŒ–è¯ä¹¦ç®¡ç†å™¨
  async initialize() {
    console.log('åˆå§‹åŒ–è¯ä¹¦ç®¡ç†å™¨...');
  
    // 1. åŠ è½½æœ¬åœ°è¯ä¹¦ï¼ˆå¦‚æœæœ‰ï¼‰
    await this.loadLocalCertificates();
  
    // 2. æ£€æŸ¥å¹¶æ›´æ–°è¯ä¹¦
    await this.updateCertificates();
  
    // 3. å¯åŠ¨å®šæ—¶ä»»åŠ¡ï¼ˆæ¯12å°æ—¶æ£€æŸ¥ä¸€æ¬¡ï¼‰
    this.startAutoUpdate();
  
    console.log('è¯ä¹¦ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ');
  }

  // åŠ è½½æœ¬åœ°ä¿å­˜çš„è¯ä¹¦
  async loadLocalCertificates() {
    try {
      const files = fs.readdirSync('./certs');
      const certFiles = files.filter(f => f.startsWith('wechatpay_') && f.endsWith('.pem'));
    
      for (const file of certFiles) {
        const serialNo = file.replace('wechatpay_', '').replace('.pem', '');
        const content = fs.readFileSync(`./certs/${file}`, 'utf8');
      
        // æå–è¯ä¹¦æœ‰æ•ˆæœŸ
        const cert = crypto.X509Certificate(content);
        const expireTime = new Date(cert.validTo);
      
        this.certCache.set(serialNo, {
          publicKey: content,
          expireTime
        });
      
        console.log(`åŠ è½½è¯ä¹¦: ${serialNo}, è¿‡æœŸæ—¶é—´: ${expireTime.toISOString()}`);
      }
    } catch (error) {
      console.log('æ²¡æœ‰æœ¬åœ°è¯ä¹¦ï¼Œå°†ä»APIè·å–');
    }
  }

  // æ›´æ–°è¯ä¹¦
  async updateCertificates() {
    try {
      const certificates = await downloadPlatformCertificate();
    
      // æ¸…ç†è¿‡æœŸè¯ä¹¦æ–‡ä»¶
      this.cleanExpiredCertificates();
    
      return certificates;
    } catch (error) {
      console.error('æ›´æ–°è¯ä¹¦å¤±è´¥:', error);
    
      // å¦‚æœæœ‰ç¼“å­˜ï¼Œç»§ç»­ä½¿ç”¨
      if (this.certCache.size > 0) {
        console.log('ä½¿ç”¨ç¼“å­˜çš„è¯ä¹¦ç»§ç»­è¿è¡Œ');
      } else {
        throw new Error('æ— å¯ç”¨è¯ä¹¦ï¼Œç³»ç»Ÿæ— æ³•å¯åŠ¨');
      }
    }
  }

  // æ¸…ç†è¿‡æœŸè¯ä¹¦
  cleanExpiredCertificates() {
    const now = new Date();
  
    for (const [serialNo, cert] of this.certCache.entries()) {
      if (cert.expireTime < now) {
        console.log(`æ¸…ç†è¿‡æœŸè¯ä¹¦: ${serialNo}`);
        this.certCache.delete(serialNo);
      
        // åˆ é™¤æ–‡ä»¶
        try {
          fs.unlinkSync(`./certs/wechatpay_${serialNo}.pem`);
        } catch (e) {
          console.error(`åˆ é™¤è¯ä¹¦æ–‡ä»¶å¤±è´¥: ${e.message}`);
        }
      }
    }
  }

  // å¯åŠ¨è‡ªåŠ¨æ›´æ–°
  startAutoUpdate() {
    // æ¯12å°æ—¶æ£€æŸ¥ä¸€æ¬¡
    this.updateInterval = setInterval(async () => {
      console.log('å®šæ—¶æ£€æŸ¥è¯ä¹¦æ›´æ–°...');
      await this.updateCertificates();
    }, 12 * 60 * 60 * 1000);
  }

  // è·å–è¯ä¹¦
  getCertificate(serialNo = null) {
    return getPlatformPublicKey(serialNo);
  }

  // åœæ­¢ç®¡ç†å™¨
  stop() {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
      console.log('è¯ä¹¦ç®¡ç†å™¨å·²åœæ­¢');
    }
  }
}

// å…¨å±€å•ä¾‹
const certManager = new CertificateManager();

// åœ¨åº”ç”¨å¯åŠ¨æ—¶åˆå§‹åŒ–
async function startApplication() {
  await certManager.initialize();

  // å¯åŠ¨ExpressæœåŠ¡å™¨
  app.listen(3000, () => {
    console.log('æœåŠ¡å™¨å¯åŠ¨æˆåŠŸ');
  });
}

// ä¼˜é›…å…³é—­
process.on('SIGTERM', () => {
  certManager.stop();
  process.exit(0);
});

startApplication();
```

**è¯ä¹¦æ›´æ–°ç›‘æ§**ï¼š
```javascript
// è¯ä¹¦é¢„è­¦ç³»ç»Ÿ
class CertificateMonitor {
  // æ£€æŸ¥è¯ä¹¦æ˜¯å¦å³å°†è¿‡æœŸ
  static checkExpiration() {
    const warningDays = 30; // 30å¤©é¢„è­¦
    const now = new Date();
  
    for (const [serialNo, cert] of certManager.certCache.entries()) {
      const daysUntilExpire = Math.floor(
        (cert.expireTime - now) / (1000 * 60 * 60 * 24)
      );
    
      if (daysUntilExpire <= warningDays) {
        console.warn(`âš ï¸  è¯ä¹¦${serialNo}å°†åœ¨${daysUntilExpire}å¤©åè¿‡æœŸ`);
      
        // å‘é€å‘Šè­¦
        this.sendAlert({
          type: 'CERT_EXPIRING',
          serialNo,
          daysLeft: daysUntilExpire,
          expireTime: cert.expireTime
        });
      }
    }
  }

  // å‘é€å‘Šè­¦ï¼ˆç¤ºä¾‹ï¼‰
  static async sendAlert(alert) {
    // å¯ä»¥å‘é€é‚®ä»¶ã€é’‰é’‰ã€ä¼ä¸šå¾®ä¿¡ç­‰
    console.log('å‘é€å‘Šè­¦:', JSON.stringify(alert, null, 2));
  
    // ç¤ºä¾‹ï¼šå‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    try {
      await axios.post('https://monitor.example.com/alert', alert);
    } catch (error) {
      console.error('å‘Šè­¦å‘é€å¤±è´¥:', error.message);
    }
  }
}

// æ¯å¤©æ£€æŸ¥ä¸€æ¬¡
setInterval(() => {
  CertificateMonitor.checkExpiration();
}, 24 * 60 * 60 * 1000);
```

---

## æ•æ„Ÿä¿¡æ¯åŠ å¯†å®æˆ˜

### åŠ å¯†åœºæ™¯ä¸ç®—æ³•

**éœ€è¦åŠ å¯†çš„æ•æ„Ÿä¿¡æ¯**ï¼š
- ç”¨æˆ·å§“å
- èº«ä»½è¯å·
- é“¶è¡Œå¡å·
- æ‰‹æœºå·ç 
- åœ°å€ä¿¡æ¯

**åŠ å¯†ç®—æ³•**ï¼šAES-256-GCMï¼ˆGalois/Counter Modeï¼‰

```mermaid
graph LR
    A[æ˜æ–‡æ•°æ®] --> B[è·å–å¹³å°å…¬é’¥]
    B --> C[ç”ŸæˆAESå¯†é’¥]
    C --> D[AES-GCMåŠ å¯†]
    D --> E[Base64ç¼–ç ]
    E --> F[å‘é€åˆ°å¾®ä¿¡]
  
    G[å¾®ä¿¡æ¥æ”¶] --> H[Base64è§£ç ]
    H --> I[ä½¿ç”¨å¹³å°ç§é’¥è§£å¯†]
    I --> J[è·å–æ˜æ–‡]
```

### åŠ å¯†å®ç°ä»£ç 

```javascript
const crypto = require('crypto');

// æ•æ„Ÿä¿¡æ¯åŠ å¯†
function encryptSensitiveData(plaintext) {
  // 1. è·å–å¹³å°è¯ä¹¦å…¬é’¥
  const publicKey = certManager.getCertificate();

  // 2. ç”ŸæˆéšæœºAESå¯†é’¥
  const aesKey = crypto.randomBytes(32); // 256ä½

  // 3. ç”ŸæˆéšæœºIV
  const iv = crypto.randomBytes(12); // GCMæ¨¡å¼æ¨è12å­—èŠ‚

  // 4. AES-GCMåŠ å¯†
  const cipher = crypto.createCipheriv('aes-256-gcm', aesKey, iv);
  let encrypted = cipher.update(plaintext, 'utf8', 'base64');
  encrypted += cipher.final('base64');

  // 5. è·å–è®¤è¯æ ‡ç­¾
  const authTag = cipher.getAuthTag();

  // 6. ä½¿ç”¨å¹³å°å…¬é’¥åŠ å¯†AESå¯†é’¥
  const encryptedKey = crypto.publicEncrypt(
    {
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,
      oaepHash: 'sha256'
    },
    aesKey
  );

  // 7. è¿”å›åŠ å¯†ç»“æœ
  return {
    algorithm: 'AEAD_AES_256_GCM',
    ciphertext: Buffer.concat([
      Buffer.from(encrypted, 'base64'),
      authTag
    ]).toString('base64'),
    nonce: iv.toString('base64'),
    associated_data: '', // å¯é€‰çš„å…³è”æ•°æ®
    encrypted_key: encryptedKey.toString('base64')
  };
}

// ä½¿ç”¨ç¤ºä¾‹
const sensitiveInfo = {
  name: 'å¼ ä¸‰',
  id_card_number: '110101199001011234',
  mobile: '13800138000'
};

const encrypted = encryptSensitiveData(JSON.stringify(sensitiveInfo));
console.log('åŠ å¯†ç»“æœ:', encrypted);

// åœ¨APIè¯·æ±‚ä¸­ä½¿ç”¨
const requestData = {
  appid: config.appId,
  mchid: config.mchId,
  payer_info: encrypted, // æ•æ„Ÿä¿¡æ¯å·²åŠ å¯†
  // ... å…¶ä»–å‚æ•°
};
```

### è§£å¯†æµç¨‹

```javascript
// è§£å¯†å›è°ƒä¸­çš„æ•æ„Ÿä¿¡æ¯
function decryptCallbackResource(resource) {
  const { ciphertext, associated_data, nonce } = resource;

  // ä½¿ç”¨APIv3å¯†é’¥è§£å¯†
  const decipher = crypto.createDecipheriv(
    'aes-256-gcm',
    config.v3Key,
    Buffer.from(nonce, 'base64')
  );

  // è®¾ç½®å…³è”æ•°æ®
  if (associated_data) {
    decipher.setAAD(Buffer.from(associated_data));
  }

  // æå–è®¤è¯æ ‡ç­¾ï¼ˆæœ€å16å­—èŠ‚ï¼‰
  const ciphertextBuffer = Buffer.from(ciphertext, 'base64');
  const authTag = ciphertextBuffer.slice(-16);
  const encryptedData = ciphertextBuffer.slice(0, -16);

  decipher.setAuthTag(authTag);

  // è§£å¯†
  let decrypted = decipher.update(encryptedData, null, 'utf8');
  decrypted += decipher.final('utf8');

  return JSON.parse(decrypted);
}
```

---

## å›è°ƒæœºåˆ¶ä¸éªŒç­¾

### å›è°ƒé€šçŸ¥æœºåˆ¶

å¾®ä¿¡æ”¯ä»˜é€šè¿‡HTTP POSTæ–¹å¼å‘é€æ”¯ä»˜ç»“æœé€šçŸ¥ï¼š

```mermaid
sequenceDiagram
    participant WxPay as å¾®ä¿¡æ”¯ä»˜
    participant Merchant as å•†æˆ·æœåŠ¡å™¨
  
    Note over WxPay: æ”¯ä»˜å®Œæˆ
  
    loop é‡è¯•æœºåˆ¶
        WxPay->>Merchant: POST /notify<br/>Headers: ç­¾åä¿¡æ¯<br/>Body: åŠ å¯†æ•°æ®
      
        alt å¤„ç†æˆåŠŸ
            Merchant->>Merchant: 1. éªŒç­¾<br/>2. è§£å¯†<br/>3. ä¸šåŠ¡å¤„ç†
            Merchant->>WxPay: 200 OK<br/>{"code":"SUCCESS"}
            Note over WxPay: åœæ­¢é‡è¯•
        else å¤„ç†å¤±è´¥æˆ–è¶…æ—¶
            Merchant->>WxPay: é200æˆ–è¶…æ—¶
            Note over WxPay: ç­‰å¾…åé‡è¯•<br/>15s/15s/30s/3m/10m/20m/30m...
        end
    end
  
    Note over WxPay: æœ€å¤šé€šçŸ¥10æ¬¡
```

**é‡è¯•æ—¶é—´é—´éš”**ï¼š
```
15ç§’ â†’ 15ç§’ â†’ 30ç§’ â†’ 3åˆ†é’Ÿ â†’ 10åˆ†é’Ÿ â†’ 20åˆ†é’Ÿ â†’ 30åˆ†é’Ÿ â†’ 30åˆ†é’Ÿ â†’ 30åˆ†é’Ÿ â†’ 30åˆ†é’Ÿ
```

### éªŒç­¾æµç¨‹å®ç°

**å®Œæ•´çš„å›è°ƒå¤„ç†å®ç°**ï¼š
```javascript
const express = require('express');
const crypto = require('crypto');

// å›è°ƒè·¯ç”±
app.post('/api/pay/notify', async (req, res) => {
  const startTime = Date.now();

  try {
    // ============= ç¬¬ä¸€æ­¥ï¼šéªŒè¯ç­¾å =============
    const signature = req.headers['wechatpay-signature'];
    const timestamp = req.headers['wechatpay-timestamp'];
    const nonce = req.headers['wechatpay-nonce'];
    const serialNo = req.headers['wechatpay-serial'];
    const body = JSON.stringify(req.body);
  
    console.log(`[å›è°ƒ] æ”¶åˆ°é€šçŸ¥, å•†æˆ·è®¢å•å·: ${req.body.out_trade_no || 'unknown'}`);
  
    // é˜²é‡æ”¾æ”»å‡»
    const now = Math.floor(Date.now() / 1000);
    if (Math.abs(now - timestamp) > 300) {
      console.error('[å›è°ƒ] è¯·æ±‚æ—¶é—´æˆ³è¿‡æœŸ');
      return res.status(401).json({ code: 'FAIL', message: 'è¯·æ±‚å·²è¿‡æœŸ' });
    }
  
    // éªŒç­¾
    const isValid = verifyNotifySignature(timestamp, nonce, body, signature, serialNo);
    if (!isValid) {
      console.error('[å›è°ƒ] ç­¾åéªŒè¯å¤±è´¥');
      return res.status(401).json({ code: 'FAIL', message: 'ç­¾åéªŒè¯å¤±è´¥' });
    }
  
    console.log('[å›è°ƒ] ç­¾åéªŒè¯é€šè¿‡');
  
    // ============= ç¬¬äºŒæ­¥ï¼šè§£å¯†æ•°æ® =============
    const resource = req.body.resource;
    const decryptedData = decryptCallbackResource(resource);
    const paymentData = JSON.parse(decryptedData);
  
    console.log('[å›è°ƒ] è§£å¯†æ•°æ®:', {
      out_trade_no: paymentData.out_trade_no,
      transaction_id: paymentData.transaction_id,
      trade_state: paymentData.trade_state,
      amount: paymentData.amount
    });
  
    // ============= ç¬¬ä¸‰æ­¥ï¼šä¸šåŠ¡å¤„ç† =============
    const result = await processPaymentNot
    ç»§ç»­ç”Ÿæˆæ–‡æ¡£2çš„å‰©ä½™å†…å®¹...

---

```javascript
    // ============= ç¬¬ä¸‰æ­¥ï¼šä¸šåŠ¡å¤„ç† =============
    const result = await processPaymentNotification(paymentData);
  
    if (!result.success) {
      console.error('[å›è°ƒ] ä¸šåŠ¡å¤„ç†å¤±è´¥:', result.error);
      return res.status(500).json({ code: 'FAIL', message: result.error });
    }
  
    // ============= ç¬¬å››æ­¥ï¼šè¿”å›æˆåŠŸåº”ç­” =============
    const processingTime = Date.now() - startTime;
    console.log(`[å›è°ƒ] å¤„ç†å®Œæˆï¼Œè€—æ—¶: ${processingTime}ms`);
  
    res.json({ code: 'SUCCESS', message: 'æˆåŠŸ' });
  
  } catch (error) {
    console.error('[å›è°ƒ] å¼‚å¸¸:', error);
    res.status(500).json({ code: 'FAIL', message: error.message });
  }
});

// ä¸šåŠ¡å¤„ç†å‡½æ•°
async function processPaymentNotification(paymentData) {
  const {
    out_trade_no,
    transaction_id,
    trade_state,
    trade_state_desc,
    amount,
    payer,
    success_time
  } = paymentData;

  try {
    // 1. æŸ¥è¯¢è®¢å•
    const order = await db.orders.findOne({ outTradeNo: out_trade_no });
  
    if (!order) {
      return { success: false, error: 'è®¢å•ä¸å­˜åœ¨' };
    }
  
    // 2. å¹‚ç­‰æ€§æ£€æŸ¥
    if (order.status === 'PAID') {
      console.log('[å›è°ƒ] è®¢å•å·²å¤„ç†ï¼Œè¿”å›æˆåŠŸï¼ˆå¹‚ç­‰ï¼‰');
      return { success: true, message: 'è®¢å•å·²å¤„ç†' };
    }
  
    // 3. éªŒè¯äº¤æ˜“çŠ¶æ€
    if (trade_state !== 'SUCCESS') {
      console.log(`[å›è°ƒ] äº¤æ˜“çŠ¶æ€å¼‚å¸¸: ${trade_state} - ${trade_state_desc}`);
    
      // æ›´æ–°è®¢å•çŠ¶æ€ä¸ºå¤±è´¥
      await db.orders.update(
        { outTradeNo: out_trade_no },
        {
          status: 'FAILED',
          failReason: trade_state_desc,
          updatedAt: new Date()
        }
      );
    
      return { success: true, message: 'äº¤æ˜“æœªæˆåŠŸ' };
    }
  
    // 4. éªŒè¯é‡‘é¢
    if (order.amount !== amount.total) {
      console.error('[å›è°ƒ] é‡‘é¢ä¸åŒ¹é…', {
        expected: order.amount,
        received: amount.total
      });
    
      // è®°å½•å¼‚å¸¸è®¢å•
      await db.abnormalOrders.create({
        outTradeNo: out_trade_no,
        reason: 'AMOUNT_MISMATCH',
        expectedAmount: order.amount,
        receivedAmount: amount.total,
        createdAt: new Date()
      });
    
      return { success: false, error: 'é‡‘é¢ä¸åŒ¹é…' };
    }
  
    // 5. ä½¿ç”¨äº‹åŠ¡æ›´æ–°è®¢å•çŠ¶æ€
    await db.transaction(async (trx) => {
      // æ›´æ–°è®¢å•
      await db.orders.update(
        { outTradeNo: out_trade_no },
        {
          status: 'PAID',
          transactionId: transaction_id,
          payerOpenid: payer.openid,
          paidAt: new Date(success_time),
          updatedAt: new Date()
        },
        { transaction: trx }
      );
    
      // 6. æ‰§è¡Œä¸šåŠ¡é€»è¾‘
      await executeBusinessLogic(order, paymentData, trx);
    });
  
    console.log('[å›è°ƒ] è®¢å•å¤„ç†æˆåŠŸ:', out_trade_no);
  
    return { success: true };
  
  } catch (error) {
    console.error('[å›è°ƒ] ä¸šåŠ¡å¤„ç†å¼‚å¸¸:', error);
    return { success: false, error: error.message };
  }
}

// æ‰§è¡Œä¸šåŠ¡é€»è¾‘
async function executeBusinessLogic(order, paymentData, trx) {
  // 1. å¢åŠ ç”¨æˆ·ç§¯åˆ†
  if (order.userId) {
    const points = Math.floor(order.amount / 100); // 1å…ƒ=1ç§¯åˆ†
    await db.users.increment(
      { id: order.userId },
      { points },
      { transaction: trx }
    );
  
    console.log(`[ä¸šåŠ¡] ç”¨æˆ·${order.userId}å¢åŠ ${points}ç§¯åˆ†`);
  }

  // 2. è®°å½•æ”¯ä»˜æ—¥å¿—
  await db.paymentLogs.create({
    outTradeNo: order.outTradeNo,
    transactionId: paymentData.transaction_id,
    amount: order.amount,
    userId: order.userId,
    createdAt: new Date()
  }, { transaction: trx });

  // 3. å‘é€é€šçŸ¥
  await sendPaymentSuccessNotification(order, paymentData);

  // 4. è™šæ‹Ÿå•†å“è‡ªåŠ¨å‘è´§
  if (order.productType === 'VIRTUAL') {
    await deliverVirtualProduct(order, trx);
  }

  // 5. è§¦å‘åç»­æµç¨‹ï¼ˆå¼‚æ­¥ï¼‰
  setImmediate(async () => {
    try {
      // å‘é€é‚®ä»¶
      await sendEmailNotification(order);
    
      // æ›´æ–°ç»Ÿè®¡æ•°æ®
      await updateStatistics(order);
    
      // è§¦å‘ç¬¬ä¸‰æ–¹ç³»ç»Ÿ
      await notifyThirdPartySystem(order);
    } catch (error) {
      console.error('[ä¸šåŠ¡] å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œå¤±è´¥:', error);
    }
  });
}

// å‘é€æ”¯ä»˜æˆåŠŸé€šçŸ¥
async function sendPaymentSuccessNotification(order, paymentData) {
  // å°ç¨‹åºè®¢é˜…æ¶ˆæ¯
  if (order.platform === 'miniprogram') {
    await sendMiniprogramSubscribeMessage({
      touser: order.userId,
      template_id: 'PAYMENT_SUCCESS_TEMPLATE',
      page: `/pages/order/detail?id=${order.outTradeNo}`,
      data: {
        character_string1: { value: order.outTradeNo },
        amount2: { value: `${(order.amount / 100).toFixed(2)}å…ƒ` },
        time3: { value: paymentData.success_time }
      }
    });
  }

  // çŸ­ä¿¡é€šçŸ¥ï¼ˆå¯é€‰ï¼‰
  if (order.userMobile) {
    await sendSMS({
      mobile: order.userMobile,
      template: 'PAYMENT_SUCCESS',
      params: {
        orderNo: order.outTradeNo,
        amount: (order.amount / 100).toFixed(2)
      }
    });
  }
}
```

---

### å›è°ƒå¤„ç†æœ€ä½³å®è·µ

**1. å¿«é€Ÿå“åº”åŸåˆ™**

```javascript
// âŒ é”™è¯¯åšæ³•ï¼šåŒæ­¥æ‰§è¡Œè€—æ—¶æ“ä½œ
app.post('/api/pay/notify', async (req, res) => {
  // éªŒç­¾
  // è§£å¯†
  // æ›´æ–°è®¢å•
  await sendEmail(); // è€—æ—¶æ“ä½œ
  await generateInvoice(); // è€—æ—¶æ“ä½œ
  await syncToERP(); // è€—æ—¶æ“ä½œ

  res.json({ code: 'SUCCESS' }); // å¯èƒ½è¶…è¿‡5ç§’
});

// âœ… æ­£ç¡®åšæ³•ï¼šå¼‚æ­¥å¤„ç†
app.post('/api/pay/notify', async (req, res) => {
  // éªŒç­¾
  // è§£å¯†
  // æ›´æ–°è®¢å•

  // ç«‹å³è¿”å›
  res.json({ code: 'SUCCESS' });

  // å¼‚æ­¥æ‰§è¡Œè€—æ—¶ä»»åŠ¡
  setImmediate(async () => {
    await sendEmail();
    await generateInvoice();
    await syncToERP();
  });
});
```

**2. å¹‚ç­‰æ€§è®¾è®¡**

```javascript
// ä½¿ç”¨æ•°æ®åº“å”¯ä¸€ç´¢å¼•ä¿è¯å¹‚ç­‰
// migrations/create_orders.js
await db.schema.createTable('orders', (table) => {
  table.increments('id');
  table.string('out_trade_no').unique(); // å”¯ä¸€ç´¢å¼•
  table.string('transaction_id').unique(); // å”¯ä¸€ç´¢å¼•
  table.enum('status', ['PENDING', 'PAID', 'FAILED', 'CLOSED']);
  // ... å…¶ä»–å­—æ®µ
});

// ä¸šåŠ¡ä»£ç ä¸­æ£€æŸ¥çŠ¶æ€
async function updateOrderStatus(outTradeNo, newStatus) {
  const result = await db.orders.update(
    {
      outTradeNo,
      status: 'PENDING' // åªæ›´æ–°å¾…æ”¯ä»˜çŠ¶æ€çš„è®¢å•
    },
    { status: newStatus }
  );

  if (result.affectedRows === 0) {
    console.log('è®¢å•å·²å¤„ç†æˆ–ä¸å­˜åœ¨ï¼Œè·³è¿‡');
    return false;
  }

  return true;
}
```

**3. å¼‚å¸¸å¤„ç†**

```javascript
// è®°å½•æ‰€æœ‰å›è°ƒè¯·æ±‚ï¼ˆåŒ…æ‹¬å¤±è´¥çš„ï¼‰
app.post('/api/pay/notify', async (req, res) => {
  const notifyLog = {
    headers: req.headers,
    body: req.body,
    receivedAt: new Date()
  };

  try {
    // ä¿å­˜åŸå§‹è¯·æ±‚
    await db.notifyLogs.create(notifyLog);
  
    // å¤„ç†é€»è¾‘
    // ...
  
    // æ›´æ–°æ—¥å¿—çŠ¶æ€
    await db.notifyLogs.update(
      { id: notifyLog.id },
      { status: 'SUCCESS', processedAt: new Date() }
    );
  
    res.json({ code: 'SUCCESS' });
  
  } catch (error) {
    // è®°å½•é”™è¯¯
    await db.notifyLogs.update(
      { id: notifyLog.id },
      {
        status: 'FAILED',
        error: error.message,
        processedAt: new Date()
      }
    );
  
    // å‘é€å‘Šè­¦
    await sendAlert({
      type: 'NOTIFY_PROCESS_FAILED',
      error: error.message,
      orderNo: req.body.out_trade_no
    });
  
    res.status(500).json({ code: 'FAIL', message: error.message });
  }
});
```

---

### é‡è¯•æœºåˆ¶ä¸å¹‚ç­‰è®¾è®¡

**å¾®ä¿¡æ”¯ä»˜é‡è¯•ç­–ç•¥**ï¼š

```mermaid
graph TD
    A[æ”¯ä»˜å®Œæˆ] --> B[å‘é€ç¬¬1æ¬¡é€šçŸ¥]
    B --> C{å•†æˆ·è¿”å›200<br/>ä¸”code=SUCCESS?}
    C -->|æ˜¯| D[åœæ­¢é‡è¯•]
    C -->|å¦| E[ç­‰å¾…15ç§’]
    E --> F[å‘é€ç¬¬2æ¬¡é€šçŸ¥]
    F --> G{æˆåŠŸ?}
    G -->|æ˜¯| D
    G -->|å¦| H[ç­‰å¾…15ç§’]
    H --> I[å‘é€ç¬¬3æ¬¡é€šçŸ¥]
    I --> J{æˆåŠŸ?}
    J -->|æ˜¯| D
    J -->|å¦| K[ç­‰å¾…30ç§’]
    K --> L[ç¬¬4æ¬¡...]
  
    style D fill:#90EE90
    style C fill:#FFE4B5
    style G fill:#FFE4B5
    style J fill:#FFE4B5
```

**å•†æˆ·ä¾§å¹‚ç­‰æ€§ä¿è¯**ï¼š

```javascript
// æ–¹æ¡ˆ1ï¼šæ•°æ®åº“å”¯ä¸€çº¦æŸ + çŠ¶æ€æœº
class OrderStateMachine {
  static async transition(outTradeNo, fromStatus, toStatus) {
    const result = await db.orders.update(
      {
        outTradeNo,
        status: fromStatus
      },
      {
        status: toStatus,
        updatedAt: new Date()
      }
    );
  
    return result.affectedRows > 0;
  }
}

// ä½¿ç”¨
const success = await OrderStateMachine.transition(
  'ORDER123',
  'PENDING',  // åªæœ‰å¾…æ”¯ä»˜çŠ¶æ€æ‰èƒ½è½¬ä¸ºå·²æ”¯ä»˜
  'PAID'
);

if (!success) {
  console.log('è®¢å•çŠ¶æ€å·²å˜æ›´ï¼Œè·³è¿‡å¤„ç†');
}

// æ–¹æ¡ˆ2ï¼šåˆ†å¸ƒå¼é”
const Redis = require('ioredis');
const redis = new Redis();

async function processWithLock(outTradeNo, callback) {
  const lockKey = `order:lock:${outTradeNo}`;
  const lockValue = Date.now().toString();

  // å°è¯•è·å–é”ï¼ˆ10ç§’è¿‡æœŸï¼‰
  const acquired = await redis.set(lockKey, lockValue, 'EX', 10, 'NX');

  if (!acquired) {
    console.log('å…¶ä»–è¿›ç¨‹æ­£åœ¨å¤„ç†ï¼Œè·³è¿‡');
    return { success: true, message: 'é‡å¤è¯·æ±‚' };
  }

  try {
    // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
    const result = await callback();
    return result;
  } finally {
    // é‡Šæ”¾é”ï¼ˆæ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±çš„é”ï¼‰
    const currentValue = await redis.get(lockKey);
    if (currentValue === lockValue) {
      await redis.del(lockKey);
    }
  }
}

// åœ¨å›è°ƒå¤„ç†ä¸­ä½¿ç”¨
app.post('/api/pay/notify', async (req, res) => {
  const { out_trade_no } = req.body;

  const result = await processWithLock(out_trade_no, async () => {
    // éªŒç­¾ã€è§£å¯†ã€ä¸šåŠ¡å¤„ç†...
    return await processPaymentNotification(paymentData);
  });

  res.json({ code: 'SUCCESS' });
});
```

---

## å®‰å…¨æœºåˆ¶ç»¼åˆåº”ç”¨

### é˜²é‡æ”¾æ”»å‡»

**åŸç†**ï¼šæ”»å‡»è€…æˆªè·åˆæ³•è¯·æ±‚åï¼Œå¤šæ¬¡é‡æ”¾ä»¥è¾¾åˆ°é‡å¤æ‰£æ¬¾ç­‰ç›®çš„ã€‚

**é˜²æŠ¤æªæ–½**ï¼š

```javascript
// 1. æ—¶é—´æˆ³éªŒè¯ï¼ˆ5åˆ†é’Ÿæœ‰æ•ˆæœŸï¼‰
function validateTimestamp(timestamp) {
  const now = Math.floor(Date.now() / 1000);
  const diff = Math.abs(now - timestamp);

  if (diff > 300) { // 5åˆ†é’Ÿ
    throw new Error('è¯·æ±‚å·²è¿‡æœŸ');
  }
}

// 2. éšæœºæ•°å»é‡ï¼ˆRedisï¼‰
const requestCache = new Redis();

async function validateNonce(nonce, timestamp) {
  const key = `nonce:${nonce}`;

  // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
  const exists = await requestCache.exists(key);
  if (exists) {
    throw new Error('é‡å¤è¯·æ±‚');
  }

  // ä¿å­˜éšæœºæ•°ï¼ˆè¿‡æœŸæ—¶é—´=5åˆ†é’Ÿ+5åˆ†é’Ÿå®¹å·®ï¼‰
  await requestCache.set(key, '1', 'EX', 600);
}

// ç»¼åˆä½¿ç”¨
app.post('/api/pay/notify', async (req, res) => {
  const timestamp = req.headers['wechatpay-timestamp'];
  const nonce = req.headers['wechatpay-nonce'];

  try {
    validateTimestamp(timestamp);
    await validateNonce(nonce, timestamp);
  
    // ç»§ç»­å¤„ç†...
  } catch (error) {
    return res.status(401).json({ code: 'FAIL', message: error.message });
  }
});
```

---

### é˜²ç¯¡æ”¹ä¿æŠ¤

```mermaid
graph TD
    A[åŸå§‹è¯·æ±‚] --> B[è®¡ç®—ç­¾å]
    B --> C[é™„åŠ åˆ°è¯·æ±‚ä¸­]
    C --> D[å‘é€åˆ°æœåŠ¡å™¨]
  
    D --> E[æå–ç­¾å]
    E --> F[é‡æ–°è®¡ç®—ç­¾å]
    F --> G{ç­¾åä¸€è‡´?}
  
    G -->|æ˜¯| H[æ•°æ®æœªè¢«ç¯¡æ”¹<br/>ç»§ç»­å¤„ç†]
    G -->|å¦| I[æ•°æ®è¢«ç¯¡æ”¹<br/>æ‹’ç»è¯·æ±‚]
  
    style H fill:#90EE90
    style I fill:#FFB6C1
```

**å®Œæ•´æ ¡éªŒæµç¨‹**ï¼š

```javascript
// è¯·æ±‚å®Œæ•´æ€§æ ¡éªŒ
function validateRequestIntegrity(req) {
  // 1. ç­¾åéªŒè¯
  const signatureValid = verifySignature(req);
  if (!signatureValid) {
    throw new Error('ç­¾åéªŒè¯å¤±è´¥');
  }

  // 2. æ—¶é—´æˆ³éªŒè¯
  const timestamp = req.headers['wechatpay-timestamp'];
  validateTimestamp(timestamp);

  // 3. éšæœºæ•°éªŒè¯
  const nonce = req.headers['wechatpay-nonce'];
  await validateNonce(nonce, timestamp);

  // 4. å†…å®¹hashéªŒè¯ï¼ˆå¯é€‰ï¼‰
  const contentHash = crypto
    .createHash('sha256')
    .update(JSON.stringify(req.body))
    .digest('hex');

  console.log('è¯·æ±‚æ ¡éªŒé€šè¿‡', {
    timestamp,
    nonce: nonce.slice(0, 8) + '...',
    contentHash: contentHash.slice(0, 16) + '...'
  });
}
```

---

### å¯†é’¥ç®¡ç†ç­–ç•¥

**å®Œæ•´çš„å¯†é’¥ç®¡ç†æ–¹æ¡ˆ**ï¼š

```javascript
// å¯†é’¥é…ç½®ç®¡ç†
class KeyManager {
  constructor() {
    this.keys = new Map();
    this.loadKeys();
  }

  // åŠ è½½å¯†é’¥
  loadKeys() {
    // ä»ç¯å¢ƒå˜é‡åŠ è½½
    this.keys.set('v3Key', process.env.WECHAT_V3_KEY);
    this.keys.set('v2Key', process.env.WECHAT_V2_KEY);
  
    // ä»å¯†é’¥ç®¡ç†æœåŠ¡åŠ è½½ï¼ˆæ¨èï¼‰
    // this.keys = await KeyManagementService.getKeys();
  }

  // è·å–å¯†é’¥
  getKey(type) {
    const key = this.keys.get(type);
    if (!key) {
      throw new Error(`å¯†é’¥${type}æœªé…ç½®`);
    }
    return key;
  }

  // è½®æ¢å¯†é’¥
  async rotateKey(type, newKey) {
    // 1. éªŒè¯æ–°å¯†é’¥æ ¼å¼
    if (newKey.length !== 32) {
      throw new Error('å¯†é’¥é•¿åº¦å¿…é¡»ä¸º32ä½');
    }
  
    // 2. ä¿å­˜æ—§å¯†é’¥ï¼ˆä¿ç•™24å°æ—¶ç”¨äºéªŒè¯æ—§è¯·æ±‚ï¼‰
    const oldKey = this.keys.get(type);
    this.keys.set(`${type}_old`, oldKey);
  
    // 3. æ›´æ–°ä¸ºæ–°å¯†é’¥
    this.keys.set(type, newKey);
  
    // 4. æŒä¹…åŒ–åˆ°é…ç½®ä¸­å¿ƒ
    await ConfigService.update({
      [`wechat.${type}`]: newKey
    });
  
    // 5. 24å°æ—¶åæ¸…ç†æ—§å¯†é’¥
    setTimeout(() => {
      this.keys.delete(`${type}_old`);
    }, 24 * 60 * 60 * 1000);
  
    console.log(`å¯†é’¥${type}è½®æ¢æˆåŠŸ`);
  }

  // éªŒè¯å¯†é’¥å¥åº·åº¦
  async healthCheck() {
    const checks = [];
  
    // æ£€æŸ¥å¯†é’¥æ˜¯å¦å­˜åœ¨
    for (const keyType of ['v3Key', 'v2Key']) {
      checks.push({
        type: keyType,
        exists: this.keys.has(keyType),
        length: this.keys.get(keyType)?.length || 0
      });
    }
  
    // æ£€æŸ¥è¯ä¹¦
    const certValid = await certManager.certCache.size > 0;
    checks.push({
      type: 'certificates',
      count: certManager.certCache.size,
      valid: certValid
    });
  
    return checks;
  }
}

const keyManager = new KeyManager();

// å®šæœŸå¥åº·æ£€æŸ¥
setInterval(async () => {
  const health = await keyManager.healthCheck();
  console.log('å¯†é’¥å¥åº·æ£€æŸ¥:', health);
}, 60 * 60 * 1000); // æ¯å°æ—¶æ£€æŸ¥
```

**å¯†é’¥è½®æ¢é€šçŸ¥**ï¼š
```javascript
// å¯†é’¥å³å°†è¿‡æœŸæé†’
class KeyExpirationMonitor {
  static async checkExpiration() {
    const keyCreatedAt = await ConfigService.get('wechat.v3Key.createdAt');
    const daysSinceCreation = Math.floor(
      (Date.now() - new Date(keyCreatedAt)) / (1000 * 60 * 60 * 24)
    );
  
    if (daysSinceCreation > 330) { // 11ä¸ªæœˆ
      await sendAlert({
        type: 'KEY_EXPIRATION_WARNING',
        message: `APIv3å¯†é’¥å·²ä½¿ç”¨${daysSinceCreation}å¤©ï¼Œå»ºè®®è½®æ¢`,
        severity: 'HIGH'
      });
    }
  }
}

// æ¯å¤©æ£€æŸ¥
setInterval(() => {
  KeyExpirationMonitor.checkExpiration();
}, 24 * 60 * 60 * 1000);
```

---

## åç»­æ–‡æ¡£å¯¼èˆª

æ­å–œæ‚¨å®Œæˆäº†ç¬¬äºŒä»½æ–‡æ¡£çš„å­¦ä¹ ï¼ç°åœ¨æ‚¨å·²ç»ï¼š
- âœ… æŒæ¡äº†å®Œæ•´çš„äº¤æ˜“æµç¨‹
- âœ… ç†è§£äº†V2/V3ç­¾åç®—æ³•åŸç†å’Œå®ç°
- âœ… å­¦ä¼šäº†è¯ä¹¦ç®¡ç†è‡ªåŠ¨åŒ–
- âœ… æŒæ¡äº†å›è°ƒå¤„ç†çš„æœ€ä½³å®è·µ
- âœ… ç†è§£äº†å®‰å…¨æœºåˆ¶çš„ç»¼åˆåº”ç”¨

**æ¥ä¸‹æ¥çš„å­¦ä¹ è·¯å¾„**ï¼š

ğŸ“„ **æ–‡æ¡£3ï¼šVue3 ç½‘é¡µæ”¯ä»˜å®æˆ˜**
- H5æ”¯ä»˜å®Œæ•´å®ç°
- JSAPIæ”¯ä»˜ï¼ˆå…¬ä¼—å·ï¼‰
- å‰ç«¯SDKå°è£…
- æ”¯ä»˜çŠ¶æ€ç®¡ç†

ğŸ“„ **æ–‡æ¡£4ï¼šå¾®ä¿¡å°ç¨‹åºæ”¯ä»˜å®æˆ˜**
- å°ç¨‹åºæ”¯ä»˜æµç¨‹
- uni-appè·¨ç«¯æ–¹æ¡ˆ
- æ”¯ä»˜ç»„ä»¶å¼€å‘
- å¸¸è§é—®é¢˜å¤„ç†

ğŸ“„ **æ–‡æ¡£5ï¼šç”Ÿäº§ç¯å¢ƒéƒ¨ç½²ä¸ç›‘æ§**
- é«˜å¯ç”¨æ¶æ„è®¾è®¡
- æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ
- ç›‘æ§å‘Šè­¦ç³»ç»Ÿ
- æ•…éšœåº”æ€¥é¢„æ¡ˆ

---

## ğŸ“š å‚è€ƒèµ„æ–™

- [å¾®ä¿¡æ”¯ä»˜APIv3æ–‡æ¡£](https://pay.weixin.qq.com/wiki/doc/apiv3/index.shtml)
- [å¾®ä¿¡æ”¯ä»˜ç­¾åç®—æ³•](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_0.shtml)
- [å¾®ä¿¡æ”¯ä»˜è¯ä¹¦æŒ‡å¼•](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay5_1.shtml)
- [å¾®ä¿¡æ”¯ä»˜å›è°ƒé€šçŸ¥](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/pay/chapter3_1.shtml)

---

## ğŸ’¡ å­¦ä¹ å»ºè®®

1. **åŠ¨æ‰‹å®è·µ**ï¼šå°†æ–‡æ¡£ä¸­çš„ä»£ç å¤åˆ¶åˆ°æœ¬åœ°ï¼Œå®é™…è¿è¡Œè°ƒè¯•
2. **å¯¹æ¯”æµ‹è¯•**ï¼šåˆ†åˆ«æµ‹è¯•V2å’ŒV3ç­¾åï¼Œç†è§£å…¶å·®å¼‚
3. **æ•…éšœæ¨¡æ‹Ÿ**ï¼šæ•…æ„åˆ¶é€ ç­¾åé”™è¯¯ã€æ—¶é—´æˆ³è¿‡æœŸç­‰åœºæ™¯ï¼Œè§‚å¯Ÿç³»ç»Ÿè¡¨ç°
4. **å·¥å…·å¼€å‘**ï¼šç¼–å†™ç­¾åç”Ÿæˆ/éªŒè¯å°å·¥å…·ï¼Œæ–¹ä¾¿æ—¥å¸¸è°ƒè¯•

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0
**æ›´æ–°æ—¥æœŸï¼š** 2024-10-23
**ç»´æŠ¤äººå‘˜ï¼š** å¼€å‘å›¢é˜Ÿ
**åé¦ˆæ¸ é“ï¼š** tech-docs@example.com
