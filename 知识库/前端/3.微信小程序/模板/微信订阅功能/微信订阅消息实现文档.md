
# 粤邮通小程序 - 微信订阅消息实现技术文档

## 目录
1. [概述](#概述)
2. [技术架构](#技术架构)
3. [实现步骤详解](#实现步骤详解)
4. [应用场景](#应用场景)
5. [代码示例](#代码示例)
6. [最佳实践](#最佳实践)

---

## 概述

### 什么是微信订阅消息
微信订阅消息是小程序向用户推送消息的官方能力，用户主动订阅后，小程序可在特定场景下向用户发送服务通知。

### 项目中的应用价值
- **订单状态通知**：支付成功、发货提醒、售后进度等
- **拼团状态提醒**：拼团成功、拼团进度更新等
- **提现通知**：分销商提现审核结果
- **分销申请**：分销商申请审核通知

---

## 技术架构

### 整体流程图
```
用户操作 
  ↓
页面初始化/用户触发
  ↓
获取订阅消息配置（后端API）
  ↓
调用 wx.requestSubscribeMessage()
  ↓
用户选择订阅/拒绝
  ↓
执行业务逻辑（提交订单、申请等）
  ↓
后端发送订阅消息
```

### 核心组成部分

#### 1. 前端配置管理
- **API接口**：[`wxapp.submsg/setting`](app.js)
- **数据结构**：多层嵌套的模板ID配置
- **存储方式**：页面data中的`submsgSetting`字段

#### 2. 模板ID管理
配置示例结构：
```javascript
{
  order: {
    refund: {
      template_id: "xxx"  // 售后状态通知
    }
  },
  dealer: {
    withdraw_01: {
      template_id: "xxx"  // 提现审核通过
    },
    withdraw_02: {
      template_id: "xxx"  // 提现审核拒绝
    }
  },
  order_submsg: ["xxx", "xxx"]  // 订单相关模板ID数组
}
```

---

## 实现步骤详解

### 步骤一：获取订阅消息配置

#### 1.1 在页面加载时获取配置

**位置**：[`pages/user/index.js:90-99`](pages/user/index.js:90)

```javascript
getSubmsgSetting(callback) {
  let _this = this;
  App._get('wxapp.submsg/setting', {}, (result) => {
    _this.setData({
      submsgSetting: result.data.setting
    }, () => {
      callback && callback();
    });
  });
}
```

**调用时机**：
- 页面`onShow`生命周期
- 页面`onLoad`生命周期

**示例场景**：
- [`pages/user/index.js:37`](pages/user/index.js:37) - 用户中心页面显示时
- [`pages/sharing/order/refund/index.js:28`](pages/sharing/order/refund/index.js:28) - 售后订单页面加载时
- [`pages/dealer/withdraw/apply/apply.js:23`](pages/dealer/withdraw/apply/apply.js:23) - 提现申请页面加载时

---

### 步骤二：提取模板ID

#### 2.1 单个模板ID提取

**场景**：单一业务场景（如售后通知）

**代码示例**：[`pages/sharing/order/refund/index.js:156-172`](pages/sharing/order/refund/index.js:156)

```javascript
_onRequestSubscribeMessage(callback) {
  let _this = this;
  let tmplItem = _this.data.submsgSetting.order.refund.template_id;

  if (tmplItem.length == 0) {
    callback && callback();
    return;
  }
  wx.requestSubscribeMessage({
    tmplIds: [tmplItem],
    success(res) {},
    fail(res) {},
    complete(res) {
      callback && callback();
    },
  });
}
```

#### 2.2 多个模板ID提取

**场景**：多种通知可能（如提现成功/失败）

**代码示例**：[`pages/dealer/withdraw/apply/apply.js:130-149`](pages/dealer/withdraw/apply/apply.js:130)

```javascript
_onRequestSubscribeMessage(callback) {
  let _this = this,
    tmplIds = [],
    dealerSubmsg = _this.data.submsgSetting.dealer;
  
  // 提取所有非空模板ID
  dealerSubmsg.withdraw_01.template_id != '' && 
    tmplIds.push(dealerSubmsg.withdraw_01.template_id);
  dealerSubmsg.withdraw_02.template_id != '' && 
    tmplIds.push(dealerSubmsg.withdraw_02.template_id);

  if (tmplIds.length == 0) {
    callback && callback();
    return;
  }
  wx.requestSubscribeMessage({
    tmplIds,
    success(res) {},
    fail(res) {},
    complete(res) {
      callback && callback();
    },
  });
}
```

#### 2.3 递归收集所有模板ID

**场景**：用户中心统一订阅所有消息

**代码示例**：[`pages/user/index.js:104-120`](pages/user/index.js:104)

```javascript
collectTmplIdsFromSetting(setting) {
  const ids = [];
  const walk = (obj) => {
    if (!obj || typeof obj !== 'object') return;
    Object.keys(obj).forEach(k => {
      const v = obj[k];
      if (v && typeof v === 'object') {
        // 找到template_id字段
        if (v.template_id && typeof v.template_id === 'string' && v.template_id.length) {
          ids.push(v.template_id);
        }
        // 递归遍历子对象
        walk(v);
      }
    });
  };
  walk(setting);
  return ids;
}
```

---

### 步骤三：调用订阅消息API

#### 3.1 基本调用方式

**微信API**：[`wx.requestSubscribeMessage`](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html)

**参数说明**：
```javascript
wx.requestSubscribeMessage({
  tmplIds: ['模板ID1', '模板ID2'],  // 必填：模板ID数组，最多3个
  success(res) {
    // 用户授权成功
    // res 结构: { 模板ID: 'accept'/'reject'/'ban' }
  },
  fail(res) {
    // 用户拒绝授权或接口调用失败
  },
  complete(res) {
    // 接口调用结束（无论成功失败）
    // 通常在这里执行业务逻辑
  }
})
```

#### 3.2 与业务逻辑结合

**模式一：先订阅后提交**（推荐）

**代码示例**：[`pages/sharing/checkout/index.js:247-248`](pages/sharing/checkout/index.js:247)

```javascript
// 提交订单的回调函数
const onCommitCallback = () => {
  // 显示loading
  wx.showLoading({ title: '正在处理...' });
  
  // 创建订单API调用
  App._post_form('sharing.order/checkout', {
    order_type: options.order_type || 10,
    goods_id: options.goods_id,
    // ... 其他参数
  }, result => {
    _this._onSubmitCallback(result);
  });
};

// 先请求订阅消息，再执行提交
_this._onRequestSubscribeMessage(onCommitCallback);
```

**模式二：确认后订阅再提交**

**代码示例**：[`pages/dealer/withdraw/apply/apply.js:109-124`](pages/dealer/withdraw/apply/apply.js:109)

```javascript
// 确认是否提交
wx.showModal({
  content: '确定提交提现申请吗？请确认填写无误',
  showCancel: true,
  success(res) {
    if (res.confirm) {
      // 用户确认后才请求订阅消息
      _this._onRequestSubscribeMessage(onCallback);
    } else if (res.cancel) {
      // 用户取消，解除按钮禁用
      _this.setData({ disabled: false });
    }
  }
});
```

---

### 步骤四：智能提示订阅（高级功能）

#### 4.1 功能说明
在用户中心页面，智能判断用户是否需要订阅消息，主动弹出提示框。

#### 4.2 实现逻辑

**代码位置**：[`pages/user/index.js:125-182`](pages/user/index.js:125)

```javascript
/**
 * 进入页面后提示订阅（需用户点击确认按钮才能触发请求）
 */
maybeShowSubscribePrompt() {
  let _this = this;
  
  // 检查是否在24小时内已提示过
  const shownFlag = wx.getStorageSync('submsg_prompt_shown');
  if (shownFlag && (Date.now() - shownFlag) < 24 * 60 * 60 * 1000) {
    return;  // 一天内不重复提示
  }
  
  const setting = _this.data.submsgSetting;
  if (!setting) return;
  
  // 收集所有模板ID
  const tmplIds = _this.collectTmplIdsFromSetting(setting);
  if (!tmplIds.length) return;

  // 检查用户订阅状态
  wx.getSetting({
    withSubscriptions: true,
    success(res) {
      const subs = res.subscriptionsSetting || {};
      const mainSwitch = subs.mainSwitch;  // 总开关
      const itemSettings = subs.itemSettings || {};  // 各模板订阅状态
      
      // 判断是否需要提示
      // 条件1: 总开关未开启
      // 条件2: 有任何模板未订阅（不是'accept'状态）
      const needPrompt = !mainSwitch || 
        tmplIds.some(id => itemSettings[id] !== 'accept');
      
      if (needPrompt) {
        _this.setData({ 
          subscribePromptVisible: true, 
          submsgTmplIds: tmplIds 
        });
      }
    },
    fail() {
      // 无法获取设置时也尝试提示
      _this.setData({ 
        subscribePromptVisible: true, 
        submsgTmplIds: tmplIds 
      });
    }
  });
}
```

#### 4.3 用户操作处理

```javascript
/**
 * 用户点击开启订阅
 */
onSubscribeConfirm() {
  let _this = this;
  const tmplIds = _this.data.submsgTmplIds || [];
  
  if (!tmplIds.length) {
    _this.setData({ subscribePromptVisible: false });
    return;
  }
  
  wx.requestSubscribeMessage({
    tmplIds,
    success() {},
    fail() {},
    complete() {
      // 记录提示时间，24小时内不再提示
      wx.setStorageSync('submsg_prompt_shown', Date.now());
      _this.setData({ subscribePromptVisible: false });
    }
  });
}

/**
 * 取消订阅提示
 */
onSubscribeCancel() {
  this.setData({ subscribePromptVisible: false });
  // 也记录时间，避免频繁打扰用户
  wx.setStorageSync('submsg_prompt_shown', Date.now());
}
```

---

## 应用场景

### 场景一：订单结算流程

**页面**：[`pages/sharing/checkout/index.js`](pages/sharing/checkout/index.js)

**触发时机**：用户点击"提交订单"按钮

**模板类型**：订单状态通知（支付成功、发货提醒等）

**完整流程**：
```javascript
onSubmitOrder() {
  let _this = this;
  
  // 1. 表单验证
  if (!_this._onVerify()) {
    return false;
  }
  
  // 2. 按钮禁用，防止重复提交
  _this.data.disabled = true;
  
  // 3. 定义提交订单的回调
  const onCommitCallback = () => {
    wx.showLoading({ title: '正在处理...' });
    
    App._post_form('sharing.order/checkout', {
      // ... 订单数据
    }, result => {
      _this._onSubmitCallback(result);
    }, result => {}, () => {
      wx.hideLoading();
      _this.data.disabled = false;
    });
  };
  
  // 4. 先请求订阅消息，再提交订单
  _this._onRequestSubscribeMessage(onCommitCallback);
}

// 订阅消息请求方法
_onRequestSubscribeMessage(onCommitCallback) {
  let _this = this,
    tmplIds = _this.data.setting.order_submsg;
  
  if (tmplIds.length == 0) {
    onCommitCallback();
    return;
  }
  
  wx.requestSubscribeMessage({
    tmplIds,
    success(res) {},
    fail(res) {},
    complete(res) {
      onCommitCallback();  // 无论成功失败都继续提交
    },
  });
}
```

---

### 场景二：售后订单查看

**页面**：[`pages/sharing/order/refund/index.js`](pages/sharing/order/refund/index.js)

**触发时机**：用户点击售后订单查看详情

**模板类型**：售后状态通知

**流程说明**：
```javascript
/**
 * 跳转售后详情页
 */
onTargetDetail(e) {
  let _this = this;
  
  // 跳转的回调函数
  const onCallback = () => {
    wx.navigateTo({
      url: `./detail/detail?order_refund_id=${e.currentTarget.dataset.id}`
    });
  };
  
  // 先请求订阅消息，再跳转
  _this._onRequestSubscribeMessage(onCallback);
}
```

---

### 场景三：分销商提现申请

**页面**：[`pages/dealer/withdraw/apply/apply.js`](pages/dealer/withdraw/apply/apply.js)

**触发时机**：用户提交提现申请

**模板类型**：提现审核通过、提现审核拒绝（2个模板）

**特殊处理**：
```javascript
_onRequestSubscribeMessage(callback) {
  let _this = this,
    tmplIds = [],
    dealerSubmsg = _this.data.submsgSetting.dealer;
  
  // 可能有两种结果，订阅两个模板
  dealerSubmsg.withdraw_01.template_id != '' && 
    tmplIds.push(dealerSubmsg.withdraw_01.template_id);
  dealerSubmsg.withdraw_02.template_id != '' && 
    tmplIds.push(dealerSubmsg.withdraw_02.template_id);

  if (tmplIds.length == 0) {
    callback && callback();
    return;
  }
  
  wx.requestSubscribeMessage({
    tmplIds,
    success(res) {},
    fail(res) {},
    complete(res) {
      callback && callback();
    },
  });
}
```

---

### 场景四：拼团活动

**页面**：[`pages/sharing/active/index.js`](pages/sharing/active/index.js)

**触发时机**：
1. 用户点击"立即分享"按钮
2. 用户点击"立即参团"按钮

**模板类型**：拼团进度通知

**代码示例**：
```javascript
/**
 * 点击立即分享,请求订阅消息
 */
onShare() {
  let _this = this;
  _this._onRequestSubscribeMessage();
}

/**
 * 立即参团
 */
onCheckout(e) {
  let _this = this;
  
  if (!_this._onVerify()) {
    return false;
  }
  
  // 参团的回调
  const onCommitCallback = () => {
    wx.navigateTo({
      url: '../checkout/index?' + util.urlEncode({
        order_type: 20,
        active_id: _this.data.detail.active_id,
        goods_id: _this.data.goods.goods_id,
        goods_num: _this.data.goods_num,
        goods_sku_id: _this.data.goods_sku_id,
      })
    });
  };
  
  // 请求订阅消息后跳转
  _this._onRequestSubscribeMessage(onCommitCallback);
}

/**
 * 订阅消息 => [拼团进度通知]
 */
_onRequestSubscribeMessage(callback) {
  let _this = this;
  let tmplItem = _this.data.setting.order_submsg.active_status;

  if (tmplItem.length == 0) {
    callback && callback();
    return;
  }
  
  wx.requestSubscribeMessage({
    tmplIds: [tmplItem],
    success(res) {},
    fail(res) {},
    complete(res) {
      callback && callback();
    },
  });
}
```

---

### 场景五：用户中心主动提醒

**页面**：[`pages/user/index.js`](pages/user/index.js)

**触发时机**：用户打开个人中心页面

**特点**：
- 智能判断是否需要提醒
- 24小时内只提醒一次
- 检查用户订阅状态
- 一次性订阅所有消息模板

**页面数据结构**：
```javascript
data: {
  submsgSetting: null,              // 订阅消息配置
  subscribePromptVisible: false,    // 是否显示提示弹窗
  submsgTmplIds: [],                // 要订阅的模板ID数组
}
```

**调用流程**：
```
onShow() 
  → getSubmsgSetting() 
  → maybeShowSubscribePrompt()
  → 用户操作（确认/取消）
  → onSubscribeConfirm() / onSubscribeCancel()
```

---

## 代码示例

### 完整示例：订单提交带订阅消息

```javascript
const App = getApp();

Page({
  data: {
    setting: {},           // 系统设置（包含订阅消息配置）
    disabled: false,       // 按钮禁用状态
  },

  /**
   * 页面显示时获取配置
   */
  onShow() {
    let _this = this;
    _this.getOrderData();
  },

  /**
   * 获取订单信息（包含订阅消息配置）
   */
  getOrderData() {
    let _this = this;
    
    wx.showLoading({ title: '加载中...' });
    
    App._get('sharing.order/checkout', {
      goods_id: _this.data.goods_id,
      // ... 其他参数
    }, result => {
      _this.setData(result.data);
      wx.hideLoading();
    });
  },

  /**
   * 提交订单
   */
  onSubmitOrder() {
    let _this = this;
    
    // 1. 表单验证
    if (!_this._onVerify()) {
      return false;
    }
    
    // 2. 防止重复提交
    if (_this.data.disabled) {
      return false;
    }
    _this.data.disabled = true;
    
    // 3. 定义提交成功后的回调
    const onCommitCallback = () => {
      wx.showLoading({ title: '正在处理...' });
      
      App._post_form('sharing.order/checkout', {
        goods_id: _this.data.goods_id,
        goods_num: _this.data.goods_num,
        // ... 其他订单参数
      }, result => {
        // 订单创建成功
        if (result.code === 1) {
          // 跳转到订单列表
          wx.redirectTo({
            url: '/pages/order/index'
          });
        }
      }, result => {
        // 请求失败处理
      }, () => {
        // 请求完成（无论成功失败）
        wx.hideLoading();
        _this.data.disabled = false;
      });
    };
    
    // 4. 先请求订阅消息，再提交订单
    _this._onRequestSubscribeMessage(onCommitCallback);
  },

  /**
   * 请求订阅消息
   */
  _onRequestSubscribeMessage(onCommitCallback) {
    let _this = this,
      tmplIds = _this.data.setting.order_submsg || [];
    
    // 如果没有配置模板ID，直接执行回调
    if (tmplIds.length == 0) {
      onCommitCallback();
      return;
    }
    
    // 调用微信订阅消息API
    wx.requestSubscribeMessage({
      tmplIds,
      success(res) {
        // 用户授权成功
        console.log('订阅消息授权成功', res);
      },
      fail(res) {
        // 用户拒绝或接口调用失败
        console.log('订阅消息授权失败', res);
      },
      complete(res) {
        // 无论成功失败，都继续执行业务逻辑
        onCommitCallback();
      },
    });
  },

  /**
   * 表单验证
   */
  _onVerify() {
    // ... 验证逻辑
    return true;
  }
});
```

---

## 最佳实践

### 1. 配置管理

✅ **推荐做法**：
```javascript
// 页面加载时统一获取配置
onLoad() {
  this.getSubmsgSetting();
}

getSubmsgSetting() {
  App._get('wxapp.submsg/setting', {}, (result) => {
    this.setData({
      submsgSetting: result.data.setting
    });
  });
}
```

❌ **避免**：
- 每次调用都重新请求配置
- 硬编码模板ID在代码中

---

### 2. 调用时机

✅ **推荐做法**：
```javascript
// 在用户明确操作前调用（如点击提交按钮）
onSubmitOrder() {
  // 先订阅，再提交
  this._onRequestSubscribeMessage(() => {
    this.submitOrderData();
  });
}
```

❌ **避免**：
- 页面加载时自动弹出订阅请求
- 短时间内多次请求订阅

---

### 3. 错误处理

✅ **推荐做法**：
```javascript
_onRequestSubscribeMessage(callback) {
  let tmplIds = this.data.submsgSetting.order_submsg;
  
  // 检查配置是否存在
  if (!tmplIds || tmplIds.length == 0) {
    callback && callback();
    return;
  }
  
  wx.requestSubscribeMessage({
    tmplIds,
    success(res) {},
    fail(res) {
      // 失败也继续执行业务逻辑
      console.warn('订阅消息失败', res);
    },
    complete(res) {
      // 确保业务逻辑一定会执行
      callback && callback();
    },
  });
}
```

❌ **避免**：
- 订阅失败就中断业务流程
- 不处理配置为空的情况

---

### 4. 用户体验优化

✅ **推荐做法**：
```javascript
// 智能提示：检查用户是否已订阅
maybeShowSubscribePrompt() {
  // 1. 检查24小时内是否已提示
  const shownFlag = wx.getStorageSync('submsg_prompt_shown');
  if (shownFlag && (Date.now() - shownFlag) < 24 * 60 * 60 * 1000) {
    return;
  }
  
  // 2. 检查用户订阅状态
  wx.getSetting({
    withSubscriptions: true,
    success(res) {
      const subs = res.subscriptionsSetting || {};
      const needPrompt = !subs.mainSwitch || 
        tmplIds.some(id => subs.itemSettings[id] !== 'accept');
      
      if (needPrompt) {
        this.showSubscribePrompt();
      }
    }
  });
}
```

❌ **避免**：
- 每次进入页面都提示
- 不检查用户已订阅状态

---

### 5. 回调函数设计

✅ **推荐做法**：
```javascript
// 使用回调函数，保持代码灵活性
_onRequestSubscribeMessage(callback) {
  wx.requestSubscribeMessage({
    tmplIds,
    complete() {
      callback && callback();  // 安全调用
    }
  });
}

// 调用时
this._onRequestSubscribeMessage(() => {
  // 业务逻辑
});
```

❌ **避免**：
- 在订阅方法中直接写业务逻辑
- 不使用回调函数，降低代码复用性

---

### 6. 模板ID管理

✅ **推荐做法**：
```javascript
// 后端统一管理，前端动态获取
getSubmsgSetting() {
  App._get('wxapp.submsg/setting', {}, (result) => {
    this.setData({
      submsgSetting: result.data.setting
    });
  });
}

// 使用时从配置中读取
let tmplIds = this.data.submsgSetting.order.refund.template_id;
```

❌ **避免**：
```javascript
// 硬编码在前端代码中
const tmplIds = ['xxxxxxxxxxxxx'];  // 不推荐
```

---

### 7. 数据页面结构

✅ **推荐做法**：
```javascript
Page({
  data: {
    submsgSetting: {},      // 订阅消息配置
    disabled: false,        // 按钮状态
    // ... 其他业务数据
  }
})
```

---

## 技术要点总结

### 核心API
- [`wx.requestSubscribeMessage()`](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html) - 请求订阅消息
- [`wx.getSetting()`](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/setting/wx.getSetting.html) - 获取用户订阅状态

### 配置来源
- 后端API：`wxapp.submsg/setting`
- 返回数据结构：多层嵌套对象，包含各场景的模板ID

### 调用模式
1. **同步模式**：用户操作 → 订阅请求 → 业务逻辑
2. **异步模式**：使用回调函数处理业务逻辑
3. **智能提示**：检查状态 → 智能判断 → 主动提醒

### 关键注意事项
- ✅ 一次最多订阅3个模板
- ✅ 必须由用户主动触发（点击事件）
- ✅ 订阅失败不应影响业务流程
- ✅ 避免频繁打扰用户（24小时限制）
- ✅ 后端统一管理模板ID

---

## 项目中的文件分布

### 主要实现文件

| 文件路径 | 主要功能 | 订阅场景 |
|---------|---------|---------|
| [`pages/user/index.js`](pages/user/index.js) | 用户中心 | 智能提示订阅所有消息 |
| [`pages/sharing/checkout/index.js`](pages/sharing/checkout/index.js) | 订单结算 | 订单状态通知 |
| [`pages/sharing/order/refund/index.js`](pages/sharing/order/refund/index.js) | 售后订单 | 售后状态通知 |
js) | 拼团活动 | 拼团进度通知 |
| [`pages/dealer/withdraw/apply/apply.js`](pages/dealer/withdraw/apply/apply.js) | 提现申请 | 提现审核通知 |
| [`pages/dealer/apply/apply.js`](pages/dealer/apply/apply.js) | 分销申请 | 申请审核通知 |
| [`pages/flow/checkout.js`](pages/flow/checkout.js) | 普通订单结算 | 订单状态通知 |
| [`pages/order/refund/index.js`](pages/order/refund/index.js) | 普通售后订单 | 售后状态通知 |

---

## 常见问题FAQ

### Q1: 用户拒绝订阅消息会影响业务流程吗?
**A**: 不会。在所有实现中,订阅消息请求都在`complete`回调中执行业务逻辑,无论用户同意或拒绝,业务流程都会正常进行。

```javascript
wx.requestSubscribeMessage({
  tmplIds,
  complete(res) {
    callback && callback();  // 无论成功失败都执行
  }
});
```

---

### Q2: 为什么要从后端获取模板ID而不是前端硬编码?
**A**: 
1. **灵活性**: 后端可以随时更换模板而不需要发布小程序版本
2. **管理性**: 统一在后端管理所有模板,便于维护
3. **安全性**: 避免前端泄露模板ID信息

---

### Q3: 一次可以订阅多少个模板?
**A**: 微信限制一次最多订阅**3个模板**。如果需要订阅更多,需要分多次调用。

项目中的示例:
```javascript
// 提现通知: 订阅2个模板(成功+失败)
tmplIds = ['模板1', '模板2'];

// 用户中心: 一次性订阅所有(如果超过3个会被截取前3个)
tmplIds = this.collectTmplIdsFromSetting(setting);
```

---

### Q4: 如何避免频繁打扰用户?
**A**: 使用本地存储记录提示时间:

```javascript
// 检查24小时内是否已提示
const shownFlag = wx.getStorageSync('submsg_prompt_shown');
if (shownFlag && (Date.now() - shownFlag) < 24 * 60 * 60 * 1000) {
  return;  // 不重复提示
}

// 提示后记录时间
wx.setStorageSync('submsg_prompt_shown', Date.now());
```

---

### Q5: 订阅消息请求必须由用户操作触发吗?
**A**: 是的。微信要求`wx.requestSubscribeMessage()`必须由用户主动触发(如点击按钮),不能在页面加载时自动调用。

---

### Q6: 如何检查用户是否已经订阅?
**A**: 使用`wx.getSetting()`API:

```javascript
wx.getSetting({
  withSubscriptions: true,
  success(res) {
    const subs = res.subscriptionsSetting;
    const mainSwitch = subs.mainSwitch;  // 总开关
    const itemSettings = subs.itemSettings || {};
    
    // 检查特定模板是否已订阅
    if (itemSettings['模板ID'] === 'accept') {
      console.log('用户已订阅');
    }
  }
});
```

---

### Q7: 后端如何发送订阅消息?
**A**: 后端需要:
1. 调用微信服务器接口`/cgi-bin/message/subscribe/send`
2. 传入用户openid、模板ID、数据等
3. 在适当的业务节点触发发送

注意: 前端只负责**收集订阅授权**,实际发送由后端完成。

---

## 进阶优化建议

### 1. 统一封装订阅消息工具类

创建 `utils/submsg.js`:

```javascript
/**
 * 订阅消息工具类
 */
class SubscribeMessage {
  constructor() {
    this.setting = null;
  }

  /**
   * 初始化配置
   */
  async init() {
    return new Promise((resolve, reject) => {
      const App = getApp();
      App._get('wxapp.submsg/setting', {}, (result) => {
        this.setting = result.data.setting;
        resolve(this.setting);
      });
    });
  }

  /**
   * 请求订阅消息
   * @param {Array} tmplIds 模板ID数组
   * @param {Function} callback 回调函数
   */
  request(tmplIds, callback) {
    if (!tmplIds || tmplIds.length === 0) {
      callback && callback();
      return;
    }

    wx.requestSubscribeMessage({
      tmplIds: tmplIds.slice(0, 3), // 最多3个
      success(res) {},
      fail(res) {},
      complete(res) {
        callback && callback();
      }
    });
  }

  /**
   * 获取指定业务的模板ID
   * @param {String} path 配置路径,如 'order.refund'
   */
  getTemplateIds(path) {
    if (!this.setting) return [];
    
    const keys = path.split('.');
    let current = this.setting;
    
    for (let key of keys) {
      current = current[key];
      if (!current) return [];
    }
    
    if (Array.isArray(current)) return current;
    if (current.template_id) return [current.template_id];
    
    return [];
  }
}

module.exports = SubscribeMessage;
```

使用示例:
```javascript
const SubscribeMessage = require('../../utils/submsg.js');
const submsg = new SubscribeMessage();

Page({
  async onLoad() {
    await submsg.init();
  },
  
  onSubmit() {
    const tmplIds = submsg.getTemplateIds('order.refund');
    submsg.request(tmplIds, () => {
      // 业务逻辑
    });
  }
});
```

---

### 2. 添加订阅状态缓存

减少API调用,提升性能:

```javascript
/**
 * 订阅状态管理
 */
class SubscriptionCache {
  constructor() {
    this.cache = {};
    this.cacheTime = 5 * 60 * 1000; // 5分钟缓存
  }

  async getStatus(tmplId) {
    const now = Date.now();
    const cached = this.cache[tmplId];
    
    // 缓存有效
    if (cached && (now - cached.time) < this.cacheTime) {
      return cached.status;
    }
    
    // 重新获取
    return new Promise((resolve) => {
      wx.getSetting({
        withSubscriptions: true,
        success(res) {
          const status = res.subscriptionsSetting?.itemSettings?.[tmplId];
          this.cache[tmplId] = {
            status,
            time: now
          };
          resolve(status);
        }
      });
    });
  }
}
```

---

### 3. 订阅消息分析统计

记录用户订阅行为:

```javascript
/**
 * 订阅消息统计
 */
function trackSubscription(tmplIds, result) {
  // 上报到数据分析平台
  wx.reportAnalytics('subscribe_message', {
    template_ids: tmplIds.join(','),
    result: JSON.stringify(result),
    timestamp: Date.now()
  });
}

// 在requestSubscribeMessage中使用
wx.requestSubscribeMessage({
  tmplIds,
  success(res) {
    trackSubscription(tmplIds, res);
  }
});
```

---

## 测试指南

### 1. 开发环境测试

在微信开发者工具中:
1. 打开"详情" → "本地设置"
2. 勾选"不校验合法域名"
3. 调用订阅消息API会弹出模拟授权框

---

### 2. 真机测试

1. **测试用户订阅流程**:
   - 点击触发订阅的按钮
   - 检查授权弹窗是否正常显示
   - 选择"总是保持以上选择"并订阅

2. **测试拒绝场景**:
   - 点击"取消"
   - 验证业务流程是否正常继续

3. **测试重复订阅**:
   - 已订阅后再次触发
   - 检查是否会重复弹窗

---

### 3. 后端消息发送测试

使用微信开发者工具的"订阅消息"功能:
1. 在"工具" → "订阅消息"
2. 输入用户openid和模板数据
3. 点击发送,查看消息是否到达

---

## 附录

### A. 微信官方文档链接

- [订阅消息概述](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html)
- [wx.requestSubscribeMessage API](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html)
- [服务端发送订阅消息](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/mp-message-management/subscribe-message/sendMessage.html)

---

### B. 常用模板场景

| 场景 | 模板类型 | 关键字 |
|-----|---------|--------|
| 订单支付 | 支付成功通知 | 订单号、金额、时间 |
| 订单发货 | 发货通知 | 订单号、物流公司、快递单号 |
| 售后进度 | 售后状态通知 | 售后单号、处理结果、时间 |
| 拼团活动 | 拼团状态通知 | 拼团名称、状态、时间 |
| 提现申请 | 审核结果通知 | 提现金额、审核结果、时间 |

---

### C. 项目配置清单

开发订阅消息功能需要准备:

1. ✅ 微信小程序appid和secret
2. ✅ 在微信公众平台选用订阅消息模板
3. ✅ 获取模板ID并配置到后端系统
4. ✅ 后端实现获取配置和发送消息接口
5. ✅ 前端集成订阅消息请求代码

---

## 结语

本文档详细介绍了粤邮通小程序中微信订阅消息的完整实现方案,包括:

- ✅ 技术架构和实现原理
- ✅ 分步骤详细代码说明
- ✅ 5大应用场景实战
- ✅ 最佳实践和优化建议
- ✅ 常见问题解答

通过本文档,开发者可以:
1. 理解订阅消息的工作流程
2. 快速实现类似功能
3. 避免常见问题和陷阱
4. 进行功能优化和扩展

---

**文档版本**: v1.0  
**创建日期**: 2025-10-21  
**适用项目**: 粤邮通小程序  
**技术栈**: 微信小程序原生开发
| [`pages/sharing/active/index.js`](pages/sharing/active/index.