# Vue 每个生命周期都做了什么

## 目录

- [Vue 生命周期概述](#vue-生命周期概述)
- [创建阶段的生命周期](#创建阶段的生命周期)
- [挂载阶段的生命周期](#挂载阶段的生命周期)
- [更新阶段的生命周期](#更新阶段的生命周期)
- [销毁阶段的生命周期](#销毁阶段的生命周期)
- [Keep-Alive 组件的生命周期](#keep-alive-组件的生命周期)
- [生命周期相关的常见问题](#生命周期相关的常见问题)
- [AI 总结](#ai-总结)

## Vue 生命周期概述

Vue 生命周期是面试中的基础知识点，必须掌握。这不是能力问题，而是态度问题。花十分钟准备，把生命周期图画一遍就能掌握。

Vue 3 和 Vue 2 的生命周期有所不同，主要区别在于：
- `beforeDestroy` 改为 `beforeUnmount`
- `destroyed` 改为 `unmounted`

Vue 3 完整的生命周期包括：
- `beforeCreate`
- `created`
- `beforeMount`
- `mounted`
- `beforeUpdate`
- `updated`
- `beforeUnmount`
- `unmounted`

## 创建阶段的生命周期

### beforeCreate

在 `beforeCreate` 阶段：
- 创建一个空白的 Vue 实例
- data 和 methods 尚未被初始化，不可使用
- 这个时候只是一个空白的 Vue 对象
- 基本上做不了什么事情

### created

在 `created` 阶段：
- Vue 实例已经创建完成（JS 对象层面）
- 响应式数据已经完成初始化
- data 和 methods 都可以使用和调用了
- 可以进行与页面无关的 JS 模型相关操作
- 可以获取属性等数据
- 此时还没有开始渲染模板，不要操作模板相关的东西

### created 和 beforeMount 之间

在这个阶段会进行：
- 编译模板
- 调用 render 函数生成虚拟 DOM（V-DOM）
- 此时已经有了 V-DOM，但还是 JS 级别的对象
- 还没有转化为真实 DOM，还没有渲染到页面

## 挂载阶段的生命周期

### beforeMount

在 `beforeMount` 阶段：
- 虚拟 DOM 已经生成
- 但还没有完成真实 DOM 的渲染
- 页面的 DOM 节点还不存在
- `$el` 还是空的

### mounted

在 `mounted` 阶段：
- 完成了 DOM 的渲染
- 虚拟 DOM 已经转换成真实 DOM
- 组件创建完成，已经渲染到页面上
- 可以访问到 DOM 节点（`$el` 已经有值）
- 组件等待运行，后续只有更新或销毁两个选择

**代码演示**：

通过 `LifeCycleDemo` 组件演示：
- `beforeCreate` 时：`data` 和 `$refs` 都是 `undefined`
- `created` 时：`data` 已经是 `Proxy` 对象（Vue 3 响应式形式），`$refs` 也已经有值
- `beforeMount` 时：`$el` 还是空的，说明页面还没有渲染
- `mounted` 时：`$el` 已经有值，DOM 节点已经存在

## 更新阶段的生命周期

### beforeUpdate

在 `beforeUpdate` 阶段：
- data 发生了变化
- 即将更新到页面，但还没有更新
- 类似于 `beforeMount`，只不过是在更新阶段

### updated

在 `updated` 阶段：
- data 发生变化后，页面已经更新完成
- 类似于 `mounted`

**重要注意事项**：
- 不要在 `updated` 中修改 data
- 否则可能导致死循环：更改数据 → 触发渲染 → 渲染完又改数据 → 又触发渲染 → 无限循环

## 销毁阶段的生命周期

### beforeUnmount

在 `beforeUnmount` 阶段：
- 组件即将进入销毁阶段
- 此时组件还没有销毁，仍然可以正常使用
- 常用于解除绑定一些全局事件、定时器等
- 使用场景比 `unmounted` 更多

### unmounted

在 `unmounted` 阶段：
- 组件已经销毁完成
- 组件实例已经不存在
- 所有子组件也都已经销毁
- 如果在这个阶段去解绑或清除东西，可能已经晚了，有些东西可能解除不到

## Keep-Alive 组件的生命周期

Keep-Alive 组件有两个特殊的生命周期钩子：

### onActivated

- 缓存组件被激活时调用

### onDeactivated

- 缓存组件被隐藏时调用（也叫失活）

**代码演示**：

使用 `<keep-alive>` 包裹两个子组件（Child1 和 Child2）：
- 通过 `number` 控制显示和隐藏
- 首次显示 Child1：触发 `created` 和 `activated`
- 切换到 Child2：Child1 触发 `deactivated`，Child2 触发 `created` 和 `activated`
- 再次切换：只触发 `activated` 和 `deactivated`，不再触发 `created`
- 说明组件被缓存了，没有销毁，不会重复创建

如果不使用 `keep-alive`，而是用 `v-if` 和 `v-else`，组件会被销毁和重新创建。

## 生命周期相关的常见问题

### 1\. Vue 什么时候操作 DOM 合适？

在 `mounted` 钩子中直接操作 DOM 不能保证所有子组件全部渲染完成。

**正确做法**：
- 在 `mounted` 中使用 `this.$nextTick()` 来操作 DOM
- `$nextTick` 可以确保 DOM 更新完成后再执行回调

```javascript
mounted() {
  this.$nextTick(() => {
    // 操作 DOM
  })
}
```

### 2\. Ajax 请求应该放在哪个生命周期？

这个问题有讨论空间，可以放在 `created` 或 `mounted` 中。

**推荐放在 `mounted` 中**，原因如下：

从时间轴来看：
- `beforeCreate` → `created`（数据初始化完成）
- `created` → `beforeMount` → `mounted`（DOM 渲染完成）
- `created` 到 `mounted` 的时间间隔非常短（可能只有 10 毫秒），因为只是进行了虚拟 DOM 计算和 DOM 渲染

Ajax 请求的网络时间通常是几百毫秒甚至几秒（比如 1000 毫秒）。

**时间对比**：
- `created` 到 `mounted` 的间隔：约 10 毫秒
- Ajax 请求时间：约 1000 毫秒

这 10 毫秒相对于 1000 毫秒的网络请求时间，差别微乎其微，肉眼看不出任何差别。

**区别在于并行还是串行**：
- 在 `created` 中发起请求：理论上更快，但实际上看不出区别
- 在 `mounted` 中发起请求：更符合逻辑，DOM 已经准备好

两种方式都可以，但更倾向于使用 `mounted`。

### 3\. Vue 3 Composition API 生命周期有什么区别？

Vue 3 Composition API 中的生命周期变化：

- `setup` 代替了 `beforeCreate` 和 `created`
- 使用 hooks 形式调用其他生命周期：
  - `onMounted` 代替 `mounted`
  - `onUpdated` 代替 `updated`
  - `onBeforeMount` 代替 `beforeMount`
  - `onBeforeUpdate` 代替 `beforeUpdate`
  - `onBeforeUnmount` 代替 `beforeUnmount`
  - `onUnmounted` 代替 `unmounted`

```javascript
import { onMounted, onUpdated } from 'vue'

setup() {
  onMounted(() => {
    // mounted 逻辑
  })
  
  onUpdated(() => {
    // updated 逻辑
  })
}
```

## AI 总结

Vue 生命周期是前端面试的必考基础知识，需要掌握每个阶段的特点和适用场景。创建阶段（beforeCreate/created）主要处理数据初始化，挂载阶段（beforeMount/mounted）完成 DOM 渲染，更新阶段（beforeUpdate/updated）响应数据变化，销毁阶段（beforeUnmount/unmounted）清理资源。Keep-Alive 组件有特殊的 activated/deactivated 钩子用于缓存场景。实践中，DOM 操作建议在 mounted 中配合 $nextTick 使用，Ajax 请求推荐放在 mounted 中。Vue 3 Composition API 使用 setup 和 on 前缀的 hooks 形式调用生命周期。理解生命周期的底层原理（如虚拟 DOM 生成、响应式初始化等）有助于更好地应用这些知识。