# Node.js 多进程与进程通信 - 使用 child_process.fork()

## 目录

- [进程基础概念](#进程基础概念)
- [Node.js 单进程特性](#nodejs-单进程特性)
- [开启多进程的方式](#开启多进程的方式)
- [使用 fork() 创建子进程](#使用-fork-创建子进程)
- [主进程与子进程通信机制](#主进程与子进程通信机制)
- [完整代码实现](#完整代码实现)
- [AI 总结](#ai-总结)

## 进程基础概念

**进程通信的核心原则**：
- 通信需要双方合法沟通，双方都必须允许才能进行
- 进程之间的内存是相互隔离的，不能直接访问
- 必须通过特定的通信机制来传递信息

**获取进程 ID**：
```javascript
console.log(process.pid);
```

## Node.js 单进程特性

Node.js 是单线程运行的，默认只有一个进程。

**基础示例**：
```javascript
// process.js
console.log(process.pid);
```

执行后会输出当前进程 ID，但程序会立即结束，进程被销毁。

**保持进程运行**：

通过创建 HTTP 服务器来保持进程常驻内存：

```javascript
const http = require('http');

const server = http.createServer();

server.listen(3000, () => {
  console.log('localhost:3000');
  console.log(process.pid);
});
```

此时进程不会退出，会常驻在内存中，除非强制退出。

## 开启多进程的方式

Node.js 没有与多线程相关的 API，但可以通过以下方式开启多进程：

1. **fork()** 方式
2. **cluster** 方式

本节重点讲解 fork() 方式。

## 使用 fork() 创建子进程

### 主进程代码结构

**文件：process-fork.js**

```javascript
const http = require('http');
const { fork } = require('child_process');

// 创建 HTTP 服务器
const server = http.createServer((request, response) => {
  if (request.url === '/getSum') {
    console.log('主进程 ID:', process.pid);
    
    // 开启子进程
    const computeProcess = fork('./compute.js');
    
    // 发送消息给子进程
    computeProcess.send('开始计算');
    
    // 接收子进程返回的消息
    computeProcess.on('message', (data) => {
      console.log('主进程接收到的信息:', data);
      response.end(data);
    });
    
    // 监听子进程错误退出
    computeProcess.on('error', () => {
      console.log('子进程因报错而退出');
      computeProcess.kill();
      response.end('error');
    });
  }
});

server.listen(3000, () => {
  console.log('localhost:3000');
});
```

### 子进程代码结构

**文件：compute.js**

```javascript
// 子进程 - 负责计算

// 接收主进程的消息
process.on('message', (data) => {
  console.log('子进程 ID:', process.pid);
  console.log('子进程接收到的信息:', data);
  
  // 计算 0 到 10000 的累加和
  let sum = 0;
  for (let i = 0; i <= 10000; i++) {
    sum += i;
  }
  
  // 发送计算结果给主进程
  process.send(sum);
});
```

## 主进程与子进程通信机制

### 通信流程

1. **主进程 → 子进程**：
   - 使用 `computeProcess.send(message)` 发送消息
   - 子进程通过 `process.on('message', callback)` 接收

2. **子进程 → 主进程**：
   - 使用 `process.send(message)` 发送消息
   - 主进程通过 `computeProcess.on('message', callback)` 接收

### 关键 API

**主进程侧**：
- `fork(modulePath)` - 创建子进程
- `childProcess.send(message)` - 向子进程发送消息
- `childProcess.on('message', callback)` - 接收子进程消息
- `childProcess.on('error', callback)` - 监听子进程错误
- `childProcess.kill()` - 杀死子进程

**子进程侧**：
- `process.on('message', callback)` - 接收主进程消息
- `process.send(message)` - 向主进程发送消息
- `process.pid` - 获取当前子进程 ID

## 完整代码实现

### 执行流程

1. 启动主进程服务：`node process-fork.js`
2. 访问 `http://localhost:3000/getSum`
3. 主进程创建子进程并发送 "开始计算" 消息
4. 子进程接收消息，计算 0-10000 累加和
5. 子进程将结果发送回主进程
6. 主进程接收结果并返回给浏览器

### 控制台输出示例

```
localhost:3000
主进程 ID: 12345
子进程 ID: 12346
子进程接收到的信息: 开始计算
主进程接收到的信息: 50005000
```

### 计算逻辑

累加和计算：$\sum_{i=0}^{10000} i = 50005000$

```javascript
let sum = 0;
for (let i = 0; i <= 10000; i++) {
  sum += i;
}
```

## AI 总结

本视频详细讲解了 Node.js 中使用 `child_process.fork()` 开启多进程的方法。核心要点包括：

1. **进程隔离**：Node.js 是单线程的，进程间内存相互隔离，需要通过特定机制通信
2. **fork() 方法**：通过 `child_process.fork()` 可以创建子进程来执行计算密集型任务
3. **通信机制**：主进程使用 `childProcess.send()` 发送消息，子进程使用 `process.on('message')` 接收；反之亦然
4. **实际应用**：将耗时计算任务交给子进程处理，避免阻塞主进程的 HTTP 服务

这种多进程架构可以有效提升 Node.js 应用处理计算密集型任务的能力，充分利用多核 CPU 资源。