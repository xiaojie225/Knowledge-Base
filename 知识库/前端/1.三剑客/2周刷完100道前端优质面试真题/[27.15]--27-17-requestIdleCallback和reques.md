# requestIdleCallback 和 requestAnimationFrame

## 目录

- [基本概念](#基本概念)
- [React Fiber 机制背景](#react-fiber-机制背景)
- [两者的核心区别](#两者的核心区别)
- [浏览器兼容性](#浏览器兼容性)
- [代码示例：动画效果](#代码示例动画效果)
- [执行优先级验证](#执行优先级验证)
- [AI 总结](#ai-总结)

## 基本概念

**requestIdleCallback** 和 **requestAnimationFrame** 是两个浏览器提供的 API，用于在不同时机执行回调函数。

- **requestAnimationFrame**：每次渲染时都会执行（高优先级）
- **requestIdleCallback**：空闲时才执行（低优先级）

## React Fiber 机制背景

requestIdleCallback 这个 API 原本不常被提及，但因为 **React 16** 引入了 **Fiber 机制**而受到关注。

### Fiber 机制的工作原理

- 将 React 的虚拟 DOM 树转换成**链表结构**
- 实现**可中断的渲染**：可以分段渲染组件树
- 在渲染过程中，可以暂停去执行更高优先级的任务（如用户输入、动画）
- 等待高优先级任务完成后，再继续渲染

### 为什么需要这种机制

- JavaScript 是**单线程**的
- JavaScript 执行线程和 DOM 渲染线程**共用一个线程**
- 如果 JavaScript 执行时间过长，会阻塞 DOM 渲染，导致页面卡顿
- Fiber 机制通过 requestIdleCallback 判断浏览器空闲时机，实现可中断的渲染

## 两者的核心区别

### 渲染频率与流畅度

网页要流畅显示，需要：
- 每秒至少 **60 帧**（60 FPS）
- 每帧间隔约 **16.6 毫秒**（1000ms ÷ 60 ≈ 16.6ms）

### requestAnimationFrame

- **高优先级执行**
- 每次页面重绘时都会执行
- 每一帧（约 16.6ms）都会触发回调
- 无论如何都会在当前帧完成回调执行
- 适合做动画效果

### requestIdleCallback

- **低优先级执行**
- 只在浏览器**空闲时**执行
- 如果页面渲染繁忙，会被推迟执行
- 如果页面静态或变化慢，才有机会执行
- 适合做非紧急的后台任务

## 浏览器兼容性

在 [caniuse.com](https://caniuse.com) 上搜索 requestIdleCallback：
- 兼容性还不错
- Safari 有一些问题
- IE11 有一些问题
- 其他主流浏览器支持良好

## 代码示例：动画效果

### HTML 结构

```html
<button>Transform</button>
<div style="width: 100px; height: 100px; background: blue;"></div>
```

### JavaScript 实现

```javascript
let currentWidth = 100; // 当前宽度
const maxWidth = 400;   // 最大宽度

function addWidth() {
  currentWidth = currentWidth + 3; // 每次增加 3px
  div.style.width = currentWidth + 'px';
  
  if (currentWidth < maxWidth) {
    // 方式一：使用 requestAnimationFrame（高优先级）
    requestAnimationFrame(addWidth);
    
    // 方式二：使用 requestIdleCallback（低优先级）
    // requestIdleCallback(addWidth);
  }
}

button.addEventListener('click', addWidth);
```

### 效果说明

- 点击按钮后，div 宽度从 100px 逐渐增加到 400px
- 使用 **requestAnimationFrame**：每帧都执行，动画流畅
- 使用 **requestIdleCallback**：在当前简单场景下效果相同，但本质不同
  - 因为当前页面没有繁忙任务，所以一直处于空闲状态
  - 如果页面有大量计算或渲染任务，requestIdleCallback 会被延迟执行

## 执行优先级验证

### 测试代码

```javascript
window.addEventListener('load', () => {
  console.info('Start');
  
  setTimeout(() => {
    console.info('setTimeout');
  }, 0);
  
  requestAnimationFrame(() => {
    console.info('requestAnimationFrame');
  });
  
  requestIdleCallback(() => {
    console.info('requestIdleCallback');
  });
  
  console.info('End');
});
```

### 执行结果

```
Start
End
setTimeout
requestAnimationFrame
requestIdleCallback
```

### 结论

1. 同步代码最先执行（Start → End）
2. setTimeout 作为宏任务执行
3. **requestAnimationFrame** 和 **requestIdleCallback** 都是**宏任务**
4. 它们比 setTimeout 更晚执行（因为要等待渲染时机）
5. **requestAnimationFrame 优先级高于 requestIdleCallback**
   - 即使调换代码顺序，执行顺序依然是 requestAnimationFrame 先执行
   - 这证明了高优先级任务先执行，低优先级任务后执行

## AI 总结

requestAnimationFrame 和 requestIdleCallback 是两个用于不同场景的浏览器 API。前者是高优先级的，每次页面重绘（约 16.6ms）都会执行，适合制作流畅的动画效果；后者是低优先级的，只在浏览器空闲时执行，适合处理非紧急的后台任务。

React 16 的 Fiber 机制正是利用 requestIdleCallback 实现了可中断的渲染：将组件树转换为链表结构，在渲染过程中可以暂停去处理高优先级任务（如用户输入、动画），然后再继续渲染。这种机制有效解决了 JavaScript 单线程环境下长时间执行导致的页面卡顿问题。

从执行时机来看，两者都属于宏任务，但 requestAnimationFrame 的优先级明显高于 requestIdleCallback，这也符合它们各自的设计目的。