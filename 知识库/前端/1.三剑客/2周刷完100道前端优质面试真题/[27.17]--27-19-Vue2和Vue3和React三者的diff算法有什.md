# Vue2、Vue3 和 React 的 Diff 算法区别

## 目录

- [Diff 算法基础](#diff-算法基础)
- [算法优化策略](#算法优化策略)
- [React 的 Diff 算法特点](#react-的-diff-算法特点)
- [Vue2 的 Diff 算法特点](#vue2-的-diff-算法特点)
- [Vue3 的 Diff 算法特点](#vue3-的-diff-算法特点)
- [Key 的重要性](#key-的重要性)
- [AI 总结](#ai-总结)

## Diff 算法基础

Diff 算法是社区讨论较多且较难的话题,很少有人能通俗易懂地讲清楚这个问题。

### 什么是 Diff 算法

- Diff 算法不是 Vue 或 React 独有的,很早之前就存在
- 应用场景广泛,如 GitHub 的 Pull Request 和 Merge Request 中都有 Diff 的应用
- 在框架中,Diff 算法用于对比虚拟 DOM 树的差异

### Diff 算法的工作原理

数据更新后:
1. 重新生成新的虚拟 DOM (Virtual DOM)
2. 将新旧两个虚拟 DOM 进行对比
3. 找出需要更新的 DOM 节点
4. 执行更新操作

### 严格 Diff 的时间复杂度问题

如果严格对比两棵树的差异:
- 时间复杂度为 $O(n^3)$
- 这个复杂度是完全不可用的
- 需要遍历旧树、遍历新树,还要对结果进行排序
- 数据量稍大就会导致系统崩溃

## 算法优化策略

为了将时间复杂度降低到可用的 $O(n)$ 级别,Vue 和 React 都采用了以下优化策略:

### 1\. 只比较同一层级

- 不进行跨层级比较
- 原因:在实际 DOM 树中,很少有跨级移动节点的情况
- 大部分情况都是同级别的移动或删除

### 2\. 标签不同则删除重建

- 如果父节点标签不同,直接删除重建
- 不再深入比较内部的子节点
- 简单粗暴,但速度快

### 3\. 子节点通过 Key 区分

- Key 是 Diff 算法优化的关键
- 通过 Key 可以快速判断节点是移动还是新建/删除
- 没有 Key 会导致性能问题

通过这三级优化,时间复杂度从 $O(n^3)$ 降低到 $O(n)$,达到可用级别。

## React 的 Diff 算法特点

### 核心特点:仅右移

React 的 Diff 算法特点是"仅右移"(只往右边移动,不往左边移动)。

### 示例说明

旧序列: A, B, C, D, E  
新序列: B, C, A, D, E

**对比过程:**

**第一步:** 定位到 B
- 旧序列中 B 在右边
- 按理应该把 B 移到左边
- 但 React 是仅右移,所以不动

**第二步:** 定位到 C
- 旧序列中 C 也在右边
- 同样不动

**第三步:** 定位到 A
- 旧序列中 A 在左边
- 可以往右移
- 将 A 右移到 B、C 后面

**第四步:** A 右移后
- B、C 自然左移
- 序列变成 B, C, A
- 后续 D、E 位置不变

### 特点总结

- 比较简单粗暴
- 只进行右移操作
- 效果明显

## Vue2 的 Diff 算法特点

### 核心特点:双端比较

Vue2 采用双端比较算法,定义四个指针:
- oldStartIndex (旧序列起始指针)
- oldEndIndex (旧序列结束指针)
- newStartIndex (新序列起始指针)
- newEndIndex (新序列结束指针)

### 比较过程

四个指针相互比较:
1. oldStart 和 newStart 比较
2. oldEnd 和 newEnd 比较
3. oldStart 和 newEnd 比较
4. oldEnd 和 newStart 比较

比较完后:
- 起始指针往右移动
- 结束指针往左移动
- 每移动一步,再次进行四次比较
- 直到指针在中间相遇

### 适用场景

特别适合在列表中间插入新元素的场景:

旧序列: A, B, C, D  
新序列: A, B, X, Y, C, D

- 前两个 A、B 相同,不用动
- 后两个 C、D 相同,不用动
- 只需要在中间插入 X、Y

这种场景下,双端比较可以最大程度减少 DOM 操作次数。

## Vue3 的 Diff 算法特点

### 核心特点:最长递增子序列

Vue3 在 Vue2 的基础上进一步优化,采用最长递增子序列算法。

### 什么是最长递增子序列

给定数组: [3, 5, 7, 1, 2, 8]

最长递增子序列是: [3, 5, 7, 8]
- 元素顺序不变
- 一直递增
- 长度最长

### 算法过程示例

旧序列: A, B, C, D, E, F, G  
新序列: A, B, F, C, D, E, H, G

**第一步:** 前后端比较
- 前面 A、B 相同,不动
- 后面 G 相同,不动

**第二步:** 处理中间部分
剩余新序列: F, C, D, E, H (索引 2, 3, 4, 5, 6)

对应旧序列的索引: [5, 2, 3, 4, -1]
- F 对应索引 5
- C 对应索引 2
- D 对应索引 3
- E 对应索引 4
- H 是新增,标记为 -1

**第三步:** 找最长递增子序列
在 [5, 2, 3, 4, -1] 中,最长递增子序列是 [2, 3, 4]

对应元素 C, D, E 不需要移动

**第四步:** 处理其他元素
- F 需要移动
- H 是新增,直接插入

### 优化效果

通过最长递增子序列算法:
- A、B 不动
- C、D、E 不动
- G 不动
- 只需要操作 F 和 H

最大程度减少了 DOM 操作次数,这是在 Vue2 基础上的进一步优化。

## Key 的重要性

### 为什么必须使用 Key

在 Vue 和 React 的循环中必须使用 Key,原因是:
- Diff 算法会根据 Key 判断元素是移动还是删除重建
- 有 Key:只需移动,性能好
- 无 Key:删除重建,性能差

### 对比示例

旧序列: A, B, C, D  
新序列: B, A, D, C

**不使用 Key:**
- 对比发现每个位置都不同
- 全部删除
- 全部重新创建

**使用 Key:**
```
旧: key=A, key=B, key=C, key=D
新: key=B, key=A, key=D, key=C
```
- 通过 Key 识别出是同一个元素
- 只需要移动位置
- 不需要删除重建

### React 中的示例

由于 React 是仅右移:
- A 往后移一位
- C 往后移一位
- 通过移动完成更新

性能对比:
- 不用 Key:全部删除重建
- 用 Key:只是移动
- 性能差异巨大

### 代码示例

**Vue 中使用 Key:**
```vue
<div v-for="item in list" :key="item.id">
  {{ item.name }}
</div>
```

**React 中使用 Key:**
```jsx
{list.map(item => (
  <div key={item.id}>
    {item.name}
  </div>
))}
```

现在的框架如果不使用 Key,都会给出警告或报错,因为 Key 对 Diff 算法的性能优化至关重要。

## AI 总结

Vue2、Vue3 和 React 的 Diff 算法都基于相同的优化原则:只比较同层级、标签不同则删除重建、通过 Key 区分子节点,将时间复杂度从 $O(n^3)$ 优化到 $O(n)$。

三者的主要区别在于具体实现策略:
- **React** 采用仅右移策略,简单粗暴但有效
- **Vue2** 使用双端比较,通过四个指针从两端向中间靠拢,特别适合列表中间插入的场景
- **Vue3** 在 Vue2 基础上引入最长递增子序列算法,进一步减少 DOM 操作次数,性能更优

无论哪种算法,核心目标都是尽量减少 DOM 操作,找出真正需要改变的节点。在实际开发中,必须为循环元素添加 Key,这样 Diff 算法才能通过 Key 识别元素并进行移动,而不是删除重建,从而获得最佳性能。