# JS内存泄漏的场景有哪些

## 目录

- [为什么以Vue为例](#为什么以vue为例)
- [内存泄漏的常见场景](#内存泄漏的常见场景)
  - [全局变量或全局函数引用](#全局变量或全局函数引用)
  - [全局定时器引用](#全局定时器引用)
  - [全局事件监听器](#全局事件监听器)
  - [自定义事件](#自定义事件)
- [开发人员应具备的敏感度](#开发人员应具备的敏感度)
- [前端内存泄漏的重要性变化](#前端内存泄漏的重要性变化)
- [AI 总结](#ai-总结)

## 为什么以Vue为例

如果仅仅讲纯JS会太过理论化，希望大家能展现出一些实际工作经验的内容给面试官，这样会更好。因此以Vue为例来讲解内存泄漏场景。

## 内存泄漏的常见场景

### 全局变量或全局函数引用

**问题描述**：
- 组件销毁时，被全局变量、函数引用的数据未清除
- 全局事件、定时器引用组件数据，组件销毁时未清除

**代码示例**：

创建 `MemoryLeak.vue` 文件（leak是泄漏的意思，与lake湖类似）

```javascript
// 问题代码
data() {
  return {
    arr: [] // 或对象
  }
},
mounted() {
  // 不小心放在全局
  window.leakArray = this.arr
  // 或者全局函数引用
  window.printArray = () => {
    console.log(this.arr)
  }
}
```

**解决方案**：

在组件销毁前清除引用（Vue3使用`beforeUnmount`，Vue2使用`beforeDestroy`）

```javascript
beforeUnmount() {
  window.printArray = null
  // 或清理函数
  delete window.printArray
}
```

### 全局定时器引用

**问题描述**：
- `setInterval` 或 `setTimeout` 持续引用组件数据
- `setInterval` 一直执行，影响更明显
- `setTimeout` 只执行一次，但如果未执行完也需要清除

**代码示例**：

```javascript
// 问题代码
data() {
  return {
    arr: []
  }
},
mounted() {
  setInterval(() => {
    console.log(this.arr) // 一直占用arr和整个组件实例
  }, 100)
}
```

**解决方案**：

```javascript
data() {
  return {
    arr: [],
    intervalId: null
  }
},
mounted() {
  this.intervalId = setInterval(() => {
    console.log(this.arr)
  }, 100)
},
beforeUnmount() {
  if (this.intervalId) {
    clearInterval(this.intervalId)
  }
}
```

### 全局事件监听器

**问题描述**：
- 全局事件如 `window.addEventListener` 的 `resize` 事件
- 组件创建和销毁多次时，会执行多次事件绑定
- 事件回调函数持续引用组件数据

**代码示例**：

```javascript
// 问题代码
methods: {
  fn() {
    console.log(this.arr)
  }
},
mounted() {
  // 错误：每次都是新函数，无法移除
  window.addEventListener('resize', () => {
    console.log(this.arr)
  })
}
```

**解决方案**：

必须将函数单独抽出来，保证绑定和移除使用同一个函数引用

```javascript
methods: {
  printArray() {
    console.log(this.arr)
  }
},
mounted() {
  window.addEventListener('resize', this.printArray)
},
beforeUnmount() {
  window.removeEventListener('resize', this.printArray)
}
```

**注意**：如果在绑定和移除时分别写两个箭头函数或匿名函数，它们是两个不同的函数，无法正确移除。

### 自定义事件

**问题描述**：
- 使用 `EventEmitter` 或类似的自定义事件系统
- 绑定事件后未在组件销毁时解绑

**解决方案**：

```javascript
import { eventBus } from './eventBus'

methods: {
  handleCustomEvent() {
    // 处理逻辑
  }
},
mounted() {
  eventBus.on('customEvent', this.handleCustomEvent)
},
beforeUnmount() {
  eventBus.off('customEvent', this.handleCustomEvent)
}
```

同样需要将函数抽出来，确保 `on` 和 `off` 使用同一个函数引用。

## 开发人员应具备的敏感度

作为开发人员，需要培养对内存泄漏的敏感度：

1. **遇到全局变量、全局函数、全局事件、定时器时**，要立即意识到：是否需要清除？是否需要销毁？

2. **类比其他编程素养**：
   - 遇到算法 → 敏感地检查时间复杂度是否可以优化
   - 遇到数据结构 → 敏感地检查是否可以优化
   - 遇到闭包函数 → 敏感地检查this指向是否正确

3. **充分利用组件销毁生命周期**：
   - Vue3: `beforeUnmount`
   - Vue2: `beforeDestroy`
   - 在这个生命周期中清除不必要的引用和占用

## 前端内存泄漏的重要性变化

### 以前前端不太注重内存泄漏的原因

1. **后端特点**：
   - 7×24小时持续运行
   - 内存泄漏影响巨大：每分钟泄漏一点点，累积后内存崩溃

2. **前端特点（过去）**：
   - 主要是网页，刷新后访问，访问完就关闭
   - 没有长时间运行
   - 即使有泄漏也不明显
   - 页面不复杂，以展示为主（展示数据、提交表单等）
   - 功能简单，内存泄漏不容易暴露

### 现在前端需要重视内存泄漏的原因

1. **前端工程复杂度提升**：
   - 富文本编辑器
   - 低代码平台
   - 页面搭建器
   - 功能丰富的系统

2. **使用时间变长**：
   - 用户可能使用半天甚至更久
   - 系统复杂 + 运行时间长 = 内存问题暴露

3. **大厂面试趋势**：
   - 考察内存泄漏的频率越来越高
   - 考察JS内存知识的面试题越来越多

## AI 总结

本视频详细讲解了Vue中常见的内存泄漏场景及解决方案。主要包括四类场景：全局变量/函数引用、全局定时器、全局事件监听器和自定义事件。核心解决思路是在组件的`beforeUnmount`生命周期中清除这些引用。

关键要点：
1. 事件监听器的绑定和移除必须使用同一个函数引用
2. 定时器需要保存ID并在销毁时清除
3. 开发者需要培养对全局资源的敏感度
4. 随着前端应用复杂度提升和使用时长增加，内存泄漏问题变得越来越重要，成为大厂面试的高频考点