# Vue组件通讯方式详解

## 目录

- [组件通讯方式概览](#组件通讯方式概览)
- [Props 和 Emit（父子组件通讯）](#props-和-emit父子组件通讯)
- [自定义事件（跨组件通讯）](#自定义事件跨组件通讯)
- [其他通讯方式](#其他通讯方式)
- [适用场景对比](#适用场景对比)
- [AI 总结](#ai-总结)

## 组件通讯方式概览

Vue组件通讯方式从基础到高级包括：

1\. **Props 和 Emit** - 最基本、最常用的父子组件通讯方式

2\. **自定义事件** - 适用于任意组件间通讯

3\. **$attrs** - 属性透传

4\. **$parent** - 访问父组件实例

5\. **$refs** - 访问子组件实例

6\. **Provide 和 Inject** - 跨多级组件通讯

7\. **Vuex** - 全局状态管理（需单独学习）

这些通讯方式适用于不同场景：
- 父子组件通讯
- 兄弟组件通讯
- 跨多级组件通讯
- 全局组件通讯（无父子关系）

## Props 和 Emit（父子组件通讯）

### 父组件向子组件传递数据（Props）

父组件通过属性向子组件传递数据：

```vue
<!-- 父组件 -->
<HelloWorld :message="someMessage" />
```

子组件接收属性：

```vue
<!-- 子组件 HelloWorld.vue -->
<script>
export default {
  props: {
    message: String
  }
}
</script>

<template>
  <h1>{{ message }}</h1>
</template>
```

### 子组件向父组件传递数据（Emit）

**Vue 3 中的重要变化**：需要使用 `emits` 选项声明事件（Vue 2 中没有此要求）

子组件触发事件：

```vue
<!-- 子组件 -->
<script>
export default {
  emits: ['sendMessage'],  // Vue 3 新增，必须声明
  methods: {
    handleClick() {
      this.$emit('sendMessage', 'Hello World')
    }
  }
}
</script>

<template>
  <button @click="handleClick">发送消息</button>
</template>
```

父组件监听事件：

```vue
<!-- 父组件 -->
<template>
  <HelloWorld @sendMessage="onMessage" />
</template>

<script>
export default {
  methods: {
    onMessage(data) {
      console.log(data)  // 输出: Hello World
    }
  }
}
</script>
```

### 适用场景

Props 和 Emit 适合**父子组件**之间的通讯：
- 父组件 → 子组件：使用 Props
- 子组件 → 父组件：使用 Emit

## 自定义事件（跨组件通讯）

### Vue 2 vs Vue 3 的重要区别

**Vue 2**：可以使用 `new Vue()` 创建事件总线

```javascript
// Vue 2
const eventBus = new Vue()
```

**Vue 3**：移除了这种方式，必须使用第三方库，如 `mitt`

```javascript
// Vue 3
import mitt from 'mitt'
const eventBus = mitt()
```

### 使用 mitt 实现自定义事件

安装 mitt：
```bash
npm install mitt
```

创建事件总线：

```javascript
// event-bus.js
import mitt from 'mitt'
export const eventBus = mitt()
```

### 监听事件的组件

```vue
<script>
import { eventBus } from './event-bus'

export default {
  mounted() {
    // 监听事件
    eventBus.on('customEvent', this.handleMessage)
  },
  beforeUnmount() {  // Vue 3 使用 beforeUnmount，Vue 2 使用 beforeDestroy
    // 组件销毁时必须 off 事件，防止内存泄漏
    eventBus.off('customEvent', this.handleMessage)
  },
  methods: {
    handleMessage(data) {
      console.log(data)
    }
  }
}
</script>
```

### 触发事件的组件

```vue
<script>
import { eventBus } from './event-bus'

export default {
  methods: {
    sendMessage() {
      eventBus.emit('customEvent', 'Hello Custom Event')
    }
  }
}
</script>

<template>
  <button @click="sendMessage">触发事件</button>
</template>
```

### 关键注意事项

1\. **必须 off 事件**：组件销毁时必须移除事件监听，否则会造成内存泄漏

2\. **生命周期钩子变化**：
   - Vue 2：`beforeDestroy`
   - Vue 3：`beforeUnmount`

3\. **off 时必须传入函数引用**：

```javascript
// ❌ 错误：无法 off 匿名函数
eventBus.on('event', () => { console.log('test') })
eventBus.off('event', () => { console.log('test') })  // 无效，两个箭头函数不是同一个引用

// ✅ 正确：使用命名函数
eventBus.on('event', this.handleEvent)
eventBus.off('event', this.handleEvent)  // 有效
```

### 适用场景

自定义事件适合以下场景：

1\. **兄弟组件通讯**：A 组件和 B 组件之间没有父子关系

2\. **跨层级组件通讯**：组件之间相隔多层，使用 Props 传递不方便

3\. **多对多通讯**：
   - 多个组件监听同一个事件
   - 多个组件触发同一个事件
   - 一个组件触发，多个组件响应

4\. **无关联组件通讯**：组件之间没有任何父子或兄弟关系

### 使用建议

自定义事件在实际项目中使用最多，但也最容易用乱：
- 多个监听、多个触发容易造成混乱
- 必须制定清晰的规范
- 事件命名要规范统一
- 及时清理不用的事件监听
- 不能随意乱用，否则难以调试

## 其他通讯方式

### $attrs（属性透传）

用于将父组件的属性透传给子组件，与 Props 相关但不完全相同。

### $parent 和 $refs

- `$parent`：访问父组件实例
- `$refs`：访问子组件实例

这两个方式可以直接访问组件实例，但会增加组件间的耦合度。

### Provide 和 Inject

用