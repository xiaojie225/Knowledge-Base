# JS内存垃圾回收算法

## 目录

- [什么是垃圾回收](#什么是垃圾回收)
- [垃圾回收的基本概念](#垃圾回收的基本概念)
- [引用计数算法](#引用计数算法)
- [标记清除算法](#标记清除算法)
- [AI 总结](#ai-总结)

## 什么是垃圾回收

垃圾回收（Garbage Collection，简称 GC）是 JavaScript 引擎自动管理内存的机制。当函数执行完毕后，函数内部定义的变量和占用的内存空间会被标记为"垃圾"并被回收。

**基本示例：**

```javascript
function fn() {
  let a = 'AA';
  console.log(a);
  
  let obj = { x: 100 };
  console.log(obj);
}
```

执行完 `fn()` 后，变量 `a` 和对象 `obj` 都不再存在，它们占用的内存会被回收。这是正常的垃圾回收过程。

## 垃圾回收的基本概念

### 不能被回收的情况

**情况1：全局引用**

```javascript
function fn2() {
  let obj = { x: 100 };
  window.data = obj;  // 将对象赋值给全局对象
}

fn2();
console.log(window.data);  // 对象仍然存在
```

执行完 `fn2()` 后，虽然函数执行完毕，但因为 `window.data` 引用了这个对象，所以对象不能被回收。这不是垃圾，因为它符合用户预期，未来可能还会使用。

**情况2：闭包**

```javascript
function createData() {
  let data = {};
  
  return {
    get(key) {
      return data[key];
    },
    set(key, value) {
      data[key] = value;
    }
  };
}

const { get, set } = createData();
set('x', 100);
console.log(get('x'));  // 100
```

闭包中的 `data` 对象会长期驻留内存，不会被回收。因为返回的 `get` 和 `set` 函数可能随时被调用，需要访问 `data`。

**重要结论：闭包的数据永远都是长驻内存的，不会被销毁。**

## 引用计数算法

引用计数（Reference Counting）是早期浏览器（如 IE6/IE7）使用的垃圾回收算法。

### 工作原理

通过记录每个对象被引用的次数来判断是否需要回收：
- 当引用次数为 0 时，对象被回收
- 当引用次数大于 0 时，对象保留

**示例：**

```javascript
let a = { x: 100 };     // 对象被 a 引用，引用计数 = 1
let a1 = a;             // 对象被 a1 引用，引用计数 = 2
a = 10;                 // a 不再引用对象，引用计数 = 1
a1 = null;              // a1 不再引用对象，引用计数 = 0，对象被回收
```

### 引用计数的缺陷：循环引用

```javascript
function fn3() {
  let obj1 = {};
  let obj2 = {};
  
  obj1.a = obj2;  // obj1 引用 obj2
  obj2.a = obj1;  // obj2 引用 obj1
}

fn3();
```

执行完 `fn3()` 后，`obj1` 和 `obj2` 互相引用，引用计数都不为 0，导致无法回收。这是引用计数算法的重大缺陷。

**历史问题：IE6/IE7 的内存泄漏 Bug**

```javascript
let div1 = document.getElementById('div1');
div1.a = div1;  // 循环引用
div1.someData = { /* 大量数据 */ };  // 导致内存泄漏
```

这种循环引用在 IE6/IE7 中会导致内存泄漏，现代浏览器已经解决了这个问题。

## 标记清除算法

标记清除（Mark and Sweep）是现代浏览器使用的垃圾回收算法，解决了循环引用的问题。

### 工作原理

1. 从 JavaScript 的根对象（通常是 `window`）开始
2. 定期遍历所有属性和子属性
3. 能够访问到的对象标记为"可达"，保留
4. 无法访问到的对象标记为"不可达"，删除

**循环引用的解决：**

```javascript
function fn3() {
  let obj1 = {};
  let obj2 = {};
  
  obj1.a = obj2;
  obj2.a = obj1;
}

fn3();
```

使用标记清除算法：
- 执行完 `fn3()` 后，`obj1` 和 `obj2` 变量被销毁
- 从 `window` 开始遍历，无法访问到这两个对象
- 这两个对象被标记为不可达，会被回收

**其他场景：**

```javascript
// 场景1：全局引用
function fn() {
  let obj = { x: 100 };
  window.data = obj;
}
// 从 window 可以访问到 obj，对象保留

// 场景2：闭包
function createData() {
  let data = {};
  return {
    get(key) { return data[key]; },
    set(key, value) { data[key] = value; }
  };
}
// 返回的函数被引用，从 window 可以访问到这些函数
// 函数内部引用了 data，所以 data 不会被回收
```

### 标记清除的优势

- 解决了循环引用问题
- 更准确地判断对象是否可达
- 现代浏览器的标准算法

## AI 总结

JavaScript 的垃圾回收机制用于自动管理内存。早期使用引用计数算法，通过记录对象被引用的次数来判断是否回收，但存在循环引用无法回收的缺陷。现代浏览器采用标记清除算法，从根对象（window）开始遍历，标记所有可达对象并保留，不可达对象则被回收，有效解决了循环引用问题。

需要注意的是，并非所有无法回收的数据都是内存泄漏。全局引用和闭包中的数据虽然长驻内存，但如果符合代码预期，就不算内存泄漏。真正的内存泄漏是指那些非预期的、本应被回收却无法回收的数据。