# 如何检测 JS 内存泄漏

## 目录

- [检测内存泄漏的基本原理](#检测内存泄漏的基本原理)
- [实战演示：创建内存泄漏场景](#实战演示创建内存泄漏场景)
- [使用 Performance 工具检测内存变化](#使用-performance-工具检测内存变化)
- [正常内存释放的表现](#正常内存释放的表现)
- [AI 总结](#ai-总结)

## 检测内存泄漏的基本原理

检测 JavaScript 内存泄漏的核心思想是**观察内存变化趋势**：

- **内存泄漏特征**：内存持续升高，不断增长，没有下降趋势
- **正常情况特征**：内存呈锯齿状变化，升高后会降下来，形成"升高→降低→升高→降低"的循环模式

判断是否存在内存泄漏，关键在于观察内存使用量是否一直保持上升趋势而不释放。

## 实战演示：创建内存泄漏场景

### 准备测试代码

创建一个 `MemoryChain.html` 文件来演示内存泄漏场景：

**HTML 结构：**
```html
<button id="btn">Start</button>
```

**JavaScript 代码：**

```javascript
// 创建一个包含 10 万个元素的大数组，模拟大数据
const arr = [];
for (let i = 0; i < 100000; i++) {
  arr.push(i);
}

// 绑定函数 - 这是造成内存泄漏的关键
function bind() {
  const obj = {
    str: JSON.stringify(arr)  // 深拷贝数组为字符串，每次都创建新数据
  };
  
  // 全局事件绑定 - 不解绑会导致内存泄漏
  window.addEventListener('resize', function() {
    console.log(obj);  // 闭包引用 obj
  });
}

// Start 按钮点击事件
let n = 0;
function start() {
  setTimeout(() => {
    bind();  // 执行绑定
    n++;
    
    if (n < 50) {
      start();  // 递归调用，执行 50 次
    }
  }, 200);  // 每次间隔 200 毫秒
}

document.getElementById('btn').addEventListener('click', start);
```

### 内存泄漏原理分析

**为什么会发生内存泄漏？**

1. **全局事件绑定**：`window.addEventListener('resize', ...)` 在全局对象上绑定事件
2. **闭包引用**：回调函数中引用了 `obj` 对象，形成闭包
3. **未解绑事件**：每次调用 `bind()` 都会新增一个事件监听器，但从未解绑
4. **对象无法销毁**：由于全局事件持有回调函数的引用，回调函数又引用了 `obj`，导致 `obj` 无法被垃圾回收
5. **累积效应**：执行 50 次后，会产生 50 个无法释放的大对象

**为什么使用 JSON.stringify？**

- 如果直接赋值 `arr`，会存在引用关系，多次引用可能指向同一个对象
- 使用 `JSON.stringify(arr)` 进行深拷贝，确保每次都创建新的数据
- 这样可以让内存增长更快、更明显，便于观察

## 使用 Performance 工具检测内存变化

### 检测步骤

**步骤 1：打开 Performance 面板**
- 在 Chrome 浏览器中打开开发者工具
- 切换到 Performance 标签

**步骤 2：准备录制**
1. 刷新页面
2. 点击**垃圾桶图标**（Collect Garbage）- 先清理现有垃圾
3. 勾选 **Memory** 选项（必须勾选才能看到内存数据）

**步骤 3：开始录制**
1. 点击左侧的**红色圆点**按钮开始录制
2. 点击页面上的 **Start** 按钮触发测试
3. 等待执行完成（50 次 × 200ms = 约 10 秒）
4. 点击 **Stop** 按钮停止录制

### 分析结果

录制完成后，查看 Performance 面板的分析结果：

**关键指标：Heap（堆内存）**

- 在图表中找到标记为 **Heap** 的蓝色细线
- 观察该线的走势：
  - **起始值**：约 3.0 MB
  - **结束值**：约 32.4 MB
  - **趋势**：持续上升，没有下降

**结论：** 内存从 3MB 持续增长到 32MB，呈现明显的上升趋势，**说明存在内存泄漏**。

### 操作技巧

- **清除录制**：点击 **Clear** 按钮清除当前录制数据
- **垃圾回收**：录制前点击垃圾桶图标，确保从干净状态开始测试
- **必须勾选 Memory**：否则看不到内存相关的数据曲线

### 内存泄漏的视觉特征

在 Performance 面板中，内存泄漏会表现为：
- Heap 曲线**持续上升**
- 没有明显的下降趋势
- 形成一条斜向上的曲线

## 正常内存释放的表现

### 富文本编辑器示例

以一个富文本编辑器（Editor）为例，演示正常的内存管理：

**测试场景：**
- 反复**创建编辑器实例** → **销毁编辑器实例**
- 编辑器代码量大（原代码几万行，压缩后几百 KB）
- 每次创建和销毁都会产生大量内存操作

**测试代码逻辑：**
```javascript
// 执行多次创建和销毁
function test() {
  // 创建编辑器
  const editor = createEditor();
  
  // 销毁编辑器
  editor.destroy();
}

// 循环执行 50 次
for (let i = 0; i < 50; i++) {
  test();
}
```

### 检测步骤（同上）

1. 点击垃圾桶图标清理垃圾
2. 设置循环次数（如 50 次）
3. 点击录制按钮
4. 点击开始按钮触发测试
5. 等待完成后点击停止

### 正常内存曲线特征

观察 Heap 曲线，会发现：

- **锯齿状波动**：上升 → 下降 → 上升 → 下降
- **有创建有释放**：内存增长后会被垃圾回收机制释放
- **整体稳定**：虽然有波动，但不会持续增长

**曲线描述：**
```
上升 上升 上升 → 下降
上升 上升 → 下降
上升 → 下降
上升 → 下降
```

### 为什么是锯齿状？

- JavaScript 的垃圾回收（GC）**不是实时的**
- GC 会在一段时间后统一清理不再使用的内存
- 因此内存会先积累增长，然后突然下降（GC 执行时刻）
- 形成规律的"升-降"模式

**这种锯齿状曲线是正常的，说明内存管理健康，没有泄漏。**

## 关键知识点总结

### 内存泄漏的常见原因

1. **全局事件监听未解绑**：`window.addEventListener` 后未调用 `removeEventListener`
2. **闭包引用**：回调函数中引用外部变量，导致变量无法释放
3. **DOM 引用**：已删除的 DOM 节点仍被 JavaScript 变量引用
4. **定时器未清除**：`setInterval`、`setTimeout` 未清理

### Performance 工具使用要点

| 操作 | 说明 |
|------|------|
| 勾选 Memory | 必须勾选才能看到内存数据 |
| 垃圾桶图标 | 手动触发垃圾回收，清理现有垃圾 |
| 红色圆点 | 开始录制性能数据 |
| Stop 按钮 | 停止录制 |
| Clear 按钮 | 清除当前录制数据 |
| Heap 曲线 | 查看堆内存变化趋势 |

### 判断标准

| 情况 | Heap 曲线特征 | 结论 |
|------|---------------|------|
| 内存泄漏 | 持续上升，无下降 | 存在内存泄漏 |
| 正常情况 | 锯齿状波动 | 内存管理健康 |

### 实际应用场景

在实际开发中，这种检测方法适用于：

- **复杂组件**：如富文本编辑器、图表库等
- **单页应用**：频繁创建销毁组件的场景
- **长时间运行**：需要长期稳定运行的页面
- **性能优化**：排查性能问题时的必备手段

**注意：** 不能仅通过看代码判断是否有内存泄漏，必须通过工具实际测试验证。

## AI 总结

本节详细讲解了如何使用 Chrome DevTools 的 Performance 面板检测 JavaScript 内存泄漏。核心要点：

**检测原理：** 通过观察内存变化趋势判断，持续上升为泄漏，锯齿状波动为正常。

**典型泄漏场景：** 演示了全局事件监听未解绑导致的内存泄漏 - 每次调用 `bind()` 都在 `window` 上绑定 `resize` 事件，闭包引用大对象，执行 50 次后内存从 3MB 增至 32MB。

**检测步骤：** ① 打开 Performance 并勾选 Memory；② 点击垃圾桶清理；③ 录制并触发测试；④ 观察 Heap 曲线走势。

**判断标准：** 持续上升曲线 = 内存泄漏；锯齿状波动 = 正常（因为 GC 是周期性执行的）。

**实战建议：** 复杂组件（如富文本编辑器）需要通过工具实测，不能仅靠代码审查判断是否存在内存泄漏。