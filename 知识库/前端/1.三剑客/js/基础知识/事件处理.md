# 事件处理与动态列表 - 学习资料

## 日常学习模式

[标签: JavaScript事件处理, let块级作用域, 闭包, DOM操作, 动态列表生成]
·
### 核心概念

#### 1. 块级作用域 vs 函数作用域

**let/const (块级作用域)**
- 变量仅在 `{}` 代码块内有效
- for循环每次迭代创建新的作用域
- 每个事件监听器引用独立的变量

**var (函数作用域)**
- 变量在整个函数内有效
- for循环所有迭代共享同一变量
- 所有事件监听器引用同一个最终值

```javascript
// let: 每个点击输出正确索引 0-9
for (let i = 0; i < 10; i++) {
  btn.onclick = () => alert(i); // 闭包捕获各自的i
}

// var: 所有点击都输出 10
for (var i = 0; i < 10; i++) {
  btn.onclick = () => alert(i); // 都引用同一个i
}
```

#### 2. 闭包机制

**定义**: 函数能访问其定义时所在作用域的变量,即使在作用域外执行

```javascript
for (let i = 0; i < 5; i++) {
  element.addEventListener('click', function(e) {
    // 这个匿名函数就是闭包
    // 它"记住"了创建时i的值
    alert(i); 
  });
}
```

**var场景的解决方案 - IIFE**
```javascript
for (var i = 0; i < 5; i++) {
  // 立即执行函数创建新作用域
  (function(savedIndex) {
    element.onclick = () => alert(savedIndex);
  })(i); // 将i作为参数传入
}
```

### DOM操作技术

#### 创建元素
```javascript
/**
 * 基础DOM创建
 */
const link = document.createElement('a');
link.textContent = '项目标题'; // 安全,防XSS
link.href = '#';
link.className = 'item-class';

// 获取容器并插入
const container = document.getElementById('list');
container.appendChild(link);
```

#### 性能优化 - DocumentFragment
```javascript
/**
 * 批量插入优化方案
 * 减少页面重排(reflow)和重绘(repaint)
 */
function createBulkList(data) {
  const fragment = document.createDocumentFragment();

  data.forEach((item, index) => {
    const element = document.createElement('div');
    element.textContent = item.name;
    // 所有元素先添加到内存中的片段
    fragment.appendChild(element);
  });

  // 一次性插入DOM,只触发1次重排
  container.appendChild(fragment);
}
```

### 事件处理

#### 基础事件绑定
```javascript
/**
 * addEventListener标准方法
 * @param {string} type - 事件类型
 * @param {Function} listener - 处理函数
 */
element.addEventListener('click', function(event) {
  event.preventDefault(); // 阻止默认行为

  // event对象包含事件详情
  console.log(event.target); // 触发元素
  console.log(event.type);   // 事件类型

  // this指向绑定元素(非箭头函数时)
  console.log(this === element); // true
});
```

#### 事件委托(推荐)
```javascript
/**
 * 适用场景: 大量子元素需要相同事件
 * 优势: 内存占用小,支持动态元素
 */
container.addEventListener('click', function(e) {
  // 判断点击的是否是目标元素
  if (e.target.classList.contains('list-item')) {
    const itemId = e.target.dataset.id;
    handleItemClick(itemId);
  }
});
```

### 完整实现模板

```javascript
/**
 * 动态列表生成器
 * @param {string} containerId - 容器ID
 * @param {Array} dataArray - 数据数组
 * @param {Function} onItemClick - 点击回调
 */
function createDynamicList(containerId, dataArray, onItemClick) {
  const container = document.getElementById(containerId);
  if (!container) {
    console.error(`容器 ${containerId} 不存在`);
    return;
  }

  // 清空容器
  container.innerHTML = '';

  // 使用文档片段优化性能
  const fragment = document.createDocumentFragment();

  dataArray.forEach((item, index) => {
    const element = document.createElement('a');
    element.textContent = item.title;
    element.href = '#';
    element.className = 'list-item';
  
    // 存储数据到元素
    element.dataset.id = item.id;
    element.dataset.index = index;
  
    // 绑定事件
    element.addEventListener('click', function(e) {
      e.preventDefault();
    
      // 高亮当前项
      container.querySelectorAll('.list-item')
        .forEach(el => el.classList.remove('active'));
      this.classList.add('active');
    
      // 执行回调
      if (onItemClick) {
        onItemClick(item, index);
      }
    });
  
    fragment.appendChild(element);
  });

  container.appendChild(fragment);
}

// 使用示例
const products = [
  { id: 1, title: '商品A' },
  { id: 2, title: '商品B' }
];

createDynamicList('product-list', products, (item, index) => {
  console.log(`点击了: ${item.title}, 索引: ${index}`);
});
```

### 关键技术点对比

| 技术 | 说明 | 使用场景 |
|------|------|----------|
| `textContent` | 纯文本,安全 | 用户输入内容 |
| `innerHTML` | 解析HTML,有XSS风险 | 可信的富文本 |
| `className` | 字符串,会覆盖 | 设置单个类 |
| `classList` | 对象,提供add/remove/toggle | 操作多个类(推荐) |

---

## 面试突击模式

### [JavaScript事件处理与作用域] 面试速记

#### 30秒电梯演讲
let具有块级作用域,for循环每次迭代创建新作用域,使每个事件监听器闭包捕获各自的变量值。var是函数作用域,所有迭代共享同一变量,导致所有监听器引用最终值。使用DocumentFragment批量操作DOM可避免多次重排重绘,事件委托将监听器绑定到父元素利用冒泡处理子元素事件。

#### 高频考点(必背)

**考点1: let vs var在循环中的差异**
let是块级作用域,每次循环迭代创建新的作用域和变量绑定,闭包捕获各自的值。var是函数作用域,整个循环共享一个变量,异步回调执行时访问的是循环结束后的最终值。解决var问题可用IIFE为每次迭代创建新作用域,或直接使用let/const。

**考点2: 闭包的本质与应用**
闭包是函数能访问其词法作用域(定义时的作用域)内的变量,即使在该作用域外执行。事件监听器就是典型闭包,它在循环中定义时捕获了当时的变量环境。闭包常用于数据私有化、柯里化、回调函数等场景。

**考点3: DOM操作性能优化**
频繁的DOM操作会触发页面重排(reflow)和重绘(repaint),严重影响性能。使用DocumentFragment可将多个元素先添加到内存中的片段,最后一次性插入DOM,将n次重排优化为1次。批量更新时还可使用display:none临时隐藏元素或使用虚拟DOM技术。

**考点4: 事件委托原理与优势**
事件委托利用事件冒泡机制,将事件监听器绑定到父元素而非每个子元素,通过event.target判断实际触发元素。优势:减少内存占用(只需1个监听器)、支持动态添加的元素、代码更简洁。适用于大量相似子元素需要相同处理的场景。

**考点5: textContent vs innerHTML安全性**
innerHTML会解析字符串中的HTML标签并执行脚本,用户输入直接赋值可导致XSS攻击。textContent只当作纯文本处理,不解析任何标签,更安全且性能略好。插入可信的富文本用innerHTML,用户内容必须用textContent或先进行HTML转义。

#### 经典面试题

**题目1: 为什么var在循环中所有点击都输出10?**

**思路**: 理解作用域差异 → 变量共享 → 异步执行时机

**答案**: var是函数作用域,for循环中的var i在整个函数内只有一个变量。循环同步执行完毕时i变为10,而事件监听器是异步触发的,点击时才执行回调函数,此时访问的i已经是循环结束后的最终值10,所以所有点击都输出10。

**代码示例**:
```javascript
/**
 * 错误示例: var导致所有点击输出10
 */
for (var i = 0; i < 10; i++) {
  btn[i].onclick = function() {
    alert(i); // 所有都输出10
  };
}

/**
 * 正确方案1: 使用let
 */
for (let i = 0; i < 10; i++) {
  btn[i].onclick = function() {
    alert(i); // 输出各自的0-9
  };
}

/**
 * 正确方案2: IIFE创建新作用域
 */
for (var i = 0; i < 10; i++) {
  (function(savedIndex) {
    btn[savedIndex].onclick = function() {
      alert(savedIndex); // 输出各自的0-9
    };
  })(i);
}
```

---

**题目2: 如何实现点击高亮当前项,其他项取消高亮?**

**思路**: 事件委托 → 遍历移除类 → 当前项添加类

**答案**: 使用事件委托在父容器绑定点击事件,判断点击目标是否为列表项。如果是,先遍历所有列表项移除active类,再给当前点击项添加active类。这样确保同时只有一个高亮项,且支持动态添加的元素。

**代码示例**:
```javascript
/**
 * 单选高亮实现
 * @param {HTMLElement} container - 列表容器
 * @param {string} itemSelector - 列表项选择器
 */
container.addEventListener('click', function(e) {
  // 检查点击的是否是列表项
  const clickedItem = e.target.closest(itemSelector);
  if (!clickedItem) return;

  // 移除所有项的active类
  this.querySelectorAll(itemSelector).forEach(item => {
    item.classList.remove('active');
  });

  // 给当前项添加active类
  clickedItem.classList.add('active');
});
```

---

**题目3: 循环创建1000个元素如何优化性能?**

**思路**: 问题分析(频繁DOM操作) → DocumentFragment → 批量插入

**答案**: 直接在循环中appendChild会触发1000次DOM操作,每次都可能导致重排重绘。应使用DocumentFragment,先将所有元素添加到内存中的片段,循环结束后一次性appendChild到真实DOM,将1000次DOM操作优化为1次,大幅提升性能。

**代码示例**:
```javascript
/**
 * 高性能批量创建元素
 * @param {Array} dataArray - 数据数组
 * @param {HTMLElement} container - 容器元素
 */
function createBulkElements(dataArray, container) {
  // 创建文档片段(存在于内存)
  const fragment = document.createDocumentFragment();

  // 循环在片段中创建元素,不触发DOM操作
  dataArray.forEach((item, index) => {
    const element = document.createElement('div');
    element.textContent = item.name;
    element.className = 'list-item';
    element.dataset.id = item.id;
  
    // 添加到片段,不是真实DOM
    fragment.appendChild(element);
  });

  // 一次性插入,只触发1次重排
  container.appendChild(fragment);
}

// 使用示例
const data = Array.from({ length: 1000 }, (_, i) => ({
  id: i,
  name: `项目${i}`
}));
createBulkElements(data, document.getElementById('container'));
```

---

**题目4: 实现事件委托处理动态列表的删除功能**

**思路**: 父容器监听 → 判断删除按钮 → 移除DOM → 通知后端

**答案**: 在父容器绑定点击事件,通过event.target判断是否点击删除按钮。如果是,找到按钮所在的列表项元素,调用remove()从DOM移除,同时获取该项的ID向后端发送DELETE请求删除数据。事件委托确保动态添加的列表项也能正常删除。

**代码示例**:
```javascript
/**
 * 事件委托实现删除功能
 * @param {HTMLElement} listContainer - 列表容器
 */
listContainer.addEventListener('click', async function(e) {
  // 检查点击的是否是删除按钮
  if (!e.target.classList.contains('delete-btn')) return;

  // 找到按钮所在的列表项
  const listItem = e.target.closest('.list-item');
  if (!listItem) return;

  // 获取项目ID
  const itemId = listItem.dataset.id;

  // 确认删除
  if (!confirm('确定删除吗?')) return;

  try {
    // 从DOM移除
    listItem.remove();
  
    // 通知后端删除
    await fetch(`/api/items/${itemId}`, {
      method: 'DELETE'
    });
  
    console.log(`项目 ${itemId} 已删除`);
  } catch (error) {
    console.error('删除失败:', error);
    // 删除失败可以重新插入元素
  }
});

/**
 * 列表项HTML结构
 */
function createListItem(item) {
  return `
    <div class="list-item" data-id="${item.id}">
      <span>${item.name}</span>
      <button class="delete-btn">删除</button>
    </div>
  `;
}
```

---

**题目5: 解释闭包并举例说明内存泄漏风险**

**思路**: 闭包定义 → 作用域链 → 内存泄漏场景 → 解决方案

**答案**: 闭包是函数能访问其外部作用域变量,即使外部函数已执行完毕,内部函数仍保持对外部变量的引用。这通过作用域链实现。风险:如果闭包引用大对象且长期存在(如全局事件监听器),会导致这些对象无法被垃圾回收,造成内存泄漏。解决:及时移除不需要的监听器,避免闭包引用不必要的大对象。

**代码示例**:
```javascript
/**
 * 闭包基本示例
 */
function createCounter() {
  let count = 0; // 外部变量

  // 返回的函数形成闭包,持有count的引用
  return function() {
    return ++count;
  };
}
const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2

/**
 * 内存泄漏风险场景
 */
function setupHeavyListener() {
  // 大对象
  const hugeData = new Array(1000000).fill('data');

  // 全局监听器持有hugeData的引用
  document.body.addEventListener('click', function() {
    // 闭包引用hugeData,导致无法释放
    console.log(hugeData[0]);
  });
  // setupHeavyListener执行完毕,但hugeData仍在内存中
}

/**
 * 正确做法: 及时清理
 */
function setupListenerCorrectly() {
  const hugeData = new Array(1000000).fill('data');

  function handleClick() {
    console.log(hugeData[0]);
  }

  document.body.addEventListener('click', handleClick);

  // 在适当时机移除监听器
  return function cleanup() {
    document.body.removeEventListener('click', handleClick);
    // 此时hugeData可以被垃圾回收
  };
}
const cleanup = setupListenerCorrectly();
// 不再需要时调用
cleanup();
```

---

**题目6: textContent和innerHTML的区别及安全性问题**

**思路**: 功能差异 → XSS攻击原理 → 安全实践

**答案**: textContent只处理纯文本,不解析HTML标签,赋值时会转义特殊字符,安全且性能好。innerHTML解析并执行HTML字符串,包括script标签,用户输入直接赋值可导致XSS(跨站脚本)攻击。安全实践:用户内容必须用textContent或先HTML转义,可信的富文本才用innerHTML。

**代码示例**:
```javascript
/**
 * textContent vs innerHTML 对比
 */
const div = document.createElement('div');

// textContent: 作为纯文本处理
div.textContent = '<script>alert("XSS")</script>';
// 显示: <script>alert("XSS")</script> (不执行)

// innerHTML: 解析并执行
div.innerHTML = '<script>alert("XSS")</script>';
// 脚本会执行! (危险)

/**
 * XSS攻击示例
 */
function displayUserComment(comment) {
  const commentDiv = document.getElementById('comment');

  // 危险! 用户输入直接用innerHTML
  commentDiv.innerHTML = comment;
  // 如果comment是: <img src=x onerror="alert('XSS')">
  // 代码会执行!
}

/**
 * 安全做法
 */
function displayUserCommentSafely(comment) {
  const commentDiv = document.getElementById('comment');

  // 安全! textContent不解析HTML
  commentDiv.textContent = comment;
  // 恶意代码只会显示为文本,不会执行
}

/**
 * HTML转义工具函数
 */
function escapeHtml(unsafe) {
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

// 使用转义后可以安全使用innerHTML
commentDiv.innerHTML = escapeHtml(userInput);
```

---

**题目7: 如何实现分页加载或无限滚动?**

**思路**: 后端分页 → 前端维护状态 → 监听触发条件 → 追加数据

**答案**: 后端API支持分页参数(page,limit)。前端维护当前页码和总数据。分页加载:点击"加载更多"按钮时页码加1,请求新数据追加到列表。无限滚动:监听scroll事件或用IntersectionObserver监听列表末尾哨兵元素,进入视窗时自动加载下一页。注意防抖避免重复请求,显示loading状态。

**代码示例**:
```javascript
/**
 * 分页加载实现
 */
class PaginatedList {
  constructor(containerId, apiUrl) {
    this.container = document.getElementById(containerId);
    this.apiUrl = apiUrl;
    this.currentPage = 1;
    this.pageSize = 20;
    this.isLoading = false;
    this.hasMore = true;
  }

  /**
   * 加载指定页数据
   */
  async loadPage() {
    if (this.isLoading || !this.hasMore) return;
  
    this.isLoading = true;
    this.showLoading();
  
    try {
      const response = await fetch(
        `${this.apiUrl}?page=${this.currentPage}&limit=${this.pageSize}`
      );
      const data = await response.json();
    
      // 渲染新数据
      this.renderItems(data.items);
    
      // 更新状态
      this.currentPage++;
      this.hasMore = data.hasMore;
    
    } catch (error) {
      console.error('加载失败:', error);
    } finally {
      this.isLoading = false;
      this.hideLoading();
    }
  }

  /**
   * 渲染列表项
   */
  renderItems(items) {
    const fragment = document.createDocumentFragment();
    items.forEach(item => {
      const div = document.createElement('div');
      div.textContent = item.name;
      div.className = 'list-item';
      fragment.appendChild(div);
    });
    this.container.appendChild(fragment);
  }

  showLoading() {
    // 显示loading图标
  }

  hideLoading() {
    // 隐藏loading图标
  }
}

/**
 * 无限滚动实现
 */
class InfiniteScrollList extends PaginatedList {
  constructor(containerId, apiUrl) {
    super(containerId, apiUrl);
    this.setupInfiniteScroll();
  }

  /**
   * 设置无限滚动监听
   */
  setupInfiniteScroll() {
    // 创建哨兵元素
    const sentinel = document.createElement('div');
    sentinel.id = 'scroll-sentinel';
    this.container.appendChild(sentinel);
  
    // 使用IntersectionObserver监听
    const observer = new IntersectionObserver(
      entries => {
        // 哨兵进入视窗时加载
        if (entries[0].isIntersecting) {
          this.loadPage();
        }
      },
      { threshold: 0.1 } // 10%进入即触发
    );
  
    observer.observe(sentinel);
  }
}

// 使用示例
const list = new InfiniteScrollList('product-list', '/api/products');
list.loadPage(); // 加载第一页
```

---

**题目8: className和classList有什么区别?**

**思路**: 数据类型 → 操作方式 → 使用场景

**答案**: className是字符串属性,赋值会覆盖所有类,追加需要字符串拼接,容易出错。classList是DOMTokenList对象,提供add/remove/toggle/contains等方法,操作更安全方便,是现代开发推荐方式。className适合一次性设置单个类,classList适合动态操作多个类。

**代码示例**:
```javascript
/**
 * className操作
 */
const element = document.getElementById('box');

// 设置类(覆盖所有)
element.className = 'active';

// 追加类(容易出错)
element.className += ' highlight'; // 注意前面的空格
element.className = element.className + ' focus'; // 繁琐

// 移除类(很麻烦)
element.className = element.className
  .split(' ')
  .filter(c => c !== 'active')
  .join(' ');

/**
 * classList操作(推荐)
 */
// 添加单个或多个类
element.classList.add('active');
element.classList.add('active', 'highlight', 'focus');

// 移除类
element.classList.remove('active');
element.classList.remove('active', 'highlight');

// 切换类(有则删,无则加)
element.classList.toggle('active');

// 检查是否包含类
if (element.classList.contains('active')) {
  console.log('元素是激活状态');
}

// 替换类
element.classList.replace('old-class', 'new-class');

/**
 * 实用场景: 主题切换
 */
function toggleTheme() {
  const body = document.body;

  // toggle返回boolean,表示切换后是否包含该类
  const isDark = body.classList.toggle('dark-theme');

  // 保存用户偏好
  localStorage.setItem('theme', isDark ? 'dark' : 'light');
}

/**
 * 实用场景: Tab切换
 */
function switchTab(clickedTab) {
  const tabs = document.querySelectorAll('.tab');

  // 移除所有tab的active类
  tabs.forEach(tab => tab.classList.remove('active'));

  // 给点击的tab添加active类
  clickedTab.classList.add('active');
}
```

---

**题目9: 事件处理函数中this的指向问题**

**思路**: 普通函数vs箭头函数 → addEventListener的this → bind改变this

**答案**: 普通函数作为addEventListener回调时,this指向触发事件的DOM元素。箭头函数没有自己的this,继承外层作用域的this。如需在事件处理函数中使用组件的this,可用箭头函数或bind()方法。event.target始终指向实际触发事件的元素,event.currentTarget指向绑定监听器的元素。

**代码示例**:
```javascript
/**
 * 普通函数: this指向DOM元素
 */
const button = document.getElementById('btn');

button.addEventListener('click', function(e) {
  console.log(this === button); // true
  console.log(this === e.currentTarget); // true
  this.textContent = '已点击'; // 可以直接操作元素
});

/**
 * 箭头函数: this继承外层
 */
const component = {
  name: '计数器',
  count: 0,

  init() {
    const button = document.getElementById('btn');
  
    // 箭头函数,this指向component对象
    button.addEventListener('click', (e) => {
      this.count++; // this是component
      console.log(this.name, this.count);
    
      // 需要操作DOM用e.currentTarget
      e.currentTarget.textContent = this.count;
    });
  }
};

/**
 * 使用bind改变this
 */
class Counter {
  constructor() {
    this.count = 0;
    this.button = document.getElementById('btn');
  
    // bind创建新函数,永久绑定this为Counter实例
    this.button.addEventListener('click', this.handleClick.bind(this));
  }

  handleClick(event) {
    this.count++; // this是Counter实例
    event.currentTarget.textContent = this.count;
  }
}

/**
 * target vs currentTarget
 */
document.getElementById('parent').addEventListener('click', function(e) {
  console.log('触发元素:', e.target); // 实际点击的子元素
  console.log('监听元素:', e.currentTarget); // parent元素
  console.log('this:', this); // parent元素(同currentTarget)
});

/**
 * 实用场景: 组件方法作为回调
 */
class TodoList {
  constructor() {
    this.todos = [];
    this.container = document.getElementById('todo-list');
    this.setupEvents();
  }

  setupEvents() {
    // 方案1: 箭头函数
    this.container.addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-btn')) {
        this.deleteTodo(e.target.dataset.id);
      }
    });
  
    // 方案2: bind
    // this.container.addEventListener('click', 
    //   this.handleClick.bind(this)
    // );
  }

  deleteTodo(id) {
    // 这里的this正确指向TodoList实例
    this.todos = this.todos.filter(todo => todo.id !== id);
    this.render();
  }
}
```

---

**题目10: 如何实现点击列表项异步获取详情并显示?**

**思路**: 绑定点击 → 获取标识 → 异步请求 → 处理loading/error → 更新UI

**答案**: 在列表项上使用data-id存储标识,点击时通过dataset获取。发起fetch请求到后端API获取详情数据,请求期间显示loading状态。成功后将数据填充到模态框或详情区域显示,失败则提示错误。使用async/await处理异步流程,try-catch捕获异常。

**代码示例**:
```javascript
/**
 * 异步获取并显示详情
 * @param {string} listId - 列表容器ID
 * @param {string} detailId - 详情显示区域ID
 */
class DetailViewer {
  constructor(listId, detailId) {
    this.listContainer = document.getElementById(listId);
    this.detailContainer = document.getElementById(detailId);
    this.currentRequest = null; // 用于取消请求
    this.setupListeners();
  }

  /**
   * 设置事件监听(使用事件委托)
   */
  setupListeners() {
    this.listContainer.addEventListener('click', async (e) => {
      // 找到被点击的列表项
      const listItem = e.target.closest('[data-id]');
      if (!listItem) return;
    
      const itemId = listItem.dataset.id;
      await this.loadDetail(itemId);
    });
  }

  /**
   * 加载详情数据
   * @param {string} id - 项目ID
   */
  async loadDetail(id) {
    // 取消之前的请求(如果有)
    if (this.currentRequest) {
      this.currentRequest.abort();
    }
  
    // 显示loading状态
    this.showLoading();
  
    // 创建可取消的请求
    const controller = new AbortController();
    this.currentRequest = controller;
  
    try {
      const response = await fetch(`/api/items/${id}`, {
        signal: controller.signal
      });
    
      if (!response.ok) {
        throw new Error(`HTTP错误: ${response.status}`);
      }
    
      const data = await response.json();
    
      // 渲染详情
      this.renderDetail(data);
    
    } catch (error) {
      // 忽略取消请求的错误
      if (error.name === 'AbortError') {
        console.log('请求已取消');
        return;
      }
    
      // 显示错误信息
      this.showError(error.message);
    
    } finally {
      this.currentRequest = null;
      this.hideLoading();
    }
  }

  /**
   * 渲染详情内容
   * @param {Object} data - 详情数据
   */
  renderDetail(data) {
    this.detailContainer.innerHTML = `
      <div class="detail-card">
        <h2>${this.escapeHtml(data.title)}</h2>
        <img src="${data.imageUrl}" alt="${this.escapeHtml(data.title)}">
        <p class="description">${this.escapeHtml(data.description)}</p>
        <div class="meta">
          <span>价格: ¥${data.price}</span>
          <span>库存: ${data.stock}</span>
        </div>
        <button class="close-btn">关闭</button>
      </div>
    `;
  
    // 显示详情区域
    this.detailContainer.classList.add('visible');
  
    // 绑定关闭按钮
    this.detailContainer.querySelector('.close-btn')
      .addEventListener('click', () => this.hideDetail());
  }

  /**
   * 显示loading状态
   */
  showLoading() {
    this.detailContainer.innerHTML = `
      <div class="loading">
        <div class="spinner"></div>
        <p>加载中...</p>
      </div>
    `;
    this.detailContainer.classList.add('visible');
  }

  /**
   * 隐藏loading
   */
  hideLoading() {
    const loading = this.detailContainer.querySelector('.loading');
    if (loading) loading.remove();
  }

  /**
   * 显示错误信息
   * @param {string} message - 错误消息
   */
  showError(message) {
    this.detailContainer.innerHTML = `
      <div class="error">
        <p>加载失败: ${this.escapeHtml(message)}</p>
        <button class="retry-btn">重试</button>
      </div>
    `;
  }

  /**
   * 隐藏详情
   */
  hideDetail() {
    this.detailContainer.classList.remove('visible');
    this.detailContainer.innerHTML = '';
  }

  /**
   * HTML转义防止XSS
   * @param {string} text - 待转义文本
   */
  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

/**
 * 使用示例
 */
// HTML结构
// <div id="product-list">
//   <div class="list-item" data-id="1">商品A</div>
//   <div class="list-item" data-id="2">商品B</div>
// </div>
// <div id="product-detail"></div>

// 初始化
const viewer = new DetailViewer('product-list', 'product-detail');

/**
 * 简化版实现
 */
async function quickShowDetail(itemId) {
  const modal = document.getElementById('modal');
  modal.innerHTML = '<div class="loading">加载中...</div>';
  modal.style.display = 'block';

  try {
    const res = await fetch(`/api/items/${itemId}`);
    const data = await res.json();
  
    modal.innerHTML = `
      <h2>${data.title}</h2>
      <p>${data.description}</p>
      <button onclick="closeModal()">关闭</button>
    `;
  } catch (err) {
    modal.innerHTML = `<p>加载失败: ${err.message}</p>`;
  }
}
```

---

### 快速记忆口诀

**作用域三句话**
- let块级独立,var函数共享
- 闭包捕获词法,异步访问当前
- IIFE新建作用,传参保存快照

**DOM操作三原则**
- 批量用Fragment,减少重排痛
- 文本用textContent,防止XSS攻
- 委托绑父级,动态也能通

**事件处理三要点**
- preventDefault阻默认
- target是触发,currentTarget是绑定
- 普通函数this是元素,箭头继承上层境

---

### 面试加分项

**展示深度理解**
- 主动提及性能优化(DocumentFragment、事件委托)
- 说明安全考虑(XSS防护、HTML转义)
- 讨论现代最佳实践(let/const、classList、async/await)

**结合实际经验**
- "在我之前的项目中,遇到过大数据量列表卡顿,通过虚拟滚动和DocumentFragment优化后FPS提升了50%"
- "我们的评论系统曾遭受XSS攻击,之后所有用户输入都改用textContent处理"

**主动扩展思考**
- 提及框架中的实现(React的虚拟DOM、Vue的响应式)
- 讨论可访问性(ARIA属性、键盘导航)
- 考虑边界情况(网络失败重试、并发请求处理)