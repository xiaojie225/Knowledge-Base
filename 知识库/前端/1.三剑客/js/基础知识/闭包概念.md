
### **日常学习模式**

[标签: JavaScript 闭包]

#### **一、核心定义**

闭包 (Closure) 是指一个函数能够记住并访问其**词法作用域**(即定义时所在的作用域)的能力,即使该函数在其词法作用域之外被执行。本质上,闭包是由**函数**以及该函数被创建时所能访问的**自由变量**(定义在外部作用域的变量)共同组成的组合体。

#### **二、原理解析**

JavaScript 闭包的核心原理基于其**词法作用域 (Lexical Scoping)** 规则。

1.  **作用域链**: 当一个函数被**定义**时,它会保存一个对其外部作用域的引用,形成一条作用域链。
2.  **变量查找**: 当函数执行并需要访问一个变量时,它会首先在自己的局部作用域中查找。如果找不到,就会沿着作用域链向上,到外部作用域中查找,直至全局作用域。
3.  **生命周期**: 闭包的存在使得外部函数的局部变量在外部函数执行完毕后,不会被垃圾回收机制销毁,因为闭包函数仍然持有对这些变量的引用。

**关键法则**: 自由变量的查找是在**函数定义的地方**向上级作用域查找,而不是在**函数执行的地方**查找。

#### **三、两大经典场景**

##### **场景1: 函数作为返回值**

当一个函数返回其内部定义的另一个函数时,内部函数就形成了一个闭包,因为它“记住”了外部函数的变量。

*   **核心伪代码示例**:
    ```javascript
    /**
     * @description 创建一个闭包的通用模式
     * @param {any} initialValue 外部函数接收的初始值
     * @returns {Function} 一个闭包函数,它能够访问 initialValue
     */
    function outerFunction(initialValue) {
      // privateVariable 是一个自由变量,被内部函数捕获
      let privateVariable = initialValue;

      // 这个返回的函数就是闭包
      return function innerFunction() {
        // 它可以访问和操作 privateVariable
        console.log(privateVariable);
      };
    }

    // 执行外部函数,返回闭包
    const closureInstance = outerFunction(100);

    // 在外部函数作用域之外执行闭包
    closureInstance(); // 输出: 100
    ```
*   **分析**: `closureInstance` 是 `outerFunction` 返回的 `innerFunction`。即使 `outerFunction` 已经执行完毕,`closureInstance` 依然可以访问 `privateVariable`,因为在它被定义时,其作用域链已经包含了 `outerFunction` 的作用域。

##### **场景2: 函数作为参数**

当一个函数作为参数传递给另一个函数时,它仍然遵循其定义时的作用-域链,而不是执行时的作用域。

*   **核心代码示例**:
    ```javascript
    // 全局作用域
    const globalVar = 100;

    // a. fn 在全局作用域定义,捕获了 globalVar
    function fn() {
      console.log(globalVar); // 查找的是定义时作用域链上的 globalVar
    }

    function executor(func) {
      // executor 函数内部有同名变量,但不会影响 fn
      const globalVar = 200;
      func(); // b. 在这里执行 fn
    }

    executor(fn); // 输出: 100
    ```
*   **分析**: `fn` 函数在全局作用域定义,所以它要查找的 `globalVar` 是全局的那个(值为100)。尽管它在 `executor` 函数内部被调用,但 `executor` 的局部变量 `globalVar` (值为200) 并不在 `fn` 的作用域链上。

#### **四、核心应用场景**

1.  **数据私有化 (封装)**: 利用闭包创建私有变量,只能通过暴露的特定方法进行访问和修改,防止外部直接篡改。
    ```javascript
    function createCache() {
        const data = {}; // 私有变量,外部无法直接访问
        return {
            set: (key, val) => data[key] = val,
            get: (key) => data[key],
        };
    }
    const myCache = createCache();
    myCache.set('user', 'Alice');
    console.log(myCache.get('user')); // "Alice"
    // console.log(myCache.data); // undefined, 无法访问
    ```
2.  **创建函数工厂**: 根据不同参数生成功能相似但行为不同的函数。
    ```javascript
    function createMultiplier(factor) {
      return function(number) {
        return number * factor;
      };
    }
    const double = createMultiplier(2);
    const triple = createMultiplier(3);
    console.log(double(5)); // 10
    console.log(triple(5)); // 15
    ```

#### **五、注意事项**

*   **内存占用**: 由于闭包会引用外部作用域的变量,导致这些变量无法被垃圾回收。如果滥用闭包或闭包捕获了大量数据,可能导致内存占用增加。
    *   **解决方法**: 在不需要闭包时,将其引用的变量设置为 `null`,以便垃圾回收器回收内存。
*   **循环中的闭包问题**: 在循环中使用 `var` 声明迭代变量时,所有闭包会共享同一个变量的最终值。
    *   **解决方法**: 使用 `let` 或 `const` 创建块级作用域,为每次循环迭代创建一个新的变量实例。

---

### **面试突击模式**

[JavaScript 闭包] 面试速记

#### **30秒电梯演讲**

闭包是JS的一个核心特性,它允许一个函数访问并操作其定义时所在作用域(词法作用域)的变量,即使这个函数在定义的作用域之外被调用。它的本质是一个函数和其引用的外部变量的组合体,主要应用在数据封装、创建私有变量和模块化开发中,但也需要注意可能引起的内存占用问题。

#### **高频考点 (必背)**

*   **[考点1]: 什么是闭包?**
    一个函数和它所引用的词法环境(即外部作用域的变量)的组合就是闭包。简单说,就是函数能够“记住”它被创建时的环境,即使它在别处被执行。

*   **[考点2]: 闭包的原理是什么?**
    基于JavaScript的词法作用域规则。函数在定义时就确定了它的作用域链,闭包函数会持有对其外部作用域的引用,所以即使外部函数执行完毕,其作用域中的变量因为被闭包引用而不会被垃圾回收,从而可以在之后被闭包访问。

*   **[考点3]: 闭包有什么优缺点和应用场景?**
    *   **优点/应用**: 创建私有变量,实现数据封装和信息隐藏(如模块化); 让变量的生命周期得以延续。
    *   **缺点**: 可能导致内存占用,因为闭包引用的变量不会被及时回收。在不再需要时,应手动解除引用(赋值为null)来释放内存。

*   **[考点4]: 循环中闭包的经典问题是什么?**
    在 `for` 循环中使用 `var` 时,所有循环内创建的函数(如事件监听器)会共享同一个 `i` 变量。因为 `var` 是函数作用域,循环结束后 `i` 变为最终值,导致所有函数执行时都使用这个最终值。使用 `let` 可以解决,因为 `let` 是块级作用域,每次循环都会创建一个新的 `i` 实例。

#### **经典面试题**

**题目1: 以下代码会输出什么?**
```javascript
function create() {
    const a = 100;
    return function () {
        console.log(a);
    }
}
const fn = create();
const a = 200;
fn();
```
*   **思路**: `fn` 是由 `create` 函数返回的闭包。根据词法作用域规则,它绑定的 `a` 是在它定义时能访问到的,也就是 `create` 函数内部的 `a=100`。全局的 `a=200` 不在它的作用域链上。
*   **答案**: `100`

**题目2: 改造下面的代码,让它按顺序输出 0, 1, 2, 3, 4**
```javascript
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}
```
*   **思路**: 原代码会输出5个5,因为`setTimeout`是异步的,执行时循环早已结束,`i` 已变成5。需要为每次循环创建一个独立的变量作用域。
*   **答案**: 最简单的方法是将 `var` 改为 `let`。
*   **代码框架**:
    ```javascript
    /**
     * @description 使用 let 解决循环闭包问题
     */
    for (let i = 0; i < 5; i++) {
      setTimeout(function() {
        console.log(i);
      }, 1000);
    }
    ```
    (或者使用立即执行函数 IIFE 创建闭包来捕获每次循环的 `i` 值)

**题目3: 实现一个私有计数器 `counter`**
```javascript
/**
 * @description 实现一个函数,每次调用返回值都会加1
 * const c = createCounter();
 * c(); // 1
 * c(); // 2
 */
```
*   **思路**: 利用闭包将计数变量封装在外部函数中,返回一个可以访问并修改该变量的内部函数。
*   **答案**:
*   **代码框架**:
    ```javascript
    /**
     * @description 使用闭包创建一个私有计数器
     * @returns {function(): number} 返回一个函数,每次调用计数器加一
     */
    function createCounter() {
      let count = 0; // 私有变量
      return function() {
        count++;
        return count;
      };
    }

    const counter = createCounter();
    console.log(counter()); // 1
    console.log(counter()); // 2
    ```

---

**题目4: 以下代码会输出什么?**
```javascript
function createCounter() {
    let count = 0;
    return {
        increment: function() {
            count++;
            console.log(count);
        },
        decrement: function() {
            count--;
            console.log(count);
        }
    };
}

const counterA = createCounter();
const counterB = createCounter();

counterA.increment(); // ?
counterA.increment(); // ?
counterB.decrement(); // ?
counterA.decrement(); // ?
```
*   **思路**: 每次调用 `createCounter()` 都会创建一个全新的作用域和全新的 `count` 变量。`counterA` 和 `counterB` 是两个独立的实例,它们各自拥有一个私有的、互不影响的 `count` 闭包变量。因此,对 `counterA` 的操作只影响它自己的 `count`,对 `counterB` 的操作也同理。
*   **答案**:
    ```
    1
    2
    -1
    1
    ```

**题目5: 实现一个 `once` 函数, 确保一个函数只能被执行一次**
```javascript
/**
 * @description 创建一个只执行一次的函数。
 * @param {Function} func 需要被包装的函数。
 * @returns {Function} 一个新的函数,该函数只能被成功调用一次。
 */
function once(func) {
    // ... your code here
}

const greet = (name) => console.log(`Hello, ${name}!`);
const onceGreet = once(greet);
onceGreet('Alice'); // 应该输出 "Hello, Alice!"
onceGreet('Bob');   // 不应该有任何输出
```
*   **思路**: 利用闭包创建一个标志位变量 (如 `hasBeenCalled`) 和一个用于存储结果的变量。返回的新函数在每次执行前检查这个标志位。如果从未调用过,则执行原函数,更新标志位,保存结果,并返回结果。如果已经调用过,则直接返回保存的结果。
*   **答案**:
    ```javascript
    /**
     * @description 创建一个只执行一次的函数。
     * @param {Function} func 需要被包装的函数。
     * @returns {Function} 一个新的函数,该函数只能被成功调用一次。
     */
    function once(func) {
      let hasBeenCalled = false; // 闭包中的私有状态
      let result;

      return function(...args) {
        if (!hasBeenCalled) {
          hasBeenCalled = true;
          result = func.apply(this, args);
          return result;
        }
        return result; // 后续调用返回第一次的结果
      };
    }
    ```

**题目6: 以下代码会输出什么?**
```javascript
function print(fn) {
    const a = 200;
    fn();
}
const a = 100;
function fn() {
    console.log(a);
}
print(fn);
```
*   **思路**: 这是检验闭包核心原理的经典题目。函数 `fn` 在**全局作用域**中定义,因此它的作用域链顶层是全局作用域。当它查找自由变量 `a` 时,会沿着其定义时的作用域链向上查找,找到全局变量 `a` (值为100)。它执行时的环境(在 `print` 函数内部,其中有 `a = 200`)不会影响它的变量查找。
*   **答案**: `100`

**题目7: 使用闭包实现一个简单的缓存/记忆化函数**
```javascript
/**
 * @description 实现一个记忆化函数,用于缓存计算结果。
 * @param {Function} fn 需要被记忆化的纯函数。
 * @returns {Function} 一个新的带有缓存功能的函数。
 */
function memoize(fn) {
    // ... your code here
}

const slowSquare = (num) => {
    console.log('Calculating...');
    return num * num;
};
const fastSquare = memoize(slowSquare);
console.log(fastSquare(5)); // 'Calculating...' 然后输出 25
console.log(fastSquare(5)); // 直接输出 25, 不再打印 'Calculating...'
```
*   **思路**: 利用闭包创建一个私有的缓存对象 (如 `cache`)。返回的函数在执行时,先用参数作为 `key` 检查缓存中是否存在结果。如果存在,直接返回缓存值;如果不存在,则执行原函数计算结果,将结果存入缓存,然后再返回。
*   **答案**:
    ```javascript
    /**
     * @description 实现一个记忆化函数,用于缓存计算结果。
     * @param {Function} fn 需要被记忆化的纯函数。
     * @returns {Function} 一个新的带有缓存功能的函数。
     */
    function memoize(fn) {
      const cache = {}; // 闭包中的私有缓存
      return function(...args) {
        const key = JSON.stringify(args); // 将参数序列化作为key
        if (cache[key]) {
          return cache[key];
        } else {
          const result = fn.apply(this, args);
          cache[key] = result;
          return result;
        }
      };
    }
    ```

**题目8: 闭包可能导致内存泄漏吗? 如何避免?**
*   **思路**: 阐述闭包的原理,即闭包会使其外部作用域的变量持续存在于内存中。如果这个闭包被长期持有(如全局变量、DOM事件监听器),那么它引用的外部变量也无法被垃圾回收,就形成了事实上的内存泄漏。
*   **答案**:
    会。因为闭包会持有其外部函数作用域的引用,导致这些作用域中的变量在外部函数执行完毕后也无法被垃圾回收。如果闭包的生命周期很长(例如赋值给全局变量或作为DOM事件监听器),这些内存将一直被占用。
    **避免方法**: 在不再需要使用闭包时,手动将其引用解除。例如,将持有闭包的变量赋值为 `null`,或者在使用完事件监听器后及时通过 `removeEventListener` 移除。

**题目9: 以下代码每次点击会输出什么?**
```html
<button id="btn1">Button 1</button>
<button id="btn2">Button 2</button>
<script>
function setupButtons() {
    for (var i = 1; i <= 2; i++) {
        var btnId = 'btn' + i;
        var btn = document.getElementById(btnId);
        btn.addEventListener('click', function() {
            console.log('Button ' + i + ' clicked');
        });
    }
}
setupButtons();
</script>
```
*   **思路**: 这是循环闭包问题的变体。事件监听器是异步执行的。当点击事件发生时,`for` 循环早已执行完毕。由于 `i` 是用 `var` 声明的,它是一个函数作用域变量,在循环结束后,它的最终值是 `3`。两个事件监听器共享同一个 `i`,所以无论点击哪个按钮,都会输出 `3`。
*   **答案**: 无论点击哪个按钮,都会输出 `Button 3 clicked`。

**题目10: 模块化和闭包有什么关系?**
*   **思路**: 现代前端模块化的核心思想就是数据封装和私有化,而这正是闭包最经典的应用场景。
*   **答案**:
    现代JavaScript模块化(无论是 CommonJS, AMD, 还是 ES Modules)的实现都严重依赖于闭包的原理。每个模块文件本质上会形成一个独立的作用域。通过 `export` 暴露出去的变量或函数,可以访问模块内部但未被导出的"私有"变量,这正是闭包的体现。闭包为模块化提供了创建私有状态和公共接口的能力,是实现封装的基础。