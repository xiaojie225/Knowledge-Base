# JavaScript 深拷贝完整学习指南

## 日常学习模式

### [标签: JavaScript 深拷贝 DeepClone]

#### 一、核心概念

**深拷贝 vs 浅拷贝**
- **浅拷贝**:仅复制对象第一层,引用类型属性复制内存地址,修改会相互影响
- **深拷贝**:递归复制所有层级,创建完全独立的新对象,修改互不影响

#### 二、基础实现

**最简版本**
```javascript
/**
 * 基础深拷贝
 * @param {any} obj - 待拷贝对象
 * @returns {any} 拷贝后的新对象
 */
function deepClone(obj) {
    // 递归终止条件:原始类型和null直接返回
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
  
    // 根据类型初始化容器
    const result = obj instanceof Array ? [] : {};
  
    // 递归拷贝每个属性
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            result[key] = deepClone(obj[key]);
        }
    }
  
    return result;
}
```

**核心逻辑**
1. **终止条件**: 原始类型(`string/number/boolean/undefined/symbol/bigint`)和`null`直接返回
2. **容器初始化**: 数组用`[]`,对象用`{}`
3. **递归遍历**: 逐个属性深拷贝,`hasOwnProperty`过滤原型链属性

#### 三、完整实现(生产级)

```javascript
/**
 * 生产级深拷贝函数
 * 支持:循环引用、Date、RegExp、Map、Set、Symbol键
 * @param {any} target - 待拷贝目标
 * @param {WeakMap} map - 缓存已拷贝对象,解决循环引用
 * @returns {any} 拷贝结果
 */
function deepClone(target, map = new WeakMap()) {
    // 1. 原始类型和null直接返回
    if (target === null || typeof target !== 'object') {
        return target;
    }

    // 2. 特殊对象类型处理
    if (target instanceof Date) {
        return new Date(target);
    }
    if (target instanceof RegExp) {
        return new RegExp(target.source, target.flags);
    }

    // 3. 循环引用检测:已拷贝过则直接返回缓存
    if (map.has(target)) {
        return map.get(target);
    }

    // 4. 初始化容器并缓存(必须在递归前)
    let newTarget;
    if (target instanceof Array) {
        newTarget = [];
    } else if (target instanceof Map) {
        newTarget = new Map();
    } else if (target instanceof Set) {
        newTarget = new Set();
    } else {
        newTarget = {};
    }
    map.set(target, newTarget); // 提前缓存防循环引用

    // 5. Map特殊处理:键值都需深拷贝
    if (target instanceof Map) {
        target.forEach((value, key) => {
            newTarget.set(deepClone(key, map), deepClone(value, map));
        });
        return newTarget;
    }

    // 6. Set特殊处理
    if (target instanceof Set) {
        target.forEach(value => {
            newTarget.add(deepClone(value, map));
        });
        return newTarget;
    }

    // 7. 普通对象/数组:遍历所有自有属性(包括Symbol键)
    const keys = Reflect.ownKeys(target);
    for (const key of keys) {
        const value = Reflect.get(target, key);
        Reflect.set(newTarget, key, deepClone(value, map));
    }

    return newTarget;
}
```

#### 四、关键技术点

**1. 类型判断**
```javascript
// typeof的局限性
typeof null === 'object'  // true! 历史遗留问题
typeof [] === 'object'    // true
typeof {} === 'object'    // true

// 精确判断用instanceof
target instanceof Array    // 判断数组
target instanceof Date     // 判断日期
target instanceof Map      // 判断Map
```

**2. 循环引用解决方案**
```javascript
// 问题示例
const obj = { name: 'test' };
obj.self = obj;  // 自引用
deepClone(obj);  // 不处理会栈溢出!

// WeakMap解决方案
const map = new WeakMap();
map.set(原始对象, 新对象);  // 拷贝前缓存
if (map.has(target)) return map.get(target);  // 遇到已拷贝的直接返回

// 为什么用WeakMap而不是Map?
// WeakMap的键是弱引用,原对象销毁时自动清理,避免内存泄漏
```

**3. 属性遍历方法对比**
```javascript
// for...in: 遍历自身+原型链可枚举属性,无法获取Symbol键
for (let key in obj) {
    if (obj.hasOwnProperty(key)) { ... }
}

// Object.keys(): 只返回自身可枚举字符串键
Object.keys(obj).forEach(key => { ... });

// Reflect.ownKeys(): 最全面!返回所有自有属性(字符串+Symbol)
Reflect.ownKeys(obj);  // 推荐用于深拷贝
```

**4. 特殊类型处理**
```javascript
// Date: 传入原Date对象创建新实例
new Date(originalDate)

// RegExp: 需复制source和flags
new RegExp(reg.source, reg.flags)

// Map: 键值都需深拷贝
map.forEach((value, key) => {
    newMap.set(deepClone(key), deepClone(value));
});

// Set: 值需深拷贝
set.forEach(value => {
    newSet.add(deepClone(value));
});
```

#### 五、使用场景

1. **状态管理**: Vuex/Redux中防止直接修改store状态
2. **表单编辑**: 保存初始数据副本,取消时恢复
3. **撤销重做**: 保存历史快照
4. **数据隔离**: API数据拷贝后操作,避免污染原始数据

#### 六、完整示例

```javascript
// 构造复杂测试对象
const symKey = Symbol('test');
const complexObj = {
    // 基础类型
    str: 'hello',
    num: 123,
    bool: true,
  
    // 特殊类型
    date: new Date(),
    reg: /^\d+$/g,
  
    // 嵌套结构
    nested: {
        arr: [1, 2, { deep: 'value' }]
    },
  
    // ES6类型
    map: new Map([['k1', 'v1']]),
    set: new Set([1, 2, 3]),
  
    // Symbol键
    [symKey]: 'symbol value',
  
    // 循环引用
    self: null
};
complexObj.self = complexObj;

// 执行深拷贝
const cloned = deepClone(complexObj);

// 验证独立性
cloned.nested.arr[2].deep = 'changed';
console.log(complexObj.nested.arr[2].deep);  // 'value' 未改变
console.log(cloned.self === cloned);  // true 新对象内部循环引用
console.log(cloned.self === complexObj);  // false 完全独立
```

---

## 面试突击模式

### [JavaScript 深拷贝] 面试速记

#### 30秒电梯演讲
深拷贝是递归复制对象所有层级的过程,核心是判断类型+递归遍历。生产级实现需处理循环引用(WeakMap缓存)、特殊类型(Date/RegExp/Map/Set)和Symbol键(Reflect.ownKeys)。

#### 高频考点(必背)

**考点1: 深浅拷贝区别**
浅拷贝仅复制第一层,引用类型属性共享内存地址,修改相互影响;深拷贝递归复制所有层级,创建完全独立副本,互不影响。

**考点2: typeof null为何是object**
JavaScript历史遗留bug,底层用000开头表示对象,null全0被误判。深拷贝必须显式判断`obj === null`。

**考点3: 循环引用如何处理**
用WeakMap缓存`<原对象, 新对象>`映射。拷贝前检查缓存,存在则直接返回;不存在则创建新对象并立即缓存,再递归属性。WeakMap的弱引用特性可自动回收,防内存泄漏。

**考点4: for...in的缺陷**
遍历原型链属性且无法获取Symbol键。需配合`hasOwnProperty`过滤继承属性,或用`Reflect.ownKeys()`直接获取所有自有属性(含Symbol)。

**考点5: 常见替代方案的局限**
- `JSON.parse(JSON.stringify())`: 无法处理函数/undefined/Symbol/Date/RegExp/循环引用
- `Object.assign()`: 仅浅拷贝
- `展开运算符{...obj}`: 仅浅拷贝
- `structuredClone()`: 现代浏览器内置深拷贝,但不支持函数

#### 经典面试题

**题目1: 实现基础版深拷贝**
**思路**: 递归终止条件→类型判断→容器初始化→属性遍历
**答案**: 判断原始类型直接返回;根据Array/Object初始化容器;for...in+hasOwnProperty遍历自有属性并递归拷贝。
```javascript
/**
 * 基础深拷贝
 * @param {any} obj - 待拷贝对象
 * @returns {any} 新对象
 */
function deepClone(obj) {
    // 终止条件:原始类型和null
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
  
    // 初始化容器
    const result = Array.isArray(obj) ? [] : {};
  
    // 递归拷贝属性
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            result[key] = deepClone(obj[key]);
        }
    }
  
    return result;
}
```

**题目2: 为什么需要hasOwnProperty?**
**思路**: for...in会遍历原型链
**答案**: for...in遍历对象自身及原型链上所有可枚举属性,不加hasOwnProperty会拷贝继承属性(如Array.prototype方法),造成数据污染。
```javascript
const arr = [1, 2];
for (let key in arr) {
    console.log(key);  // 0, 1, 及原型链上的方法
}
// hasOwnProperty过滤只保留0和1
```

**题目3: 如何处理循环引用?**
**思路**: 缓存已拷贝对象避免重复递归
**答案**: 用WeakMap存储`<原对象, 新对象>`。拷贝前先查缓存,存在直接返回;不存在则创建新对象并立即存入缓存(关键!),再递归属性。
```javascript
/**
 * 处理循环引用的深拷贝
 * @param {any} target - 待拷贝对象
 * @param {WeakMap} map - 缓存映射
 * @returns {any} 新对象
 */
function deepClone(target, map = new WeakMap()) {
    if (typeof target !== 'object' || target === null) {
        return target;
    }
  
    // 检查缓存,已拷贝则直接返回
    if (map.has(target)) {
        return map.get(target);
    }
  
    // 创建容器并立即缓存(防止递归死循环)
    const result = Array.isArray(target) ? [] : {};
    map.set(target, result);
  
    // 递归拷贝
    for (let key in target) {
        if (target.hasOwnProperty(key)) {
            result[key] = deepClone(target[key], map);
        }
    }
  
    return result;
}

// 测试循环引用
const obj = { a: 1 };
obj.self = obj;
const cloned = deepClone(obj);  // 成功!不会栈溢出
```

**题目4: 如何拷贝Date对象?**
**思路**: Date的typeof是object,需特殊处理
**答案**: 用instanceof判断,通过`new Date(原Date对象)`创建新实例。
```javascript
/**
 * 支持Date的深拷贝
 */
function deepClone(target, map = new WeakMap()) {
    if (typeof target !== 'object' || target === null) {
        return target;
    }
  
    // Date特殊处理
    if (target instanceof Date) {
        return new Date(target);
    }
  
    // 循环引用检测
    if (map.has(target)) return map.get(target);
  
    const result = Array.isArray(target) ? [] : {};
    map.set(target, result);
  
    for (let key in target) {
        if (target.hasOwnProperty(key)) {
            result[key] = deepClone(target[key], map);
        }
    }
  
    return result;
}
```

**题目5: 如何拷贝RegExp?**
**思路**: 需复制正则的模式和标志
**答案**: 通过`new RegExp(reg.source, reg.flags)`创建新正则,source是模式字符串,flags是标志(g/i/m等)。
```javascript
if (target instanceof RegExp) {
    return new RegExp(target.source, target.flags);
}

// 示例
const reg = /test/gi;
const cloned = new RegExp(reg.source, reg.flags);
console.log(cloned);  // /test/gi
```

**题目6: 如何拷贝Symbol类型的键?**
**思路**: for...in无法遍历Symbol键
**答案**: 用`Reflect.ownKeys()`获取所有自有属性(包括Symbol键),然后递归拷贝。
```javascript
/**
 * 支持Symbol键的深拷贝
 */
function deepClone(target, map = new WeakMap()) {
    if (typeof target !== 'object' || target === null) {
        return target;
    }
    if (map.has(target)) return map.get(target);
  
    const result = Array.isArray(target) ? [] : {};
    map.set(target, result);
  
    // Reflect.ownKeys获取所有键(含Symbol)
    const keys = Reflect.ownKeys(target);
    for (const key of keys) {
        result[key] = deepClone(target[key], map);
    }
  
    return result;
}

// 测试
const sym = Symbol('key');
const obj = { [sym]: 'value' };
const cloned = deepClone(obj);
console.log(cloned[sym]);  // 'value'
```

**题目7: 如何拷贝Map和Set?**
**思路**: Map/Set需调用特定API添加元素
**答案**: Map用`newMap.set(key, value)`,键值都需深拷贝;Set用`newSet.add(value)`,值需深拷贝。
```javascript
/**
 * 支持Map/Set的深拷贝
 */
function deepClone(target, map = new WeakMap()) {
    if (typeof target !== 'object' || target === null) {
        return target;
    }
    if (map.has(target)) return map.get(target);
  
    // Map处理
    if (target instanceof Map) {
        const newMap = new Map();
        map.set(target, newMap);
        target.forEach((value, key) => {
            // 键值都需深拷贝
            newMap.set(deepClone(key, map), deepClone(value, map));
        });
        return newMap;
    }
  
    // Set处理
    if (target instanceof Set) {
        const newSet = new Set();
        map.set(target, newSet);
        target.forEach(value => {
            newSet.add(deepClone(value, map));
        });
        return newSet;
    }
  
    // 其他类型...
}
```

**题目8: WeakMap vs Map的区别?**
**思路**: 键引用强度+垃圾回收
**答案**: WeakMap的键是弱引用,原对象销毁时自动清理,防内存泄漏;Map是强引用,会阻止键对象被回收。深拷贝用WeakMap更合适。
```javascript
// WeakMap示例
const wm = new WeakMap();
let obj = { a: 1 };
wm.set(obj, 'value');
obj = null;  // obj被回收,WeakMap自动清理该项

// Map会持有引用
const m = new Map();
let obj2 = { a: 1 };
m.set(obj2, 'value');
obj2 = null;  // Map仍持有原对象,无法回收
```

**题目9: JSON序列化的局限性?**
**思路**: 列举无法处理的类型
**答案**: 无法处理函数、undefined、Symbol、Date会转字符串、RegExp变空对象、循环引用报错、NaN/Infinity变null。
```javascript
const obj = {
    fn: () => {},           // 丢失
    undef: undefined,       // 丢失
    sym: Symbol('s'),       // 丢失
    date: new Date(),       // 变字符串
    reg: /test/,            // 变{}
    nan: NaN,               // 变null
    inf: Infinity           // 变null
};
const copy = JSON.parse(JSON.stringify(obj));
console.log(copy);  // { date: "2024-01-01...", reg: {} }
```

**题目10: 如何优化深拷贝性能?**
**思路**: 减少递归深度+提前终止
**答案**: 
1. 用WeakMap缓存避免重复拷贝
2. 提前判断类型,减少不必要递归
3. 使用Reflect.ownKeys代替for...in提高效率
4. 超大对象考虑迭代+栈替代递归(避免栈溢出)
```javascript
/**
 * 性能优化版深拷贝(迭代实现)
 * @param {any} target - 待拷贝对象
 * @returns {any} 新对象
 */
function deepCloneIterative(target) {
    const map = new WeakMap();
    const root = Array.isArray(target) ? [] : {};
    const stack = [{ parent: root, key: null, data: target }];
  
    while (stack.length) {
        const { parent, key, data } = stack.pop();
      
        // 原始类型直接赋值
        if (typeof data !== 'object' || data === null) {
            if (key !== null) parent[key] = data;
            continue;
        }
      
        // 循环引用检测
        if (map.has(data)) {
            parent[key] = map.get(data);
            continue;
        }
      
        // 创建容器
        const current = Array.isArray(data) ? [] : {};
        map.set(data, current);
        if (key !== null) parent[key] = current;
      
        // 将子属性入栈
        const keys = Reflect.ownKeys(data);
        for (const k of keys) {
            stack.push({ parent: current, key: k, data: data[k] });
        }
    }
  
    return root;
}
```

---

### 快速记忆口诀
1. **类型判断**: typeof判基础,instanceof分对象
2. **递归三要素**: 终止条件+容器初始化+属性遍历
3. **循环引用**: WeakMap缓存,拷贝前检查
4. **特殊类型**: Date/RegExp用new,Map/Set用forEach
5. **完整遍历**: Reflect.ownKeys获取所有键(含Symbol)