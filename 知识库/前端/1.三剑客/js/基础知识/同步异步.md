
# JavaScript同步异步执行机制-精炼版

---

## 日常学习模式

[标签: JavaScript同步异步 事件循环 Promise async/await 宏任务微任务]

### 核心概念

**同步 vs 异步**
- 同步：代码按顺序执行，阻塞后续代码
- 异步：不等待当前任务完成，继续执行后续代码

**事件循环机制（Event Loop）**
- 调用栈（Call Stack）：执行同步代码
- 宏任务队列：setTimeout、setInterval、I/O、UI渲染
- 微任务队列：Promise.then、queueMicrotask、MutationObserver
- 执行顺序：同步代码 → 所有微任务 → 一个宏任务 → 所有微任务...

### 核心伪代码示例

**基础执行顺序**
```javascript
console.log('1-同步')
setTimeout(() => console.log('2-宏任务'), 0)
Promise.resolve().then(() => console.log('3-微任务'))
console.log('4-同步')
// 输出: 1-同步 → 4-同步 → 3-微任务 → 2-宏任务


**async/await模式**

/**
 * async函数返回Promise，await暂停执行等待Promise完成
 */
async function fetchData() {
    try {
        const response = await fetch('/api/data')
        const data = await response.json()
        return data
    } catch (error) {
        console.error('请求失败', error)
    }
}
```

**Promise链式调用**
```javascript
/**
 * Promise三种状态: pending → fulfilled/rejected
 * then()处理成功，catch()处理失败
 */
fetch('/api/user')
    .then(res => res.json())
    .then(data => console.log(data))
    .catch(err => console.error(err))
```

### 实用场景

**1. 并发控制调度器**
```javascript
/**
 * 限制同时执行的异步任务数量
 * @param {number} concurrency - 最大并发数
 */
class TaskScheduler {
    constructor(concurrency = 3) {
        this.concurrency = concurrency
        this.running = 0
        this.queue = []
    }

    async add(task) {
        return new Promise((resolve, reject) => {
            this.queue.push({ task, resolve, reject })
            this.process()
        })
    }

    async process() {
        if (this.running >= this.concurrency || !this.queue.length) return
    
        this.running++
        const { task, resolve, reject } = this.queue.shift()
    
        try {
            resolve(await task())
        } catch (error) {
            reject(error)
        } finally {
            this.running--
            this.process()
        }
    }
}
```

**2. 防抖节流**
```javascript
/**
 * 防抖: 延迟执行，重复触发则重新计时
 * @param {Function} func - 要执行的函数
 * @param {number} delay - 延迟时间(ms)
 */
function debounce(func, delay) {
    let timer
    return function(...args) {
        clearTimeout(timer)
        timer = setTimeout(() => func.apply(this, args), delay)
    }
}

/**
 * 节流: 固定时间间隔执行一次
 * @param {Function} func - 要执行的函数
 * @param {number} delay - 时间间隔(ms)
 */
function throttle(func, delay) {
    let timer
    return function(...args) {
        if (timer) return
        timer = setTimeout(() => {
            func.apply(this, args)
            timer = null
        }, delay)
    }
}
```

**3. 异步重试机制**
```javascript
/**
 * 失败后自动重试，支持指数退避
 * @param {Function} fn - 异步函数
 * @param {number} times - 重试次数
 * @param {number} delay - 初始延迟(ms)
 */
async function retry(fn, times = 3, delay = 1000) {
    let lastError

    for (let i = 0; i < times; i++) {
        try {
            return await fn()
        } catch (error) {
            lastError = error
            if (i < times - 1) {
                await new Promise(resolve => setTimeout(resolve, delay))
                delay *= 2 // 指数退避
            }
        }
    }
    throw lastError
}

// 使用示例
retry(() => fetch('/api/data'), 3, 1000)
    .then(res => res.json())
    .catch(err => console.error('重试失败', err))
```

**4. 可取消的Promise**
```javascript
/**
 * 创建可取消的异步操作
 * @param {Function} asyncFn - 异步函数
 * @returns {Object} { promise, cancel }
 */
function createCancellablePromise(asyncFn) {
    let cancelled = false

    const promise = new Promise((resolve, reject) => {
        asyncFn()
            .then(result => !cancelled && resolve(result))
            .catch(error => !cancelled && reject(error))
    })

    return {
        promise,
        cancel: () => { cancelled = true }
    }
}

// 使用示例
const { promise, cancel } = createCancellablePromise(() => fetch('/api/data'))
setTimeout(() => cancel(), 500) // 500ms后取消请求
```

### 关键要点

**错误处理**
- Promise: 使用.catch()或try/catch包裹await
- 错误会沿着Promise链传播，直到遇到catch
- 未捕获的错误触发unhandledrejection事件

**最佳实践**
- 避免长时间阻塞主线程
- 使用async/await替代回调地狱
- requestAnimationFrame优化动画（与浏览器刷新率同步）
- 及时清理定时器和事件监听器

---

## 面试突击模式

### 30秒电梯演讲

JavaScript是单线程语言，通过事件循环机制实现异步。同步代码按顺序执行会阻塞，异步代码不阻塞通过回调处理结果。事件循环不断检查调用栈，执行完同步代码后处理微任务（Promise），再处理宏任务（setTimeout）。微任务优先级高于宏任务。

### 高频考点（必背）

**考点1: 同步异步区别**
同步代码按顺序执行会阻塞后续代码，如alert()；异步代码不阻塞通过回调/Promise处理结果，如setTimeout()、fetch()。异步操作被放入任务队列，等同步代码执行完再处理。

**考点2: 事件循环执行顺序**
同步代码 → 清空所有微任务 → 执行一个宏任务 → 清空所有微任务 → 循环。宏任务包括setTimeout、setInterval、I/O；微任务包括Promise.then、queueMicrotask。

**考点3: 宏任务vs微任务**
微任务优先级高于宏任务。每次事件循环中，先执行完所有微任务，再执行一个宏任务。Promise.then是微任务，setTimeout是宏任务。

**考点4: Promise三种状态**
pending（等待中）、fulfilled（已完成/resolved）、rejected（已拒绝）。状态只能从pending转为fulfilled或rejected，且不可逆。

**考点5: async/await原理**
async函数返回Promise，await暂停函数执行等待Promise完成。await后的代码相当于放在Promise.then中。使异步代码看起来像同步，避免回调地狱。

**考点6: Promise错误处理**
使用.catch()或try/catch包裹await。错误会沿着Promise链传播，跳过中间的then直到遇到catch。未捕获的Promise错误触发unhandledrejection事件。

### 经典面试题

**题目1: 代码输出顺序**
```javascript
console.log('A')
setTimeout(() => console.log('B'), 0)
Promise.resolve().then(() => console.log('C'))
console.log('D')
```
思路: 识别同步/宏任务/微任务，按事件循环顺序执行
答案: A → D → C → B（同步先行，微任务次之，宏任务最后）

代码框架:
```javascript
/**
 * 执行流程分析:
 * 1. console.log('A') - 同步代码，立即执行
 * 2. setTimeout - 宏任务，加入宏任务队列
 * 3. Promise.then - 微任务，加入微任务队列
 * 4. console.log('D') - 同步代码，立即执行
 * 5. 同步代码执行完，清空微任务队列 → 输出C
 * 6. 执行一个宏任务 → 输出B
 */
```

**题目2: async/await执行顺序**
```javascript
async function test() {
    console.log('1')
    await new Promise(resolve => {
        console.log('2')
        resolve()
    })
    console.log('3')
}
test()
console.log('4')
```
思路: Promise构造函数同步执行，await后代码变微任务
答案: 1 → 2 → 4 → 3

代码框架:
```javascript
/**
 * 执行流程:
 * 1. test()调用，console.log('1') - 同步执行
 * 2. Promise构造函数 console.log('2') - 同步执行
 * 3. await暂停，console.log('3')变成微任务
 * 4. console.log('4') - 同步执行
 * 5. 同步代码完成，执行微任务 → 输出3
 */
```

**题目3: 实现sleep函数**

题目: 用Promise实现延迟执行函数

思路: 返回一个在指定时间后resolve的Promise

答案: 使用setTimeout包装在Promise中

代码框架:
```javascript
/**
 * 暂停执行指定时间
 * @param {number} ms - 延迟时间(毫秒)
 * @returns {Promise<void>}
 */
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
}

// 使用示例
async function demo() {
    console.log('开始')
    await sleep(2000) // 暂停2秒
    console.log('2秒后执行')
}
```

**题目4: Promise.all实现**

题目: 手写Promise.all方法

思路: 等待所有Promise完成，任一失败则立即reject

答案: 遍历Promise数组，计数器追踪完成状态

代码框架:
```javascript
/**
 * 并行执行多个Promise，全部成功则返回结果数组
 * @param {Array<Promise>} promises - Promise数组
 * @returns {Promise<Array>
 */
Promise.myAll = function(promises) {
    return new Promise((resolve, reject) => {
        if (!Array.isArray(promises)) {
            return reject(new TypeError('参数必须是数组'))
        }
    
        const results = []
        let count = 0
        const len = promises.length
    
        if (len === 0) return resolve(results)
    
        promises.forEach((promise, index) => {
            // 确保每个元素都是Promise
            Promise.resolve(promise).then(
                value => {
                    results[index] = value // 保持顺序
                    count++
                    if (count === len) resolve(results)
                },
                reason => reject(reason) // 任一失败立即reject
            )
        })
    })
}
```

**题目5: 控制并发请求数量**

题目: 实现最多同时发送N个请求的调度器

思路: 维护队列和运行计数，达到上限则等待

答案: 见日常学习模式中的TaskScheduler实现

代码框架:
```javascript
/**
 * 使用示例
 */
const scheduler = new TaskScheduler(3) // 最多3个并发

// 添加10个任务
const tasks = Array.from({ length: 10 }, (_, i) => 
    () => fetch(`/api/data${i}`).then(res => res.json())
)

// 并发执行，自动控制数量
Promise.all(tasks.map(task => scheduler.add(task)))
    .then(results => console.log('全部完成', results))
```

**题目6: 实现防抖函数**

题目: 手写debounce，延迟执行并可取消

思路: 每次触发重置定时器，延迟时间内重复触发则重新计时

答案: 使用闭包保存timer，clearTimeout清除旧定时器

代码框架:
```javascript
/**
 * 防抖函数，延迟执行且支持立即执行
 * @param {Function} func - 要防抖的函数
 * @param {number} wait - 延迟时间(ms)
 * @param {boolean} immediate - 是否立即执行
 */
function debounce(func, wait, immediate = false) {
    let timer

    return function(...args) {
        const context = this
        const callNow = immediate && !timer
    
        clearTimeout(timer)
        timer = setTimeout(() => {
            timer = null
            if (!immediate) func.apply(context, args)
        }, wait)
    
        if (callNow) func.apply(context, args)
    }
}

// 使用场景: 搜索框输入、窗口resize
const handleSearch = debounce((keyword) => {
    console.log('搜索:', keyword)
}, 500)
```

**题目7: 实现Promise.race**

题目: 手写Promise.race方法

思路: 返回最快完成的Promise结果（成功或失败）

答案: 遍历Promise数组，第一个完成的决定最终结果

代码框架:
```javascript
/**
 * 返回最快完成的Promise结果
 * @param {Array<Promise>} promises - Promise数组
 * @returns {Promise
 */
Promise.myRace = function(promises) {
    return new Promise((resolve, reject) => {
        if (!Array.isArray(promises)) {
            return reject(new TypeError('参数必须是数组'))
        }
    
        // 遍历所有Promise，第一个完成的决定结果
        promises.forEach(promise => {
            Promise.resolve(promise).then(resolve, reject)
        })
    })
}

// 使用场景: 请求超时控制
Promise.race([
    fetch('/api/data'),
    new Promise((_, reject) => 
        setTimeout(() => reject('超时'), 5000)
    )
])
```

**题目8: 红绿灯问题**

题目: 实现红灯3秒、黄灯2秒、绿灯1秒的循环

思路: 使用async/await + sleep实现顺序延迟

答案: 递归调用实现无限循环

代码框架:
```javascript
/**
 * 交通灯控制
 * @param {string} color - 灯的颜色
 * @param {number} duration - 持续时间(秒)
 */
function light(color, duration) {
    return new Promise(resolve => {
        console.log(`${color}灯亮起`)
        setTimeout(resolve, duration * 1000)
    })
}

/**
 * 循环执行红黄绿灯
 */
async function trafficLight() {
    while (true) {
        await light('红', 3)
        await light('黄', 2)
        await light('绿', 1)
    }
}

trafficLight()
```

**题目9: 实现异步串行执行**

题目: 按顺序执行多个异步任务

思路: 使用reduce或for循环配合await

答案: reduce累积Promise链或async/await循环

代码框架:
```javascript
/**
 * 串行执行异步任务数组
 * @param {Array<Function>} tasks - 返回Promise的函数数组
 * @returns {Promise<Array>}
 */
async function serialExecute(tasks) {
    const results = []

    // 方法1: for...of循环
    for (const task of tasks) {
        results.push(await task())
    }

    return results
}

// 方法2: reduce累积Promise链
function serialExecuteReduce(tasks) {
    return tasks.reduce(
        (promise, task) => 
            promise.then(results => 
                task().then(result => [...results, result])
            ),
        Promise.resolve([])
    )
}

// 使用示例
const tasks = [
    () => fetch('/api/1').then(r => r.json()),
    () => fetch('/api/2').then(r => r.json()),
    () => fetch('/api/3').then(r => r.json())
]
serialExecute(tasks).then(results => console.log(results))
```

**题目10: 实现请求重试**

题目: 请求失败后自动重试N次，支持延迟

思路: 循环尝试，失败后延迟再试，最后抛出错误

答案: 见日常学习模式中的retry实现

代码框架:
```javascript
/**
 * 使用示例
 */
retry(
    () => fetch('/api/data').then(r => {
        if (!r.ok) throw new Error('请求失败')
        return r.json()
    }),
    3,     // 重试3次
    1000   // 初始延迟1秒，指数递增
)
.then(data => console.log('成功', data))
.catch(err => console.error('最终失败', err))
```

